<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>FPS Mobile Demo (AI Ring Arena)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <style>
body {
    margin: 0;
    overflow: hidden; 
    background-color: #000;
    -webkit-user-select: none;
    user-select: none;
    touch-action: none; 
}
canvas {
    display: none; 
}
#joystick-move, #fire-button, #crosshair, #player-hp-display, #ai-hp-display {
    display: none; 
}
#start-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    color: white;
    overflow-y: auto; 
    z-index: 10000;
    padding: 20px 0; 
    box-sizing: border-box;
}
#start-screen > div {
    margin: 0 auto; 
    max-width: 500px; 
}
#start-button {
    padding: 15px 30px;
    font-size: 1.5em;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}
#joystick-move {
    position: fixed;
    bottom: 50px; 
    left: 50px; 
    width: 150px; 
    height: 150px;
    z-index: 10;
}
#fire-button {
    position: fixed;
    right: 50px;
    bottom: 85px; 
    width: 80px;
    height: 80px;
    z-index: 10;
    background-color: rgba(255, 100, 100, 0.7);
    border-radius: 50%;
    border: 2px solid #fff;
    color: white;
    font-size: 16px;
    font-weight: bold;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(255, 100, 100, 0.5);
}
#fire-button:active {
    background-color: rgba(255, 50, 50, 1);
}
#crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    pointer-events: none; 
    z-index: 100;
}
.cross-line {
    position: absolute;
    background-color: white;
}
#line-h { width: 100%; height: 1px; top: 50%; transform: translateY(-50%); }
#line-v { width: 1px; height: 100%; left: 50%; transform: translateX(-50%); }

.end-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000; 
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    font-size: 4em;
    font-weight: bold;
    z-index: 200;
    display: none; 
}
#game-over-screen { text-shadow: 0 0 10px red; }
#win-screen { text-shadow: 0 0 10px blue; }
.restart-button {
    margin-top: 20px;
    padding: 10px 20px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    font-size: 1em;
    cursor: pointer;
}
.restart-button:hover { background-color: #45a049; }
    </style>

    <script src="https://unpkg.com/nipplejs@0.8.4/dist/nipplejs.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
</head>
<body>
    <div id="start-screen">
        <div style="padding: 20px; background-color: rgba(0,0,0,0.8); border-radius: 10px; text-align: left;">
            <h1 style="text-align: center;">Gun Fight Settings</h1>

            <h2 style="margin-top: 20px;">HP Settings</h2>
            <label for="player-hp">Player HP:</label>
            <select id="player-hp" style="font-size: 1em; padding: 5px;">
                <option value="3">3</option>
                <option value="10">10</option>
                <option value="Infinity">Infinite</option>
            </select>
            <br>
            <label for="ai-hp" style="margin-top: 10px; display: inline-block;">AI HP:</label>
            <select id="ai-hp" style="font-size: 1em; padding: 5px;">
                <option value="3">3</option>
                <option value="10">10</option>
                <option value="Infinity">Infinite</option>
            </select>

            <h2 style="margin-top: 20px;">Weapon Count</h2>
            <label for="mg-count">Machine Guns (MG):</label>
            <select id="mg-count" style="font-size: 1em; padding: 5px;">
                <option value="0">0</option>
                <option value="1" selected>1</option>
                <option value="3">3</option>
                <option value="5">5</option>
            </select>
            <br>
            <label for="rr-count" style="margin-top: 10px; display: inline-block;">Rocket Launchers (RR):</label>
            <select id="rr-count" style="font-size: 1em; padding: 5px;">
                <option value="0">0</option>
                <option value="1" selected>1</option>
                <option value="3">3</option>
                <option value="5">5</option>
            </select>
            <br>
            <label for="sr-count" style="margin-top: 10px; display: inline-block;">Sniper Rifles (SR):</label>
            <select id="sr-count" style="font-size: 1em; padding: 5px;">
                <option value="0">0</option>
                <option value="1" selected>1</option>
                <option value="3">3</option>
                <option value="5">5</option>
            </select>

            <h2 style="margin-top: 20px;">AI Count</h2>
            <label style="display: block; margin-bottom: 5px;">
                <input type="radio" name="ai-count" value="1"> 1 AI
            </label>
            <label style="display: block;">
                <input type="radio" name="ai-count" value="2" checked> 2 AIs
            </label>

            <h2 style="margin-top: 20px;">Field State</h2>
            <label style="display: block; margin-bottom: 5px;">
                <input type="radio" name="field-state" value="reset" checked> Reset obstacles every round
            </label>
            <label style="display: block;">
                <input type="radio" name="field-state" value="persist"> Keep obstacles destroyed
            </label>
            
            <h2 style="margin-top: 20px;">Map Type</h2>
            <label style="display: block; margin-bottom: 5px;">
                <input type="radio" name="map-type" value="default" checked> Default Map
            </label>
            <label style="display: block; margin-bottom: 5px;">
                <input type="radio" name="map-type" value="random"> Random Map
            </label>
            <label style="display: block;">
                <input type="radio" name="map-type" value="custom"> Custom Map (from Editor)
            </label>
            <div style="text-align: center; margin-top: 15px;">
                <a id="map-editor-link" href="map_editor.html" style="color: #00aaff; text-decoration: none;">- Open Map Editor -</a>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button id="start-game-btn" style="padding: 15px 30px; font-size: 1.5em; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Start Game</button>
            </div>
        </div>
    </div>

    <div id="joystick-move"></div>
    <div id="fire-button">発射</div>
    <!-- Add this new crouch button -->
    <div id="crouch-button" style="position: fixed; right: 20px; bottom: 20px; width: 60px; height: 60px; z-index: 10; background-color: rgba(100, 100, 255, 0.7); border-radius: 50%; border: 2px solid #fff; color: white; font-size: 14px; font-weight: bold; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 0 10px rgba(100, 100, 255, 0.5);">しゃがむ</div>
    
    <div id="crosshair">
        <div class="cross-line" id="line-h"></div>
        <div class="cross-line" id="line-v"></div>
    </div>

    <div id="scope-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: transparent; z-index: 150; display: none; pointer-events: none;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100vmin; height: 100vmin; border-radius: 50%; box-shadow: 0 0 0 100vmax rgba(0,0,0,0.95);"></div>
        <div style="position: absolute; background-color: black; width: 2px; height: 30%; top: 10%; left: 50%; transform: translateX(-50%);"></div>
        <div style="position: absolute; background-color: black; width: 2px; height: 30%; bottom: 10%; left: 50%; transform: translateX(-50%);"></div>
        <div style="position: absolute; background-color: black; height: 2px; width: 30%; left: 10%; top: 50%; transform: translateY(-50%);"></div>
        <div style="position: absolute; background-color: black; height: 2px; width: 30%; right: 10%; top: 50%; transform: translateY(-50%);"></div>
    </div>
    
    <audio id="playerGunSound" src="pgun.mp3" preload="auto"></audio>
    <audio id="mgGunSound" src="mg.mp3" preload="auto"></audio>
    <audio id="rrGunSound" src="rr.mp3" preload="auto"></audio>
    <audio id="srGunSound" src="pss.mp3" preload="auto"></audio>
    <audio id="aimgGunSound" src="aimg.mp3" preload="auto"></audio>
    <audio id="aiGunSound" src="aigun.mp3" preload="auto"></audio>
    <audio id="explosionSound" src="bom.mp3" preload="auto"></audio>
    <audio id="setSound" src="set.mp3" preload="auto"></audio>
    <audio id="aiSrGunSound" src="ss.mp3" preload="auto"></audio> <!-- この行を追加 -->
    
    <div id="game-over-screen" class="end-screen">
        YOU ARE LOSE
        <button class="restart-button">RESTART</button>
        <a href="#" class="settings-link" data-screen-to-hide="game-over-screen" style="margin-top: 10px; color: white; font-size: 0.8em;">Setting</a>
    </div>
    
    <div id="win-screen" class="end-screen">
        YOU ARE WIN
        <button class="restart-button">RESTART</button>
        <a href="#" class="settings-link" data-screen-to-hide="win-screen" style="margin-top: 10px; color: white; font-size: 0.8em;">Setting</a>
    </div>

    <div id="player-hp-display" style="position: fixed; top: 10px; right: 10px; color: red; font-size: 1.5em; font-weight: bold; background-color: rgba(0, 0, 0, 0.5); padding: 5px; z-index: 20;">HP: 3</div>
    <div id="player-weapon-display" style="position: fixed; top: 60px; right: 10px; color: white; font-size: 1em; font-weight: bold; background-color: rgba(0, 0, 0, 0.5); padding: 5px; z-index: 20; text-align: right;">Weapon: pistol<br>Ammo: ∞</div>
    <div id="ai-hp-display" style="position: fixed; top: 10px; left: 10px; color: limegreen; font-size: 1.5em; font-weight: bold; background-color: rgba(0, 0, 0, 0.5); padding: 5px; z-index: 20;">AI 1 HP: 3</div>
    <div id="ai2-hp-display" style="position: fixed; top: 45px; left: 10px; color: cyan; font-size: 1.5em; font-weight: bold; background-color: rgba(0, 0, 0, 0.5); padding: 5px; z-index: 20; display: none;">AI 2 HP: 3</div>
    <div id="red-flash-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; z-index: 1000; pointer-events: none; transition: background-color 0.1s ease-out;"></div>
<div id="weapon-get-display" style="position: fixed; top: 80%; left: 50%; transform: translateX(-50%); color: white; font-size: 2em; font-weight: bold; background-color: rgba(0, 0, 0, 0.5); padding: 10px 20px; border-radius: 10px; z-index: 1100; display: none; text-shadow: 0 0 10px #0ff;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
// デバイスに応じてマップエディタのリンク先を変更
(function() {
    document.addEventListener('DOMContentLoaded', function() {
        const editorLink = document.getElementById('map-editor-link');
        if (editorLink && 'ontouchstart' in window) {
            editorLink.href = 'map_editor_sp.html';
        }
    });
})();

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x87CEEB); 
document.body.appendChild(renderer.domElement);

const clock = new THREE.Clock();
let isGameRunning = false;
let playerTargetHeight = 2.0;
let isCrouchingToggle = false;
const GRAVITY = 9.8; 
let playerHP = 3;
let screenShakeDuration = 0;
const SHAKE_DURATION_MAX = 0.4;
const SHAKE_INTENSITY = 0.2;

let isAIDeathPlaying = false;
const cinematicCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const aiDeathFocusObject = new THREE.Object3D();
scene.add(aiDeathFocusObject);

const BODY_HEIGHT = 2;
const HEAD_RADIUS = 0.5;

const WEAPON_PISTOL = 'pistol';
const WEAPON_MG = 'machinegun';
const WEAPON_RR = 'rocketlauncher';
const WEAPON_SR = 'sniperrifle';
let currentWeapon = WEAPON_PISTOL;
let ammoMG = 0;
let ammoRR = 0;
let ammoSR = 0;
const MAX_AMMO_MG = 50;
const MAX_AMMO_RR = 3;
const MAX_AMMO_SR = 5;
const FIRE_RATE_PISTOL = 0.3;
const FIRE_RATE_MG = 0.1;
const FIRE_RATE_RR = 1.5;
const FIRE_RATE_SR = 2.0;
let lastFireTime = -FIRE_RATE_PISTOL;
let isMouseButtonDown = false;
let isScoping = false;
let isElevating = false;
let elevatingTargetY = 0;
let elevatingTargetObstacle = null;
let currentGroundObstacle = null;
let isLanding = false;
let landingTimer = 0;

const AUTO_AIM_RANGE = 50;
const AUTO_AIM_ANGLE = Math.PI / 8;
const AUTO_AIM_STRENGTH = 0.3;

let font;
const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
    font = loadedFont;
    createWeaponPickups(); 
}, undefined, function (error) {
    console.error('Error loading font:', error);
    font = null; 
    createWeaponPickups(); 
});

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
directionalLight.position.set(0, 10, 5);
scene.add(directionalLight);

const gameSettings = {
    playerHP: 3,
    aiHP: 3,
    mgCount: 1,
    rrCount: 1,
    srCount: 1,
    fieldState: 'reset',
    mapType: 'default', // 'default', 'random', 'custom'
    aiCount: 2
};

const playerGunSound = document.getElementById('playerGunSound');
const mgGunSound = document.getElementById('mgGunSound');
const rrGunSound = document.getElementById('rrGunSound');
const srGunSound = document.getElementById('srGunSound');
const aimgGunSound = document.getElementById('aimgGunSound');
const aiGunSound = document.getElementById('aiGunSound');
const explosionSound = document.getElementById('explosionSound');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const aiSrGunSound = document.getElementById('aiSrGunSound'); // この行を追加
const winScreen = document.getElementById('win-screen');
const playerHPDisplay = document.getElementById('player-hp-display');
const aiHPDisplay = document.getElementById('ai-hp-display');
const redFlashOverlay = document.getElementById('red-flash-overlay');
const scopeOverlay = document.getElementById('scope-overlay');

const ARENA_RADIUS = 60; 
const ARENA_EDGE_THICKNESS = 1; 
const FLOOR_HEIGHT = ARENA_EDGE_THICKNESS / 2;
const ARENA_PLAY_AREA_RADIUS = ARENA_RADIUS - ARENA_EDGE_THICKNESS - 0.5;

const floorGeometry = new THREE.CircleGeometry(ARENA_RADIUS, 64);
const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
const floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -FLOOR_HEIGHT; 
scene.add(floor);

const edgeGeometry = new THREE.TorusGeometry(ARENA_RADIUS, ARENA_EDGE_THICKNESS, 8, 64);
const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x880000 });
const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
edge.rotation.x = Math.PI / 2;
edge.position.y = 0; 
scene.add(edge);

const obstacles = [];
const HIDING_SPOTS = []; 
const weaponPickups = [];
const ladderSwitches = [];
const respawningPickups = [];
const RESPAWN_DELAY = 10;

const PLAYER_INITIAL_POSITION = new THREE.Vector3(0, 2.0, -20);
const AI_INITIAL_POSITION = new THREE.Vector3(0, 0, 20);
const NUM_RANDOM_OBSTACLES = 20; 

const defaultObstaclesConfig = [
    {x: 5, z: 5, height: 1.8}, {x: -5, z: -5}, {x: 0, z: 10, height: 1.8}, {x: 10, z: 0}, {x: -10, z: 5}, {x: 5, z: -10},
    {x: 15, z: 15, height: 1.8}, {x: -15, z: 15}, {x: 15, z: -15, height: 1.8}, {x: -15, z: -15}, {x: 0, z: -18, height: 1.8}, {x: -18, z: 0},
    {x: 25, z: 0, width: 0.5, depth: 10}, {x: -25, z: 0, width: 0.5, depth: 10}, {x: 0, z: 25, width: 10, depth: 0.5}, {x: 0, z: -25, width: 10, depth: 0.5},
    {x: 20, z: 20, height: 1.8}, {x: -20, z: 20}, {x: 20, z: -20, height: 1.8}, {x: -20, z: -20},
    {x: 35, z: 10, width: 0.5, depth: 8}, {x: -35, z: 10, width: 0.5, depth: 8}, {x: 10, z: 35, width: 8, depth: 0.5}, {x: -10, z: 35, width: 8, depth: 0.5},
    {x: 30, z: -30, height: 1.8}, {x: -30, z: -30},
    {x: 40, z: 0, width: 0.5, depth: 15}, {x: -40, z: 0, width: 0.5, depth: 15}, {x: 0, z: 40, width: 15, depth: 0.5, height: 1.8}, {x: 0, z: -40, width: 15, depth: 0.5},
    {x: 0, z: -30, width: 2, height: 1.8, depth: 2},  // Adjusted half-height obstacles
    {x: 10, z: -35, width: 2, height: 1.8, depth: 2},
    {x: -10, z: -35, width: 2, height: 1.8, depth: 2},
    {x: 20, z: -25, width: 3, height: 1.8, depth: 3},
    {x: -20, z: -25, width: 3, height: 1.8, depth: 3},
    {x: 30, z: -15, width: 2, height: 1.8, depth: 2}
];

function getRandomSafePosition() {
    const MAX_ATTEMPTS = 50;
    const MIN_DISTANCE_FROM_PLAYER = 15;
    const MIN_DISTANCE_FROM_OBSTACLE = 5;
    const MIN_DISTANCE_BETWEEN_PICKUPS = 10;
    for (let i = 0; i < MAX_ATTEMPTS; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * (ARENA_RADIUS - ARENA_EDGE_THICKNESS - 5);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const newPosition = new THREE.Vector3(x, 0, z);
        if (newPosition.distanceTo(PLAYER_INITIAL_POSITION) < MIN_DISTANCE_FROM_PLAYER) continue;
        let collisionDetected = false;
        for (const obstacle of obstacles) {
            const obstacleBox = new THREE.Box3().setFromObject(obstacle);
            const obstacleCenter = obstacleBox.getCenter(new THREE.Vector3());
            const distance = newPosition.distanceTo(obstacleCenter);
            const obstacleSize = obstacleBox.getSize(new THREE.Vector3());
            const effectiveObstacleRadius = Math.max(obstacleSize.x, obstacleSize.z) / 2;
            if (distance < MIN_DISTANCE_FROM_OBSTACLE + effectiveObstacleRadius) {
                collisionDetected = true;
                break;
            }
        }
        if (collisionDetected) continue;
        for (const pickup of weaponPickups) {
            if (newPosition.distanceTo(pickup.position) < MIN_DISTANCE_BETWEEN_PICKUPS) {
                collisionDetected = true;
                break;
            }
        }
        if (collisionDetected) continue;
        return newPosition;
    }
    return new THREE.Vector3(0, 0, 0); 
}

function createWeaponPickup(text, position, weaponType) {
    if (!font) {
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const box = new THREE.Mesh(geometry, material);
        box.position.copy(position);
        box.position.y = 1 - FLOOR_HEIGHT;
        box.userData = { type: 'weaponPickup', weaponType: weaponType };
        scene.add(box);
        weaponPickups.push(box);
        return;
    }
    const textGeometry = new THREE.TextGeometry(text, { font: font, size: 1, height: 0.5, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelOffset: 0, bevelSegments: 5 });
    textGeometry.computeBoundingBox();
    const textMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
    textGeometry.translate(-0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x), -0.5 * (textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y), -0.5 * (textGeometry.boundingBox.max.z - textGeometry.boundingBox.min.z));
    textMesh.position.copy(position);
    textMesh.position.y = 0.5; 
    textMesh.userData = { type: 'weaponPickup', weaponType: weaponType };
    scene.add(textMesh);
    weaponPickups.push(textMesh);
}

function createWeaponPickups() {
    for (let i = 0; i < gameSettings.mgCount; i++) {
        createWeaponPickup('MG', getRandomSafePosition(), WEAPON_MG);
    }
    for (let i = 0; i < gameSettings.rrCount; i++) {
        createWeaponPickup('RR', getRandomSafePosition(), WEAPON_RR);
    }
    for (let i = 0; i < gameSettings.srCount; i++) {
        createWeaponPickup('SR', getRandomSafePosition(), WEAPON_SR);
    }
}
const DEFAULT_OBSTACLE_HEIGHT = BODY_HEIGHT + (2 * HEAD_RADIUS);

function createAndAttachLadder(obstacle, ladderFace = -1) {
    const LADDER_WIDTH = 1.5;
    const RUNG_SPACING = 0.5;
    const RUNG_THICKNESS = 0.1;

    const ladderGroup = new THREE.Group();
    ladderGroup.name = 'ladder'; 
    const obstacleSize = new THREE.Vector3();
    new THREE.Box3().setFromObject(obstacle).getSize(obstacleSize);

    const numRungs = Math.floor(obstacleSize.y / RUNG_SPACING);

    const sideMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
    const rungMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });

    const sideGeometry = new THREE.BoxGeometry(RUNG_THICKNESS * 2, obstacleSize.y, RUNG_THICKNESS * 2);
    const leftSide = new THREE.Mesh(sideGeometry, sideMaterial);
    const rightSide = new THREE.Mesh(sideGeometry, sideMaterial);
    
    leftSide.position.set(-LADDER_WIDTH / 2, 0, 0);
    rightSide.position.set(LADDER_WIDTH / 2, 0, 0);
    ladderGroup.add(leftSide);
    ladderGroup.add(rightSide);

    for (let i = 0; i < numRungs; i++) {
        const rungGeometry = new THREE.BoxGeometry(LADDER_WIDTH, RUNG_THICKNESS, RUNG_THICKNESS);
        const rung = new THREE.Mesh(rungGeometry, rungMaterial);
        rung.position.y = -obstacleSize.y / 2 + RUNG_SPACING * (i + 0.5);
        ladderGroup.add(rung);
    }
    
    const face = ladderFace === -1 ? Math.floor(Math.random() * 4) : ladderFace;
    const offset = 0.1; 

    switch (face) {
        case 0: ladderGroup.position.set(0, 0, obstacleSize.z / 2 + offset); break; // +z
        case 1: ladderGroup.position.set(0, 0, -obstacleSize.z / 2 - offset); break; // -z
        case 2: ladderGroup.position.set(obstacleSize.x / 2 + offset, 0, 0); ladderGroup.rotation.y = Math.PI / 2; break; // +x
        case 3: ladderGroup.position.set(-obstacleSize.x / 2 - offset, 0, 0); ladderGroup.rotation.y = -Math.PI / 2; break; // -x
    }
    
    obstacle.add(ladderGroup);

    // ★ センサーエリア生成ロジックの修正
    const sensorAreaDepth = 3; // センサーエリアの奥行き
    const sensorAreaWidth = 3; // センサーエリアの幅
    const sensorAreaHeight = 3; // センサーエリアの高さ（プレイヤーの高さを含むように）

    const sensorGeometry = new THREE.BoxGeometry(sensorAreaWidth, sensorAreaHeight, sensorAreaDepth);
    const sensorMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.3 }); // 青色の半透明
    const sensorArea = new THREE.Mesh(sensorGeometry, sensorMaterial);
    sensorArea.name = 'ladderSensorArea'; // 識別用の名前

    // センサーエリアの奥行き半分 + 梯子の壁からのオフセット (プレイヤーの体分手前)
    const offsetFromLadderWall = sensorAreaDepth / 2 - 0.5; // センサーが梯子に少しめり込むように調整
    
    // まずセンサーエリアの回転を梯子のそれに合わせる
    sensorArea.rotation.y = ladderGroup.rotation.y;

    // 梯子のワールド位置と障害物のワールド位置から方向ベクトルを計算
    const ladderWorldPosition = new THREE.Vector3();
    ladderGroup.getWorldPosition(ladderWorldPosition); // 梯子のワールド位置

    const obstacleWorldPosition = obstacle.position.clone();

    const directionFromObstacleCenterToLadder = ladderWorldPosition.clone().sub(obstacleWorldPosition);
    directionFromObstacleCenterToLadder.y = 0; // 水平方向のみ
    directionFromObstacleCenterToLadder.normalize(); // 正規化

    // センサーエリアの中心位置を計算
    // 梯子のワールド位置から、梯子の方向ベクトルに沿って offsetFromLadderWall だけずらす
    sensorArea.position.copy(ladderWorldPosition.add(directionFromObstacleCenterToLadder.multiplyScalar(offsetFromLadderWall)));
    sensorArea.position.y = (sensorAreaHeight / 2) - FLOOR_HEIGHT; // 地面を基準に配置

    sensorArea.userData.obstacle = obstacle; 
    sensorArea.userData.ladderPos = ladderWorldPosition; // ここは修正後も梯子の位置を保存しておく
    sensorArea.visible = false; // 非表示にする
    
    scene.add(sensorArea);
    ladderSwitches.push(sensorArea);
}

function createObstacle(x, z, width = 2, height = DEFAULT_OBSTACLE_HEIGHT, depth = 2) {
    const boxGeometry = new THREE.BoxGeometry(width, height, depth);
    const boxMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    box.position.set(x, (height / 2) - FLOOR_HEIGHT, z); 
    scene.add(box);
    obstacles.push(box);

    // 一定以上の高さの障害物には梯子を追加
    if (height > DEFAULT_OBSTACLE_HEIGHT * 1.5) {
        createAndAttachLadder(box);
    }

    const HIDING_DISTANCE = 1.5; 
    // HIDING_SPOTSに位置情報と関連する障害物情報を格納
    HIDING_SPOTS.push({ position: new THREE.Vector3(x + HIDING_DISTANCE, 0, z + HIDING_DISTANCE), obstacle: box });
    HIDING_SPOTS.push({ position: new THREE.Vector3(x - HIDING_DISTANCE, 0, z + HIDING_DISTANCE), obstacle: box });
    HIDING_SPOTS.push({ position: new THREE.Vector3(x + HIDING_DISTANCE, 0, z - HIDING_DISTANCE), obstacle: box });
    HIDING_SPOTS.push({ position: new THREE.Vector3(x - HIDING_DISTANCE, 0, z - HIDING_DISTANCE), obstacle: box });
}

function createSniperTower(x, z) {
    const TOWER_WIDTH = 6;
    const TOWER_DEPTH = 6;
    const TOWER_HEIGHT = DEFAULT_OBSTACLE_HEIGHT * 3; // DEFAULT_OBSTACLE_HEIGHTは3.0なので、TOWER_HEIGHTは9.0
    const towerYPos = (TOWER_HEIGHT / 2) - FLOOR_HEIGHT;

    // 1. Create the main tower structure
    const towerGeometry = new THREE.BoxGeometry(TOWER_WIDTH, TOWER_HEIGHT, TOWER_DEPTH);
    const towerMaterial = new THREE.MeshLambertMaterial({ color: 0x4A4A4A }); // Dark grey
    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
    tower.position.set(x, towerYPos, z);
    
    // 塔本体に userData を追加
    tower.userData.isTower = true;
    // 塔のHPを計算 (例: 通常障害物の体積比を考慮)
    const DEFAULT_OBSTACLE_VOLUME = 2 * DEFAULT_OBSTACLE_HEIGHT * 2; // 幅2, 高さDEFAULT_OBSTACLE_HEIGHT, 奥行き2
    const TOWER_VOLUME = TOWER_WIDTH * TOWER_HEIGHT * TOWER_DEPTH;
    // HPは体積比の約半分 (おおよそ1ロケット弾で0.5ダメージ)
    tower.userData.hp = Math.round(TOWER_VOLUME / DEFAULT_OBSTACLE_VOLUME / 2); // おおよそ20HP
    tower.userData.coverWalls = []; // カバーウォールを格納する配列
    
    scene.add(tower);
    obstacles.push(tower);

    // Add rooftop floor for collision
    const rooftopY = tower.position.y + (TOWER_HEIGHT / 2);
    const rooftopFloorGeometry = new THREE.BoxGeometry(TOWER_WIDTH, 0.1, TOWER_DEPTH);
    const rooftopFloorMaterial = new THREE.MeshLambertMaterial({ color: 0x666666, transparent: true, opacity: 0.0 }); // Invisible but collidable
    const rooftopFloor = new THREE.Mesh(rooftopFloorGeometry, rooftopFloorMaterial);
    rooftopFloor.position.set(x, rooftopY, z);
    rooftopFloor.userData.parentTower = tower; // Link to the main tower body
    scene.add(rooftopFloor);
    obstacles.push(rooftopFloor);

    // 2. Determine the outward face for the ladder (0: +z, 1: -z, 2: +x, 3: -x)
    let ladderFace;
    // Simplified logic: Place ladder on the face furthest from the center (0,0)
    if (Math.abs(x) > Math.abs(z)) {
        ladderFace = x > 0 ? 2 : 3; // Furthest on X-axis, so ladder on +x or -x face
    } else {
        ladderFace = z > 0 ? 0 : 1; // Furthest on Z-axis, so ladder on +z or -z face
    }

    // 3. Attach the ladder
    createAndAttachLadder(tower, ladderFace);

    // 4. Add rooftop cover walls
    const wallHeight = 1.0;
    const wallThickness = 0.5;
    const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x880000 });
    
    // Defines the 4 potential walls
    const wallDefs = [
        { face: 0, w: TOWER_WIDTH + wallThickness, h: wallHeight, d: wallThickness, ox: 0, oz: TOWER_DEPTH / 2 }, // +z
        { face: 1, w: TOWER_WIDTH + wallThickness, h: wallHeight, d: wallThickness, ox: 0, oz: -TOWER_DEPTH / 2 }, // -z
        { face: 2, w: wallThickness, h: wallHeight, d: TOWER_DEPTH, ox: TOWER_WIDTH / 2, oz: 0 }, // +x
        { face: 3, w: wallThickness, h: wallHeight, d: TOWER_DEPTH, ox: -TOWER_WIDTH / 2, oz: 0 }  // -x
    ];

    for (const def of wallDefs) {
        if (def.face === ladderFace) continue; // Don't build a wall where the ladder is

        const wallGeometry = new THREE.BoxGeometry(def.w, def.h, def.d);
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.set(
            tower.position.x + def.ox,
            rooftopY + (def.h / 2), // The center of the wall should be half its height above the roof
            tower.position.z + def.oz
        );
        wall.userData.isTowerWall = true;
        wall.userData.parentTowerRef = tower; // 親の塔本体への参照を追加
        tower.userData.coverWalls.push(wall); // 塔本体の配列にカバーウォールを追加
        scene.add(wall);
        obstacles.push(wall);
    }
}

function generateObstaclePositions(count) {
    const generatedConfigs = [];
    const MIN_OBSTACLE_SIZE = 2;
    const MAX_OBSTACLE_SIZE = 15;

    const playerExclusionBox = new THREE.Box3().setFromCenterAndSize(
        PLAYER_INITIAL_POSITION,
        new THREE.Vector3(5, BODY_HEIGHT + (2 * HEAD_RADIUS), 5)
    );
    // 全てのAI初期位置の除外ボックスを作成
    const aiExclusionBoxes = AI_INITIAL_POSITIONS.map(pos => {
        return new THREE.Box3().setFromCenterAndSize(
            pos,
            new THREE.Vector3(5, BODY_HEIGHT + (2 * HEAD_RADIUS), 5)
        );
    });

    for (let i = 0; i < count; i++) {
        let positionFound = false;
        let attempts = 0;
        while (!positionFound && attempts < 100) {
            const width = Math.floor(Math.random() * (MAX_OBSTACLE_SIZE - MIN_OBSTACLE_SIZE + 1)) + MIN_OBSTACLE_SIZE;
            const depth = Math.floor(Math.random() * (MAX_OBSTACLE_SIZE - MIN_OBSTACLE_SIZE + 1)) + MIN_OBSTACLE_SIZE;
            
            // 障害物のサイズを考慮して中心座標の生成範囲を制限
            const effectiveRadius = ARENA_RADIUS - ARENA_EDGE_THICKNESS - Math.max(width, depth) / 2;
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * effectiveRadius;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            const newObstacleBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(x, 0, z),
                new THREE.Vector3(width, BODY_HEIGHT + (2 * HEAD_RADIUS), depth)
            );
            
            // プレイヤーおよび全てのAIのスポーン地点との衝突を確認
            let intersectsWithSpawn = newObstacleBox.intersectsBox(playerExclusionBox);
            if (!intersectsWithSpawn) {
                for (const box of aiExclusionBoxes) {
                    if (newObstacleBox.intersectsBox(box)) {
                        intersectsWithSpawn = true;
                        break;
                    }
                }
            }
            if (intersectsWithSpawn) {
                attempts++;
                continue;
            }

            // 既存の障害物とのオーバーラップを確認
            let overlapsWithExisting = false;
            for (const existingConfig of generatedConfigs) {
                const existingObstacleBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(existingConfig.x, 0, existingConfig.z),
                    new THREE.Vector3(existingConfig.width, BODY_HEIGHT + (2 * HEAD_RADIUS), existingConfig.depth)
                );
                if (newObstacleBox.intersectsBox(existingObstacleBox)) {
                    overlapsWithExisting = true;
                    break;
                }
            }

            if (!overlapsWithExisting) {
                generatedConfigs.push({ x, z, width, depth });
                positionFound = true;
            }
            attempts++;
        }
    }
    return generatedConfigs;
}

function resetObstacles() {
    for (const obstacle of obstacles) {
        if (obstacle.parent) { 
            obstacle.parent.remove(obstacle);
        }
    }
    obstacles.length = 0;
    HIDING_SPOTS.length = 0;

    // スイッチもクリアする
    for (const ladderSwitch of ladderSwitches) {
        scene.remove(ladderSwitch);
    }
    ladderSwitches.length = 0;

    let obstaclesToCreate = [];
    
    // gameSettings.mapType の値に応じて障害物の設定を分岐
    if (gameSettings.mapType === 'random') {
        obstaclesToCreate = generateObstaclePositions(NUM_RANDOM_OBSTACLES);
    } else if (gameSettings.mapType === 'custom') {
        const customMapData = localStorage.getItem('customMapData');
        if (customMapData) {
            try {
                obstaclesToCreate = JSON.parse(customMapData);
            } catch (e) {
                console.error("Error parsing custom map data. Falling back to default map.", e);
                obstaclesToCreate = defaultObstaclesConfig; // パースに失敗したらデフォルトを使用
            }
        } else {
            // データがなければデフォルトを使用
            obstaclesToCreate = defaultObstaclesConfig;
        }
    } else { // 'default' またはそれ以外の場合
        obstaclesToCreate = defaultObstaclesConfig;
        createSniperTower(35, -35); // Player side tower
        createSniperTower(-35, 35); // AI side tower
    }

    for (const config of obstaclesToCreate) {
        // config.height がなければ undefined を渡し、createObstacle側のデフォルト値を使わせる
        createObstacle(config.x, config.z, config.width, config.height || undefined, config.depth);
    }
}

resetObstacles(); 

const player = new THREE.Object3D(); 
player.add(camera);
scene.add(player);
player.position.copy(PLAYER_INITIAL_POSITION);
player.rotation.y = Math.PI;
camera.position.set(0, 0, 0);

// Player model for death animation
let playerBody, playerHead, playerModel;
let isPlayerDeathPlaying = false;

const playerMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 }); // Yellow
playerBody = new THREE.Mesh(new THREE.BoxGeometry(1.0, BODY_HEIGHT, 1.0), playerMaterial);
playerHead = new THREE.Mesh(new THREE.SphereGeometry(HEAD_RADIUS, 16, 16), playerMaterial);
playerBody.position.y = BODY_HEIGHT / 2;
playerHead.position.y = BODY_HEIGHT + HEAD_RADIUS;

playerModel = new THREE.Group();
playerModel.add(playerBody);
playerModel.add(playerHead);
player.add(playerModel);
playerModel.visible = false;


const AI_SPEED = 15.0;      
const HIDE_DURATION = 3.0;  
const ATTACK_DURATION = 1.0; 
const EVASION_RANGE = 3.5; 
const ARRIVAL_THRESHOLD = 1.0; 
const AVOIDANCE_RAY_DISTANCE = 3.0; 
const FIRING_RATE = 0.2; 
const EXPLOSION_RADIUS = 25;
const EXPLOSION_FORCE = 50;

const ais = [];
const AI_INITIAL_POSITIONS = [
    new THREE.Vector3(0, 0, 20),
    new THREE.Vector3(15, 0, 20),
];

function createAI(color) {
    const bodyGeometry = new THREE.BoxGeometry(1.0, BODY_HEIGHT, 1.0);
    const headGeometry = new THREE.SphereGeometry(HEAD_RADIUS, 16, 16);
    const material = new THREE.MeshLambertMaterial({ color: color });
    const body = new THREE.Mesh(bodyGeometry, material);
    const head = new THREE.Mesh(headGeometry, material);
    body.position.y = BODY_HEIGHT / 2;
    head.position.y = BODY_HEIGHT + HEAD_RADIUS;
    const aiObject = new THREE.Group();
    aiObject.add(body);
    aiObject.add(head);
    aiObject.position.y = -FLOOR_HEIGHT; 
    aiObject.lastHiddenTime = 0; 
    aiObject.lastAttackTime = 0; 
    aiObject.currentAttackTime = 0; 
    aiObject.state = 'HIDING'; 
    aiObject.currentObstacle = null; 
    aiObject.avoiding = false; 
    aiObject.currentWeapon = WEAPON_PISTOL;
    aiObject.ammoMG = 0;
    aiObject.ammoRR = 0;
    aiObject.ammoSR = 0;
    aiObject.targetWeaponPickup = null;
    aiObject.hp = 3;
    aiObject.strafeDirection = (Math.random() > 0.5 ? 1 : -1);
    aiObject.targetPosition = new THREE.Vector3(); 
    aiObject.isCrouching = false; 
    return aiObject;
}

const raycaster = new THREE.Raycaster();


function isVisibleToPlayer(ai) {
    const playerPos = new THREE.Vector3();
    player.getWorldPosition(playerPos);
    const aiHeadPos = ai.children[1].getWorldPosition(new THREE.Vector3());
    const direction = new THREE.Vector3().subVectors(aiHeadPos, playerPos).normalize();
    raycaster.set(playerPos, direction);
    const intersects = raycaster.intersectObjects(obstacles, true);
    const distanceToAI = playerPos.distanceTo(aiHeadPos);
    if (intersects.length > 0) {
        if (intersects[0].distance < distanceToAI - 0.1) {
            ai.currentObstacle = intersects[0].object; 
            return false; 
        }
    }
    ai.currentObstacle = null; 
    return true;
}

function checkLineOfSight(startPosition, endPosition, objectsToAvoid) {
    const direction = new THREE.Vector3().subVectors(endPosition, startPosition).normalize();
    const distance = startPosition.distanceTo(endPosition);
    raycaster.set(startPosition, direction);
    raycaster.far = distance;
    const intersects = raycaster.intersectObjects(objectsToAvoid, true);
    return intersects.length === 0;
}

function findEvasionSpot(ai) {
    const playerPos = player.position.clone();
    let bestObstacle = null;
    if (ai.currentObstacle) {
        bestObstacle = ai.currentObstacle.parent; 
    } else if (obstacles.length > 0) {
        bestObstacle = obstacles[0];
        for (let i = 1; i < obstacles.length; i++) {
            const current = obstacles[i];
            if (current.position.distanceTo(ai.position) < bestObstacle.position.distanceTo(ai.position)) {
                bestObstacle = current;
            }
        }
    } else {
        return false; 
    }

    if (bestObstacle) { 
        const obsPos = bestObstacle.position.clone();
        const directionToPlayer = new THREE.Vector3().subVectors(playerPos, obsPos).normalize();
        const target = obsPos.sub(directionToPlayer.multiplyScalar(EVASION_RANGE));
        target.y = 0;
        ai.state = 'EVADING';
        ai.targetPosition.copy(target);
        ai.avoiding = false; 
        return true;
    }
    return false; 
}

function findNewHidingSpot(ai) {
    const currentAIPos = ai.position.clone();
    let bestSpot = null;
    let maxDistanceToPlayer = -Infinity;
    if (HIDING_SPOTS.length === 0) return false;

    const aiStandingHeight = BODY_HEIGHT + HEAD_RADIUS * 2; // AIの立ち姿勢の全高 (3.0)
    const aiCrouchingHeight = aiStandingHeight * 0.7; // AIのしゃがみ姿勢の全高 (2.1)

    // 隠れるのに適したスポットのリスト
    const viableCrouchSpots = [];
    // 通常のスポットのリスト
    const regularSpots = [];

    for (const spotInfo of HIDING_SPOTS) { // spotはspotInfoオブジェクトに変更
        const spotPosition = spotInfo.position; // spotInfo.positionを使用
        const obstacle = spotInfo.obstacle; // spotInfo.obstacleを使用

        // 障害物がない、または既に破壊されている場合はスキップ
        if (!obstacle || !obstacle.parent) continue;

        const obstacleBox = new THREE.Box3().setFromObject(obstacle);
        const obstacleHeight = obstacleBox.max.y - obstacleBox.min.y;

        // 障害物がAIの立ち姿勢より低く、かつAIがしゃがむことで隠れられる高さの場合
        if (obstacleHeight < aiStandingHeight && obstacleHeight >= aiCrouchingHeight * 0.8) {
            viableCrouchSpots.push(spotInfo); // しゃがんで隠れるのに適したスポット
        } else {
            regularSpots.push(spotInfo); // 通常のスポット
        }
    }

    let spotsToConsider = viableCrouchSpots;
    if (spotsToConsider.length === 0) {
        spotsToConsider = regularSpots; // しゃがんで隠れるスポットがなければ、通常のスポットを考慮
    }
    if (spotsToConsider.length === 0) return false; // 考慮するスポットがなければ終了

    // 考慮するスポットの中から最適なものを選ぶ
    for (const spotInfo of spotsToConsider) {
        const spotPosition = spotInfo.position;
        if (spotPosition.distanceTo(currentAIPos) < ARRIVAL_THRESHOLD) continue; 
        const distanceToPlayer = spotPosition.distanceTo(player.position);
        if (distanceToPlayer > maxDistanceToPlayer) {
            maxDistanceToPlayer = distanceToPlayer;
            bestSpot = spotInfo; // bestSpotもspotInfoオブジェクトを格納
        }
    }

    if (bestSpot) {
        ai.state = 'MOVING';
        ai.targetPosition.copy(bestSpot.position); // bestSpot.positionを使用
        ai.avoiding = false;
        return true;
    }
    return false;
}

function findObstacleAvoidanceSpot(ai, collisionDirection) {
     const currentAIPos = ai.position.clone();
     const evasionSign = Math.random() > 0.5 ? 1 : -1; 
     const evasionDirection = new THREE.Vector3(collisionDirection.z * evasionSign, 0, -collisionDirection.x * evasionSign).normalize();
     const evasionTarget = currentAIPos.clone().add(evasionDirection.multiplyScalar(AVOIDANCE_RAY_DISTANCE * 2));
     evasionTarget.y = 0;
     ai.avoiding = true;
     ai.targetPosition.copy(evasionTarget); 
}

function findAndTargetWeapon(ai) {
    const needsUpgrade = (ai.currentWeapon === WEAPON_PISTOL || 
                         (ai.currentWeapon === WEAPON_MG && ai.ammoMG < 10) || 
                         (ai.currentWeapon === WEAPON_RR && ai.ammoRR < 1) ||
                         (ai.currentWeapon === WEAPON_SR && ai.ammoSR < 1));

    if (!needsUpgrade || weaponPickups.length === 0 || ai.targetWeaponPickup) {
        return false;
    }

    let bestPickup = null;
    let minDistance = Infinity;

    for (const pickup of weaponPickups) {
        const aiHeadPos = ai.children[1].getWorldPosition(new THREE.Vector3());
        if (checkLineOfSight(aiHeadPos, pickup.position, obstacles)) {
            const distance = ai.position.distanceTo(pickup.position);
            if (distance < minDistance) {
                minDistance = distance;
                bestPickup = pickup;
            }
        }
    }

    if (bestPickup) {
        ai.targetWeaponPickup = bestPickup;
        ai.targetPosition.copy(bestPickup.position);
        ai.state = 'MOVING';
        return true;
    }
    return false;
}

const projectiles = []; 
const debris = []; 
const projectileSpeed = 50; 

function createProjectile(startPos, direction, color, size = 0.1, isRocket = false, source = 'unknown', speed = projectileSpeed, isSniper = false) {
    let bulletGeometry;
    const bulletLength = size * 5; 
    const bulletRadius = size / 2;
    bulletGeometry = new THREE.CylinderGeometry(bulletRadius, bulletRadius, bulletLength, 8);
    
    const bulletMaterial = new THREE.MeshBasicMaterial({ color: color });
    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
    bullet.position.copy(startPos).add(direction.clone().multiplyScalar(0.5));
    
    const axis = new THREE.Vector3(0, 1, 0); 
    const quaternion = new THREE.Quaternion();
    quaternion.setFromUnitVectors(axis, direction.normalize());
    bullet.applyQuaternion(quaternion);

    scene.add(bullet);
    const velocity = direction.clone().normalize().multiplyScalar(speed);
    projectiles.push({ mesh: bullet, velocity: velocity, isRocket: isRocket, source: source, isSniper: isSniper });
}

function createExplosionEffect(position) {
    const explosionGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const explosionMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 1.0 });
    const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
    explosionMesh.position.copy(position);
    scene.add(explosionMesh);
    const scaleTarget = 25;
    const duration = 0.3;
    new TWEEN.Tween(explosionMesh.scale).to({ x: scaleTarget, y: scaleTarget, z: scaleTarget }, duration * 1000).easing(TWEEN.Easing.Quadratic.Out).start();
    new TWEEN.Tween(explosionMaterial).to({ opacity: 0 }, duration * 1000).easing(TWEEN.Easing.Quadratic.Out).onComplete(() => {
        scene.remove(explosionMesh);
        explosionMesh.geometry.dispose();
        explosionMesh.material.dispose();
    }).start();
}

function destroyObstacle(obstacle, explosionPosition) {
    const obstacleIndex = obstacles.indexOf(obstacle);
    if (obstacleIndex > -1) {
        obstacles.splice(obstacleIndex, 1);
    } else {
        return;
    }

    // もし破壊対象が塔本体であれば、関連するカバーウォールも削除する
    if (obstacle.userData.isTower) {
        for (const wall of obstacle.userData.coverWalls) {
            const wallIndex = obstacles.indexOf(wall);
            if (wallIndex > -1) {
                obstacles.splice(wallIndex, 1); // 障害物リストからカバーウォールを削除
            }
            if (wall.parent) {
                wall.parent.remove(wall); // シーンからカバーウォールを削除
            }
            if (wall.geometry) wall.geometry.dispose();
            if (wall.material) wall.material.dispose();
        }
    }

    // 梯子グループとセンサーエリアの削除
    // 1. 梯子グループを障害物から削除
    const ladderGroup = obstacle.children.find(child => child.name === 'ladder');
    if (ladderGroup) {
        obstacle.remove(ladderGroup);
        // 必要に応じてladderGroupのdisposeも行う
        // ladderGroup.traverse(obj => { if (obj.geometry) obj.geometry.dispose(); if (obj.material) obj.material.dispose(); });
    }

    // 2. 関連するセンサーエリアをladderSwitches配列とシーンから削除
    for (let i = ladderSwitches.length - 1; i >= 0; i--) {
        const sensorArea = ladderSwitches[i];
        if (sensorArea.userData.obstacle === obstacle) {
            scene.remove(sensorArea);
            ladderSwitches.splice(i, 1);
            // 必要に応じてsensorAreaのdisposeも行う
            if (sensorArea.geometry) sensorArea.geometry.dispose();
            if (sensorArea.material) sensorArea.material.dispose();
        }
    }

    scene.remove(obstacle);
    const NUM_FRAGMENTS_PER_AXIS = 3;
    const fragmentSize = new THREE.Vector3(obstacle.geometry.parameters.width / NUM_FRAGMENTS_PER_AXIS, obstacle.geometry.parameters.height / NUM_FRAGMENTS_PER_AXIS, obstacle.geometry.parameters.depth / NUM_FRAGMENTS_PER_AXIS);
    const fragmentGeometry = new THREE.BoxGeometry(fragmentSize.x, fragmentSize.y, fragmentSize.z);
    const fragmentMaterial = obstacle.material;
    for (let i = 0; i < NUM_FRAGMENTS_PER_AXIS; i++) {
        for (let j = 0; j < NUM_FRAGMENTS_PER_AXIS; j++) {
            for (let k = 0; k < NUM_FRAGMENTS_PER_AXIS; k++) {
                const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);
                const relativePos = new THREE.Vector3((i - (NUM_FRAGMENTS_PER_AXIS - 1) / 2) * fragmentSize.x, (j - (NUM_FRAGMENTS_PER_AXIS - 1) / 2) * fragmentSize.y, (k - (NUM_FRAGMENTS_PER_AXIS - 1) / 2) * fragmentSize.z);
                fragment.position.copy(obstacle.position).add(relativePos);
                scene.add(fragment);
                const forceDirection = new THREE.Vector3().subVectors(fragment.position, explosionPosition).normalize();
                const forceMagnitude = 10 + Math.random() * 15;
                const velocity = forceDirection.multiplyScalar(forceMagnitude);
                velocity.y += Math.random() * 10;
                const angularVelocity = new THREE.Vector3((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                debris.push({ mesh: fragment, velocity: velocity, angularVelocity: angularVelocity, life: 3 + Math.random() * 2 });
            }
        }
    }
    obstacle.geometry.dispose();
}

function createSmokeEffect(position) {
    const SMOKE_PARTICLE_COUNT = 5;
    for (let i = 0; i < SMOKE_PARTICLE_COUNT; i++) {
        const smokeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const smokeMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.6
        });
        const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
        const offset = new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5);
        smoke.position.copy(position).add(offset);
        scene.add(smoke);
        const scaleTarget = 4 + Math.random() * 2;
        const duration = 0.5 + Math.random() * 0.3;
        new TWEEN.Tween(smoke.scale).to({ x: scaleTarget, y: scaleTarget, z: scaleTarget }, duration * 1000).easing(TWEEN.Easing.Quadratic.Out).start();
        new TWEEN.Tween(smokeMaterial).to({ opacity: 0 }, duration * 1000).easing(TWEEN.Easing.Linear.None).onComplete(() => {
            scene.remove(smoke);
            smoke.geometry.dispose();
            smoke.material.dispose();
        }).start();
    }
}

function createRedSmokeEffect(position) {
    const SMOKE_PARTICLE_COUNT = 7; // パーティクル数を15から7に半減
    for (let i = 0; i < SMOKE_PARTICLE_COUNT; i++) {
        const smokeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const smokeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000, 
            transparent: true,
            opacity: 0.8 
        });
        const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
        const offset = new THREE.Vector3((Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5); 
        smoke.position.copy(position).add(offset);
        scene.add(smoke);

        const scaleTarget = 5 + Math.random() * 5; 
        const duration = 0.4 + Math.random() * 0.25; // 表示時間を約半分に短縮
        new TWEEN.Tween(smoke.scale).to({ x: scaleTarget, y: scaleTarget, z: scaleTarget }, duration * 1000).easing(TWEEN.Easing.Quadratic.Out).start();
        new TWEEN.Tween(smokeMaterial).to({ opacity: 0 }, duration * 1000).easing(TWEEN.Easing.Linear.None).onComplete(() => {
            scene.remove(smoke);
            smoke.geometry.dispose();
            smoke.material.dispose();
        }).start();
    }
}

function createRocketTrail(position) {
    const trailGeometry = new THREE.SphereGeometry(0.1, 4, 4);
    const trailMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff, 
        transparent: true,
        opacity: 0.8
    });
    const particle = new THREE.Mesh(trailGeometry, trailMaterial);
    particle.position.copy(position);
    scene.add(particle);

    const duration = 0.8 + Math.random() * 0.5;
    new TWEEN.Tween(particle.scale)
        .to({ x: 0.01, y: 0.01, z: 0.01 }, duration * 1000)
        .easing(TWEEN.Easing.Quadratic.Out)
        .start();
    new TWEEN.Tween(trailMaterial)
        .to({ opacity: 0 }, duration * 1000)
        .easing(TWEEN.Easing.Linear.None)
        .onComplete(() => {
            scene.remove(particle);
            particle.geometry.dispose();
            particle.material.dispose();
        })
        .start();
}

function handleFirePress() {
    if (!isGameRunning || playerHP <= 0) return;

    if (currentWeapon === WEAPON_SR) {
        if (ammoSR > 0 && !isScoping) {
            const timeSinceLastFire = clock.getElapsedTime() - lastFireTime;
            if (timeSinceLastFire > FIRE_RATE_SR) {
                isScoping = true;
                scopeOverlay.style.display = 'block';
                document.getElementById('crosshair').style.display = 'none';
                new TWEEN.Tween(camera).to({ fov: 30 }, 100).easing(TWEEN.Easing.Quadratic.Out).onUpdate(() => camera.updateProjectionMatrix()).start();
            }
        }
    } else {
        isMouseButtonDown = true;
        if (currentWeapon !== WEAPON_MG) {
            shoot();
        }
    }
}

function handleFireRelease() {
    if (!isGameRunning) return;

    if (isScoping) {
        isScoping = false;
        
        const timeSinceLastFire = clock.getElapsedTime() - lastFireTime;
        if (ammoSR > 0 && timeSinceLastFire > FIRE_RATE_SR) {
            
            srGunSound.cloneNode(true).play().catch(e => console.error("Audio playback failed:", e));

            const startPosition = new THREE.Vector3();
            player.getWorldPosition(startPosition);
            let direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            createProjectile(startPosition, direction, 0xffff00, 0.1, false, 'player', projectileSpeed * 2, true);

            lastFireTime = clock.getElapsedTime();
            if (--ammoSR === 0) {
                 setTimeout(() => { 
                    currentWeapon = WEAPON_PISTOL;
                    scopeOverlay.style.display = 'none';
                    document.getElementById('crosshair').style.display = 'block';
                    new TWEEN.Tween(camera).to({ fov: 75 }, 100).easing(TWEEN.Easing.Quadratic.Out).onUpdate(() => camera.updateProjectionMatrix()).start();
                }, 100);
            }
        }
        setTimeout(() => { 
            if(!isScoping) { 
                scopeOverlay.style.display = 'none';
                document.getElementById('crosshair').style.display = 'block';
                new TWEEN.Tween(camera).to({ fov: 75 }, 100).easing(TWEEN.Easing.Quadratic.Out).onUpdate(() => camera.updateProjectionMatrix()).start();
            }
        }, 100); 
    }
    
    isMouseButtonDown = false;
}

function shoot() {
    if (!isGameRunning || playerHP <= 0) return;
    let canFire = false;
    let projectileColor = 0xffff00;
    let projectileSize = 0.1;
    let fireRate = FIRE_RATE_PISTOL;
    switch (currentWeapon) {
        case WEAPON_PISTOL:
            canFire = true;
            fireRate = FIRE_RATE_PISTOL;
            break;
        case WEAPON_MG:
            if (ammoMG > 0) {
                canFire = true;
                projectileColor = 0xffff00;
                fireRate = FIRE_RATE_MG;
            }
            break;
        case WEAPON_RR:
            if (ammoRR > 0) {
                canFire = true;
                projectileColor = 0xff8c00;
                projectileSize = 0.5;
                fireRate = FIRE_RATE_RR;
            }
            break;
    }
    const timeSinceLastFire = clock.getElapsedTime() - lastFireTime;
    if (canFire && timeSinceLastFire > fireRate) {
        let soundToPlay = playerGunSound;
        if (currentWeapon === WEAPON_MG) soundToPlay = mgGunSound;
        else if (currentWeapon === WEAPON_RR) soundToPlay = rrGunSound;
        soundToPlay.cloneNode(true).play().catch(e => console.error("Audio playback failed:", e));
        const startPosition = new THREE.Vector3();
        player.getWorldPosition(startPosition); 
        let direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        let bestTarget = null;
        let minAngle = AUTO_AIM_ANGLE;

        for (const currentAi of ais) {
            const aiPosition = currentAi.children[1].getWorldPosition(new THREE.Vector3());
            if (startPosition.distanceTo(aiPosition) < AUTO_AIM_RANGE) {
                const directionToAI = new THREE.Vector3().subVectors(aiPosition, startPosition).normalize();
                const angle = direction.angleTo(directionToAI);
                if (angle < minAngle) {
                    minAngle = angle;
                    bestTarget = directionToAI;
                }
            }
        }

        if (bestTarget) {
            direction.lerp(bestTarget, AUTO_AIM_STRENGTH).normalize();
        }
        createProjectile(startPosition, direction, projectileColor, projectileSize, currentWeapon === WEAPON_RR, 'player'); 
        lastFireTime = clock.getElapsedTime();
        if (currentWeapon === WEAPON_MG) {
            if (--ammoMG === 0) currentWeapon = WEAPON_PISTOL;
        } else if (currentWeapon === WEAPON_RR) {
            if (--ammoRR === 0) currentWeapon = WEAPON_PISTOL;
        }
    }
}

function aiShoot(ai, timeElapsed) {
    if (!isGameRunning || playerHP <= 0) return;

    const startPosition = ai.position.clone().add(new THREE.Vector3(0, ai.isCrouching ? BODY_HEIGHT * 0.75 * 0.5 : BODY_HEIGHT * 0.75, 0)); // AIの体の約3/4の高さから発射。しゃがみ時は半分の高さ
    const playerBodyPos = player.position.clone().add(new THREE.Vector3(0, 0.5, 0));
    
    if (!checkLineOfSight(startPosition, playerBodyPos, obstacles)) {
        return; 
    }

    const direction = new THREE.Vector3().subVectors(playerBodyPos, startPosition);
    const distanceToPlayer = direction.length();
    direction.normalize();

    raycaster.set(startPosition, direction);
    const intersects = raycaster.intersectObjects(obstacles, true);

    if (intersects.length > 0 && intersects[0].distance < distanceToPlayer) {
        return; 
    }

    let canAIShoot = false;
    let aiProjectileColor = 0xffff00;
    let aiProjectileSize = 0.1;
    let aiFireRate = FIRING_RATE;
    let aiProjectileSpeed = projectileSpeed;
    switch (ai.currentWeapon) {
        case WEAPON_PISTOL:
            canAIShoot = true;
            aiFireRate = FIRING_RATE * 2;
            break;
        case WEAPON_MG:
            if (ai.ammoMG > 0) {
                canAIShoot = true;
                aiFireRate = FIRING_RATE / 2;
            }
            break;
        case WEAPON_RR:
            if (ai.ammoRR > 0) {
                canAIShoot = true;
                aiFireRate = FIRING_RATE * 5;
                aiProjectileSize = 0.5;
                aiProjectileColor = 0xff8c00; 
            }
            break;
        case WEAPON_SR:
            if (ai.ammoSR > 0) {
                canAIShoot = true;
                aiFireRate = FIRE_RATE_SR;
                aiProjectileColor = 0xffff00;
                aiProjectileSpeed = projectileSpeed * 2;
            }
            break;
    }
    if (timeElapsed - ai.lastAttackTime < aiFireRate) return; 
    if (canAIShoot) {
        if (ai.currentWeapon === WEAPON_MG) {
            aimgGunSound.cloneNode(true).play().catch(e => console.error("AI audio playback failed:", e));
        } else if (ai.currentWeapon === WEAPON_RR) { 
            rrGunSound.cloneNode(true).play().catch(e => console.error("AI audio playback failed:", e));
        } else { 
            let soundToPlay = aiGunSound;
            if (ai.currentWeapon === WEAPON_SR) {
                soundToPlay = aiSrGunSound; // ここをsrGunSoundからaiSrGunSoundに変更
            }
            soundToPlay.cloneNode(true).play().catch(e => console.error("AI audio playback failed:", e));
        }
        
        createProjectile(startPosition, direction, aiProjectileColor, aiProjectileSize, ai.currentWeapon === WEAPON_RR, 'ai', aiProjectileSpeed, ai.currentWeapon === WEAPON_SR); 
        ai.lastAttackTime = timeElapsed;
        if (ai.currentWeapon === WEAPON_MG) {
            if (--ai.ammoMG === 0) ai.currentWeapon = WEAPON_PISTOL;
        } else if (ai.currentWeapon === WEAPON_RR) {
            if (--ai.ammoRR === 0) ai.currentWeapon = WEAPON_PISTOL;
        } else if (ai.currentWeapon === WEAPON_SR) {
            if (--ai.ammoSR === 0) ai.currentWeapon = WEAPON_PISTOL;
        }
    }
}

function aiCheckPickup(ai) {
    for (let i = weaponPickups.length - 1; i >= 0; i--) {
        const pickup = weaponPickups[i];
        if (!pickup.parent) continue;
        if (ai.position.distanceTo(pickup.position) < ARRIVAL_THRESHOLD + 0.5) {
            switch (pickup.userData.weaponType) {
                case WEAPON_MG: ai.currentWeapon = WEAPON_MG; ai.ammoMG = MAX_AMMO_MG; break;
                case WEAPON_RR: ai.currentWeapon = WEAPON_RR; ai.ammoRR = MAX_AMMO_RR; break;
                case WEAPON_SR: ai.currentWeapon = WEAPON_SR; ai.ammoSR = MAX_AMMO_SR; break;
            }
            scene.remove(pickup);
            weaponPickups.splice(i, 1);
            respawningPickups.push({ weaponType: pickup.userData.weaponType, respawnTime: clock.getElapsedTime() + RESPAWN_DELAY });

            if (ai.targetWeaponPickup === pickup) {
                ai.targetWeaponPickup = null;
                ai.state = 'HIDING';
                ai.lastHiddenTime = clock.getElapsedTime();
            }
            break; 
        }
    }
}
// =========================================================================
// 入力イベントリスナー設定 (修正済み)
// =========================================================================

// 発射ボタンのイベントリスナー (エラー防止のため存在チェックを追加)
// 【元のコードの発射ボタン関連のイベントリスナーを全て差し替え】

// 【元のコードの fireBtn のイベントリスナーを全て差し替え】



const moveSpeed = 10.0;      
const lookSpeed = 0.006;     
let keyboardMoveVector = new THREE.Vector2(0, 0);
let joystickMoveVector = new THREE.Vector2(0, 0);

// ジョイスティックの設定
if (document.getElementById('joystick-move')) {
    const moveManager = nipplejs.create({ zone: document.getElementById('joystick-move'), mode: 'static', position: { left: '50%', top: '50%' }, color: 'blue' });
    moveManager.on('move', function (evt, data) {
        if (!isGameRunning) return;
        const angleRad = data.angle.radian;
        const distance = Math.min(data.distance / 40, 1.0); 
        joystickMoveVector.set(Math.cos(angleRad) * distance, Math.sin(angleRad) * distance);
    }).on('end', function () {
        joystickMoveVector.set(0, 0);
    });
}

const keySet = new Set();
document.addEventListener('keydown', (event) => {
    if (!isGameRunning) return;
    keySet.add(event.code);
    if (event.code === 'KeyC') {
        isCrouchingToggle = !isCrouchingToggle;
    }
});
document.addEventListener('keyup', (event) => { if (!isGameRunning) return; keySet.delete(event.code); });

const canvas = renderer.domElement;
canvas.addEventListener('click', () => { if (!isGameRunning) return; if (document.pointerLockElement !== canvas) { canvas.requestPointerLock(); } });
document.addEventListener('pointerlockchange', () => {
    if (document.pointerLockElement === canvas) {
        document.addEventListener('mousemove', onMouseMove, false);
    } else {
        document.removeEventListener('mousemove', onMouseMove, false);
    }
}, false);

function onMouseMove(event) {
    if (!isGameRunning) return;
    const movementX = event.movementX || 0;
    const movementY = event.movementY || 0;
    player.rotation.y -= movementX * lookSpeed;
    let cameraRotationX = camera.rotation.x - movementY * lookSpeed;
    camera.rotation.x = THREE.MathUtils.clamp(cameraRotationX, -Math.PI / 2 + 0.1, Math.PI / 2 - 0.1);
}

document.addEventListener('mousedown', (event) => { if (!isGameRunning) return; if (event.button === 0) { handleFirePress(); } });
document.addEventListener('mouseup', (event) => { if (!isGameRunning) return; if (event.button === 0) { handleFireRelease(); } });
document.addEventListener('contextmenu', (event) => event.preventDefault());

// =========================================================================
// ★ 修正済み: 視点移動 (ルック) のタッチ入力処理
// 発射ボタンとの競合を防ぎ、上下視点移動の方向を適切に設定
// =========================================================================

let isLooking = false;
let lookTouchId = -1; 
let lastTouchX = 0;
let lastTouchY = 0;


// 👇 差し替え後の修正コード
document.addEventListener('touchstart', (event) => { 
    if (!isGameRunning || lookTouchId !== -1) return; 
    const halfWidth = window.innerWidth / 2; 
    
    for (let i = 0; i < event.changedTouches.length; i++) { 
        const touch = event.changedTouches[i]; 
        
        // ★ 修正点: 発射ボタン（fire-button）でのチェックを削除
        // 画面右半分をタッチしていれば、ルック操作として追跡を開始
        if (touch.clientX > halfWidth) { 
            
            // ただし、このタッチが発射ボタン上であれば、射撃処理も行う
            if (touch.target.id === 'fire-button') {
                 handleFirePress(); 
            }
            
            isLooking = true; 
            lookTouchId = touch.identifier; 
            lastTouchX = touch.clientX; 
            lastTouchY = touch.clientY; 
            event.preventDefault(); 
            break; 
        } 
    } 
}, { passive: false });


// 注意: document.addEventListener('touchmove') と document.addEventListener('touchend') のロジックは、
// 前回修正した（lookTouchIdを追跡し、上下反転を修正した）コードをそのまま使用してください。

// 【document.addEventListener('touchmove', ...) が存在しない場合は追加】
document.addEventListener('touchmove', (event) => { 
    if (!isGameRunning || !isLooking || lookTouchId === -1) return; 
    
    let currentTouchX = 0; 
    let currentTouchY = 0; 
    let foundLookTouch = false; 

    for (let i = 0; i < event.changedTouches.length; i++) { 
        const touch = event.changedTouches[i]; 
        
        if (touch.identifier === lookTouchId) { // ★ 追跡しているIDの指の動きのみを処理
            currentTouchX = touch.clientX; 
            currentTouchY = touch.clientY; 
            foundLookTouch = true; 
            event.preventDefault(); 
            break; 
        } 
    } 
    
    if (foundLookTouch) { 
        const dx = currentTouchX - lastTouchX; 
        const dy = currentTouchY - lastTouchY; 
        
        // 左右の回転
        player.rotation.y -= dx * lookSpeed; 
        
        // 上下の回転 (符号を '-' に設定し、上下反転を解消)
        let cameraRotationX = camera.rotation.x - dy * lookSpeed; 
        camera.rotation.x = THREE.MathUtils.clamp(cameraRotationX, -Math.PI / 2 + 0.1, Math.PI / 2 - 0.1); 
        
        lastTouchX = currentTouchX; 
        lastTouchY = currentTouchY; 
    } 
}, { passive: false });


// 【document.addEventListener('touchend', ...) を差し替え】

// 👇 差し替え後の修正コード (ルック終了時に発射も停止させる)
document.addEventListener('touchend', (event) => { 
    if (!isGameRunning || lookTouchId === -1) return; 
    
    for (let i = 0; i < event.changedTouches.length; i++) { 
        const touch = event.changedTouches[i]; 
        
        if (touch.identifier === lookTouchId) {
            
            // ★ 追加修正点: ルック操作の指が離れたら、発射を停止する
            handleFireRelease(); 
            
            isLooking = false; 
            lookTouchId = -1; 
            break; 
        } 
    } 
}, false);

const crouchButton = document.getElementById('crouch-button');
if (crouchButton) {
crouchButton.addEventListener('touchstart', (event) => {
    if (!isGameRunning) return;
    isCrouchingToggle = !isCrouchingToggle; // Toggle the state
    event.preventDefault(); // Prevent default touch behavior
}, { passive: false });
}


// =========================================================================
// ゲームループ・管理ロジック
// =========================================================================

function startGame() {
    const startSc = document.getElementById('start-screen');
    if(startSc) startSc.style.display = 'none';
    
    if(renderer && renderer.domElement) {
        renderer.domElement.style.display = 'block';
    }

    const gameUI = ['crosshair', 'player-hp-display', 'ai-hp-display'];
    gameUI.forEach(id => { 
        const el = document.getElementById(id); 
        if (el) el.style.display = 'block'; 
    });

    // モバイル判定でUIを表示/非表示
    if ('ontouchstart' in window) { // タッチデバイスの場合
        const joy = document.getElementById('joystick-move');
        const fire = document.getElementById('fire-button');
        const crouch = document.getElementById('crouch-button'); // 追加
        if(joy) joy.style.display = 'block';
        if(fire) fire.style.display = 'flex'; // fire-buttonはflexなのでflexに戻す
        if(crouch) crouch.style.display = 'flex'; // crouch-buttonもflexで表示
    } else { // PCの場合
        const joy = document.getElementById('joystick-move');
        const fire = document.getElementById('fire-button');
        const crouch = document.getElementById('crouch-button'); // 追加
        if(joy) joy.style.display = 'none';
        if(fire) fire.style.display = 'none';
        if(crouch) crouch.style.display = 'none'; // PCでは非表示
    }

    // フルスクリーン処理
    const element = document.documentElement;
    if (element.requestFullscreen) element.requestFullscreen().catch(err => console.log(err));
    else if (element.webkitRequestFullscreen) element.webkitRequestFullscreen();
    
    // 画面の向きロック
    if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape').catch(e => console.log('Orientation lock failed:', e));
    }
    
    // 障害物リセット
    if (gameSettings.fieldState === 'persist') {
        if(typeof resetObstacles === 'function') resetObstacles(); 
    }
    
    // リスタート
    restartGame();
}

function resetWeaponPickups() {
    for (let i = weaponPickups.length - 1; i >= 0; i--) scene.remove(weaponPickups[i]);
    weaponPickups.length = 0;
    respawningPickups.length = 0;
    createWeaponPickups();
}

function restartGame() {
    gameOverScreen.style.display = 'none';
    winScreen.style.display = 'none';
    
    playerHP = gameSettings.playerHP === 'Infinity' ? Infinity : parseInt(gameSettings.playerHP, 10);
    playerHPDisplay.textContent = `HP: ${playerHP === Infinity ? '∞' : playerHP}`;
    
    player.position.copy(PLAYER_INITIAL_POSITION);
    player.rotation.y = Math.PI;
    camera.rotation.x = 0;
    currentWeapon = WEAPON_PISTOL;
    ammoMG = 0;
    ammoRR = 0;
    ammoSR = 0;
    
    for (const ai of ais) {
        scene.remove(ai);
    }
    ais.length = 0;

    const aiColors = [0x00ff00, 0x00ffff]; 
    for (let i = 0; i < gameSettings.aiCount; i++) {
        const ai = createAI(aiColors[i] || 0xff00ff); 
        ai.position.copy(AI_INITIAL_POSITIONS[i] || new THREE.Vector3(Math.random() * 20 - 10, 0, 20));
        scene.add(ai);
        ais.push(ai);
    }
    
    const aiHP = gameSettings.aiHP === 'Infinity' ? Infinity : parseInt(gameSettings.aiHP, 10);
    const aiHPText = gameSettings.aiHP === 'Infinity' ? '∞' : aiHP;
    
    const ai1HPDisplay = document.getElementById('ai-hp-display');
    const ai2HPDisplay = document.getElementById('ai2-hp-display');

    ais.forEach((ai, index) => {
        ai.hp = aiHP;
        ai.rotation.y = 0;
        ai.state = 'HIDING';
        ai.currentWeapon = WEAPON_PISTOL;
        ai.ammoMG = 0;
        ai.ammoRR = 0;
        ai.ammoSR = 0;
        ai.targetWeaponPickup = null;
        ai.targetPosition.copy(ai.position);
        ai.lastHiddenTime = 0;
        ai.lastAttackTime = 0;
        ai.currentAttackTime = 0;
        ai.avoiding = false;
        
        if (index === 0) {
            ai1HPDisplay.textContent = `AI 1 HP: ${aiHPText}`;
        } else if (index === 1) {
            ai2HPDisplay.textContent = `AI 2 HP: ${aiHPText}`;
        }
    });

    if (gameSettings.aiCount < 2) {
        ai2HPDisplay.style.display = 'none';
    }

    const gameUI = ['crosshair', 'player-hp-display', 'ai-hp-display', 'player-weapon-display'];
    if (gameSettings.aiCount > 1) {
        gameUI.push('ai2-hp-display');
    }
    gameUI.forEach(id => { 
        const el = document.getElementById(id); 
        if (el) el.style.display = 'block'; 
    });
    // モバイル判定でUIを表示/非表示
    if ('ontouchstart' in window) { // タッチデバイスの場合
        const joy = document.getElementById('joystick-move');
        const fire = document.getElementById('fire-button');
        const crouch = document.getElementById('crouch-button');
        if(joy) joy.style.display = 'block';
        if(fire) fire.style.display = 'flex';
        if(crouch) crouch.style.display = 'flex';
    }    
    for (let i = projectiles.length - 1; i >= 0; i--) scene.remove(projectiles[i].mesh);
    projectiles.length = 0;
    
    for (let i = debris.length - 1; i >= 0; i--) {
        const mesh = debris[i].mesh;
        if (mesh.parent) {
            mesh.parent.remove(mesh);
        }
    }
    debris.length = 0;

    if (gameSettings.fieldState === 'reset') {
        resetObstacles();
    }
    resetWeaponPickups();
    
    clock.start();
    lastFireTime = -1;
    keySet.clear();
    joystickMoveVector.set(0, 0);
    isMouseButtonDown = false;
    isGameRunning = true;

    // Reset player model for death animation
    scene.remove(playerBody);
    scene.remove(playerHead);
    player.add(playerModel);
    playerModel.visible = false;
}

function startAIDeathSequence(impactVelocity, ai) {
    if (isAIDeathPlaying) return;
    isAIDeathPlaying = true;

    // 赤い煙エフェクトを追加
    createRedSmokeEffect(ai.position); 

    const joy = document.getElementById('joystick-move');
    const fire = document.getElementById('fire-button');
    const cross = document.getElementById('crosshair');
    if(joy) joy.style.display = 'none';
    if(fire) fire.style.display = 'none';
    if(cross) cross.style.display = 'none';

    const aiBody = ai.children[0];
    const aiHead = ai.children[1];

    const bodyPos = aiBody.getWorldPosition(new THREE.Vector3());
    const headPos = aiHead.getWorldPosition(new THREE.Vector3());

    ai.remove(aiBody);
    ai.remove(aiHead);
    aiBody.position.copy(bodyPos);
    aiHead.position.copy(headPos);
    aiDeathFocusObject.add(aiBody);
    aiDeathFocusObject.add(aiHead);
    
    scene.remove(ai);

    const forceMagnitude = 25; 
    const upForce = 20; 

    const bodyVelocity = impactVelocity.clone().normalize().multiplyScalar(forceMagnitude);
    bodyVelocity.y += upForce;
    aiBody.userData.velocity = bodyVelocity;
    aiBody.userData.angularVelocity = new THREE.Vector3((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);

    const headVelocity = bodyVelocity.clone().multiplyScalar(1.2); 
    headVelocity.y += 8; 
    aiHead.userData.velocity = headVelocity;
    aiHead.userData.angularVelocity = new THREE.Vector3((Math.random() - 0.5) * 25, (Math.random() - 0.5) * 25, (Math.random() - 0.5) * 25); 

    const aiDeathLocation = bodyPos.clone();
    
    // 新しいカメラロジック: プレイヤー視点を基準にする
    let cameraPos;
    const targetLookAt = aiDeathLocation.clone().add(new THREE.Vector3(0, 1, 0));

    // プレイヤーからAIへの方向
    const playerToAiDir = new THREE.Vector3().subVectors(aiDeathLocation, player.position).normalize();
    
    // 理想的なカメラ位置（プレイヤーの背後4m、高さ3m）
    const idealPos = player.position.clone().sub(playerToAiDir.multiplyScalar(4)).add(new THREE.Vector3(0, 3, 0));
    
    // 理想位置からAIへの視線チェック
    const direction = new THREE.Vector3().subVectors(targetLookAt, idealPos).normalize();
    raycaster.set(idealPos, direction);
    const intersects = raycaster.intersectObjects(obstacles, true);
    const distance = idealPos.distanceTo(targetLookAt);

    if (intersects.length > 0 && intersects[0].distance < distance - 0.5) {
        // 遮蔽物がある場合: AIの真上にカメラを置く
        cameraPos = aiDeathLocation.clone().add(new THREE.Vector3(0, 10, 5));
    } else {
        // 遮蔽物がない場合: 理想位置を採用
        cameraPos = idealPos;
    }

    cinematicCamera.position.copy(cameraPos);
    cinematicCamera.lookAt(aiDeathLocation.clone().add(new THREE.Vector3(0, 1, 0))); // 注視点を少し上に調整
    cinematicCamera.fov = 75;
    cinematicCamera.aspect = window.innerWidth / window.innerHeight; // アスペクト比を更新
    cinematicCamera.updateProjectionMatrix();

    new TWEEN.Tween(cinematicCamera)
        .to({ fov: 30 }, 2000)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .start();

    setTimeout(() => {
        isAIDeathPlaying = false;
        aiBody.userData = {};
        aiHead.userData = {};
        aiDeathFocusObject.remove(aiBody);
        aiDeathFocusObject.remove(aiHead);

        if (ais.length > 0) {
            if(joy) joy.style.display = 'block';
            if(fire) fire.style.display = 'block';
            if(cross) cross.style.display = 'block';
        }
    }, 3500); 
}

function playerFallDownCinematicSequence() {
    createRedSmokeEffect(player.position);

    const playerDeathLocation = player.position.clone();
    const targetCameraPosition = findClearCameraPosition(playerDeathLocation, obstacles);

    cinematicCamera.position.copy(targetCameraPosition);
    cinematicCamera.lookAt(playerDeathLocation.clone().add(new THREE.Vector3(0, 1, 0)));
    cinematicCamera.fov = 75;
    cinematicCamera.aspect = window.innerWidth / window.innerHeight;
    cinematicCamera.updateProjectionMatrix();
    new TWEEN.Tween(cinematicCamera).to({ fov: 30 }, 2000).easing(TWEEN.Easing.Quadratic.InOut).start();

    playerModel.visible = true; // Ensure player model is visible
    player.remove(playerModel); // Detach playerModel from player
    scene.add(playerModel); // Add playerModel directly to the scene at current player position
    playerModel.position.copy(player.position); // Ensure playerModel is at the current player position

    // AIの倒れる演出と同様にTweenでアニメーションさせる
    const fallDuration = 1.0; 
    const fallRotationAxisAngle = Math.PI / 2;
    const finalRotation = playerModel.rotation.clone();
    finalRotation.x += (Math.random() > 0.5 ? 1 : -1) * fallRotationAxisAngle;

    new TWEEN.Tween(playerModel.rotation)
        .to({ x: finalRotation.x }, fallDuration * 1000)
        .easing(TWEEN.Easing.Quadratic.Out)
        .start();

    // Player model's Y position should drop slightly to appear 'collapsed'
    const finalPlayerYPosition = -FLOOR_HEIGHT + (BODY_HEIGHT / 2); // Assuming body is 2 units high
    new TWEEN.Tween(playerModel.position)
        .to({ y: finalPlayerYPosition }, fallDuration * 1000)
        .easing(TWEEN.Easing.Quadratic.In)
        .start();
    
    // Set a flag to indicate this type of death sequence
    playerModel.userData.deathType = 'fallDown';

    setTimeout(() => {
        isPlayerDeathPlaying = false;
        showGameOver();
        playerModel.userData = {}; // Clear user data
        scene.remove(playerModel); // Remove the model from scene
    }, fallDuration * 1000 + 1500); // Wait for animation + a bit
}

function startPlayerDeathSequence(projectile) {
    if (isPlayerDeathPlaying || playerHP > 0) return;
    isPlayerDeathPlaying = true;
    isGameRunning = false;

    document.exitPointerLock();
    const uiToHide = ['joystick-move', 'fire-button', 'crosshair', 'crouch-button', 'player-hp-display', 'ai-hp-display', 'ai2-hp-display', 'player-weapon-display'];
    uiToHide.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
    });
    
    playerModel.visible = true; // Make model visible before doing anything else
    
    // For rocket launcher, blow away. For guns, fall down.
    if (projectile.isRocket) {
        const impactVelocity = projectile.velocity;
        
        const bodyPos = playerBody.getWorldPosition(new THREE.Vector3());
        const headPos = playerHead.getWorldPosition(new THREE.Vector3());

        player.remove(playerModel); // playerModelをplayerから剥がす
        scene.add(playerBody); // body, headをそれぞれシーンに追加
        scene.add(playerHead);
        playerBody.position.copy(bodyPos);
        playerHead.position.copy(headPos);
        
        // Mark as blowAway type for animate loop
        playerBody.userData.deathType = 'blowAway';
        playerHead.userData.deathType = 'blowAway';

        const forceMagnitude = 25;
        const upForce = 20;
        const bodyVelocity = impactVelocity.clone().normalize().multiplyScalar(forceMagnitude);
        bodyVelocity.y += upForce;
        playerBody.userData.velocity = bodyVelocity;
        playerBody.userData.angularVelocity = new THREE.Vector3((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);

        const headVelocity = bodyVelocity.clone().multiplyScalar(1.2);
        headVelocity.y += 8;
        playerHead.userData.velocity = headVelocity;
        playerHead.userData.angularVelocity = new THREE.Vector3((Math.random() - 0.5) * 25, (Math.random() - 0.5) * 25, (Math.random() - 0.5) * 25);

        const playerDeathLocation = bodyPos.clone();
        const cameraPos = findClearCameraPosition(playerDeathLocation, obstacles);

        cinematicCamera.position.copy(cameraPos);
        cinematicCamera.lookAt(playerDeathLocation.clone().add(new THREE.Vector3(0, 1, 0)));
        cinematicCamera.fov = 75;
        cinematicCamera.aspect = window.innerWidth / window.innerHeight;
        cinematicCamera.updateProjectionMatrix();

        new TWEEN.Tween(cinematicCamera).to({ fov: 40 }, 2000).easing(TWEEN.Easing.Quadratic.InOut).start();

        setTimeout(() => {
            isPlayerDeathPlaying = false;
            showGameOver();
            playerBody.userData = {};
            playerHead.userData = {};
            scene.remove(playerBody);
            scene.remove(playerHead);
        }, 3500);
    } else {
        playerFallDownCinematicSequence();
    }
}


function aiFallDownCinematicSequence(impactVelocity, ai) {
    if (isAIDeathPlaying) return; 
    isAIDeathPlaying = true;
    cinematicTargetAI = ai; // 対象のAIをセット

    const joy = document.getElementById('joystick-move');
    const fire = document.getElementById('fire-button');
    const cross = document.getElementById('crosshair');
    if(joy) joy.style.display = 'none';
    if(fire) fire.style.display = 'none';
    if(cross) cross.style.display = 'none';

    createRedSmokeEffect(ai.position); 

    const aiDeathLocation = ai.position.clone(); 
    const targetCameraPosition = findClearCameraPosition(aiDeathLocation, obstacles);

    cinematicCamera.position.copy(targetCameraPosition);
    cinematicCamera.lookAt(aiDeathLocation.clone().add(new THREE.Vector3(0, 1, 0))); // 注視点を少し上に調整
    cinematicCamera.fov = 75;
    cinematicCamera.aspect = window.innerWidth / window.innerHeight; // アスペクト比を更新
    cinematicCamera.updateProjectionMatrix();

    new TWEEN.Tween(cinematicCamera)
        .to({ fov: 30 }, 2000)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .start();

    const fallDuration = 1.0; 
    
    const fallRotationAxisAngle = Math.PI / 2;
    const finalAIRotation = ai.rotation.clone();
    finalAIRotation.x += (Math.random() > 0.5 ? 1 : -1) * fallRotationAxisAngle;

    const finalAIYPosition = -FLOOR_HEIGHT + (BODY_HEIGHT / 2);

    new TWEEN.Tween(ai.rotation)
        .to({ x: finalAIRotation.x }, fallDuration * 1000)
        .easing(TWEEN.Easing.Quadratic.Out)
        .start();

    new TWEEN.Tween(ai.position)
        .to({ y: finalAIYPosition }, fallDuration * 1000)
        .easing(TWEEN.Easing.Quadratic.In)
        .start();

    setTimeout(() => {
        isAIDeathPlaying = false;
        cinematicTargetAI = null; // 対象のAIをリセット
        scene.remove(ai); 
        
        if (ais.length > 0) {
            if(joy) joy.style.display = 'block';
            if(fire) fire.style.display = 'block';
            if(cross) cross.style.display = 'block';
        }
    }, fallDuration * 1000 + 500);
}

function showGameOver() {
    isGameRunning = false;
    gameOverScreen.style.display = 'flex';
    document.exitPointerLock();
}

function showWinScreen() {
    isGameRunning = false;
    winScreen.style.display = 'flex';
    document.exitPointerLock();
}

function checkCollision(object, obstacles, ignoreObstacle = null) {
    const objectBox = new THREE.Box3();
    const pos = object.position; // ここでのpos.yが何を指すのかを特定する

    console.log("--- checkCollision start ---");
    console.log("Object type:", object === player ? "Player" : (ais.includes(object) ? "AI" : "Other"));
    console.log("Object position (world):", object.getWorldPosition(new THREE.Vector3()));
    
    // 追加: プレイヤーの生のposition.yの値を出力
    if (object === player) {
        console.log("Player raw position.y (pos.y):", pos.y);
        console.log("Player target height:", playerTargetHeight);
    }
    
    let currentObjectBox;

    if (object === player) {
        objectBox.min.set(pos.x - 0.5, pos.y, pos.z - 0.5); 
        objectBox.max.set(pos.x + 0.5, pos.y + playerTargetHeight, pos.z + 0.5);
        
        // プレイヤーの衝突ボックスをわずかに拡大して、浮動小数点数の誤差を吸収
        objectBox.expandByScalar(0.01); // 例: 全方向に0.01拡大
        
        currentObjectBox = objectBox;
    } else if (ais.includes(object)) {
        currentObjectBox = new THREE.Box3().setFromObject(object);
        const AI_HALF_WIDTH = 0.25;
        currentObjectBox.min.x -= AI_HALF_WIDTH;
        currentObjectBox.max.x += AI_HALF_WIDTH;
        currentObjectBox.min.z -= AI_HALF_WIDTH;
        currentObjectBox.max.z += AI_HALF_WIDTH;
        currentObjectBox.min.y = object.position.y;
        currentObjectBox.max.y = object.position.y + 3;
    } else {
        console.log("--- checkCollision end (invalid object) ---");
        return false;
    }
    
    console.log("Checking object's BoundingBox (min):", currentObjectBox.min.x, currentObjectBox.min.y, currentObjectBox.min.z);
    console.log("Checking object's BoundingBox (max):", currentObjectBox.max.x, currentObjectBox.max.y, currentObjectBox.max.z);


    for (const obstacle of obstacles) {
        const obstacleBox = new THREE.Box3().setFromObject(obstacle);
        const isTowerWall = obstacle.userData && obstacle.userData.isTowerWall;

        // 追加: ignoreObstacleによってどの障害物が無視されているかログ出力
        if (obstacle === ignoreObstacle) {
            console.log("DEBUG: Obstacle ignored (exact match). isTowerWall:", isTowerWall, "Obstacle ID:", obstacle.id);
            continue;
        }
        if (ignoreObstacle && obstacle.userData.parentTower === ignoreObstacle) {
            console.log("DEBUG: Obstacle ignored (parentTower match). isTowerWall:", isTowerWall, "Obstacle ID:", obstacle.id);
            continue;
        }
        
        if (isTowerWall) {
            console.log("Obstacle (Tower Wall) BoundingBox (min):", obstacleBox.min.x, obstacleBox.min.y, obstacleBox.min.z);
            console.log("Obstacle (Tower Wall) BoundingBox (max):", obstacleBox.max.x, obstacleBox.max.y, obstacleBox.max.z);
        }

        if (currentObjectBox.intersectsBox(obstacleBox)) {
            console.log("Collision detected with obstacle:", obstacle.position);
            console.log("Collided obstacle is Tower Wall:", isTowerWall);
            console.log("--- checkCollision end (collision) ---");
            return true;
        }
    }
    console.log("--- checkCollision end (no collision) ---");
    return false;
}
function findClearCameraPosition(targetPosition, obstaclesArray) {
    const lookAtTargetForRaycast = targetPosition.clone().add(new THREE.Vector3(0, 1.5, 0)); // レイキャスト用に胸の高さをターゲット

    const cameraCandidates = [
        new THREE.Vector3(0, 4, 8),    // 後方上（距離を調整）
        new THREE.Vector3(8, 4, 0),    // 右上（距離を調整）
        new THREE.Vector3(-8, 4, 0),   // 左上（距離を調整）
        new THREE.Vector3(6, 6, 6),    // 右後方上（距離を調整）
        new THREE.Vector3(-6, 6, 6),   // 左後方上（距離を調整）
        new THREE.Vector3(6, 6, -6),   // 右前方上（距離を調整）
        new THREE.Vector3(-6, 6, -6),  // 左前方上（距離を調整）
        new THREE.Vector3(0, 4, -8),   // 前方上（距離を調整）
    ];
    
    for (const offset of cameraCandidates) {
        const candidateCameraPosition = targetPosition.clone().add(offset);
        const directionToTarget = new THREE.Vector3().subVectors(lookAtTargetForRaycast, candidateCameraPosition).normalize();
        
        raycaster.set(candidateCameraPosition, directionToTarget);
        const intersects = raycaster.intersectObjects(obstaclesArray, true);
        const distanceToTarget = candidateCameraPosition.distanceTo(lookAtTargetForRaycast);

        if (intersects.length === 0 || intersects[0].distance > distanceToTarget - 0.1) {
            return candidateCameraPosition; 
        }
    }

    return targetPosition.clone().add(new THREE.Vector3(0, 15, 0));
}



function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    const timeElapsed = clock.getElapsedTime();

    playerTargetHeight = isCrouchingToggle ? 1.0 : 2.0;

        const currentMoveSpeed = isCrouchingToggle ? moveSpeed / 2 : moveSpeed;

    for (let i = debris.length - 1; i >= 0; i--) {
        const d = debris[i];
        d.velocity.y -= GRAVITY * delta;
        d.mesh.position.add(d.velocity.clone().multiplyScalar(delta));
        d.mesh.rotation.x += d.angularVelocity.x * delta;
        d.mesh.rotation.y += d.angularVelocity.y * delta;
        d.mesh.rotation.z += d.angularVelocity.z * delta;
        d.life -= delta;
        if (d.mesh.position.y < -FLOOR_HEIGHT) {
            d.mesh.position.y = -FLOOR_HEIGHT;
            d.velocity.y *= -0.4;
            d.velocity.x *= 0.8;
            d.velocity.z *= 0.8;
            d.angularVelocity.multiplyScalar(0.8);
        }
        if (d.life <= 0) {
            if (d.mesh.parent) {
                d.mesh.parent.remove(d.mesh);
            }
            debris.splice(i, 1);
        }
    }

    if (isAIDeathPlaying) {
        // バラバラになる演出の処理
        if (aiDeathFocusObject.children.length > 0) {
            const focusPos = new THREE.Vector3();
            let partsInFocus = 0;
            const tempVector = new THREE.Vector3();

            for (const part of aiDeathFocusObject.children) {
                if (part.userData.velocity) {
                    part.userData.velocity.y -= GRAVITY * delta;
                    part.position.add(part.userData.velocity.clone().multiplyScalar(delta));
                    part.rotation.x += part.userData.angularVelocity.x * delta;
                    part.rotation.y += part.userData.angularVelocity.y * delta;
                    part.rotation.z += part.userData.angularVelocity.z * delta;

                    if (part.position.y < -FLOOR_HEIGHT) {
                        part.position.y = -FLOOR_HEIGHT;
                        part.userData.velocity.y *= -0.4;
                        part.userData.velocity.x *= 0.8;
                        part.userData.velocity.z *= 0.8;
                        part.userData.angularVelocity.multiplyScalar(0.8);
                    }
                    focusPos.add(part.getWorldPosition(tempVector));
                    partsInFocus++;
                }
            }
            if (partsInFocus > 0) {
                focusPos.divideScalar(partsInFocus);
            }
            cinematicCamera.lookAt(focusPos);
        }
        // 倒れるだけの演出の処理
        else if (cinematicTargetAI) {
            const lookAtTarget = cinematicTargetAI.position.clone().add(new THREE.Vector3(0, 1.2, 0));
            cinematicCamera.lookAt(lookAtTarget);
        }

        cinematicCamera.updateProjectionMatrix();
        TWEEN.update();
        renderer.render(scene, cinematicCamera);
        return;
    }

    if (isPlayerDeathPlaying) {
        const focusPos = new THREE.Vector3();
        let partsInFocus = 0;
        const tempVector = new THREE.Vector3();

        if (playerModel.userData.deathType === 'fallDown') { // その場で倒れる演出の場合
            // Tweenがアニメーションを処理するので、物理演算は不要
            // カメラはplayerModel全体を追跡
            cinematicCamera.lookAt(playerModel.position.clone().add(new THREE.Vector3(0, 1, 0)));
            // playerModelが既にシーンに直接addされているので、その位置を基にフォーカス
            focusPos.add(playerModel.getWorldPosition(tempVector));
            partsInFocus++;
        } else { // 吹き飛ぶ演出の場合 ('blowAway'または未設定)
            const parts = [playerBody, playerHead];
            for (const part of parts) {
                if (part && part.userData.velocity) {
                    part.userData.velocity.y -= GRAVITY * delta;
                    part.position.add(part.userData.velocity.clone().multiplyScalar(delta));
                    part.rotation.x += part.userData.angularVelocity.x * delta;
                    part.rotation.y += part.userData.angularVelocity.y * delta;
                    part.rotation.z += part.userData.angularVelocity.z * delta;

                    if (part.position.y < -FLOOR_HEIGHT) {
                        part.position.y = -FLOOR_HEIGHT;
                        part.userData.velocity.y *= -0.4;
                        part.userData.velocity.x *= 0.8;
                        part.userData.velocity.z *= 0.8;
                        part.userData.angularVelocity.multiplyScalar(0.8);
                    }
                    focusPos.add(part.getWorldPosition(tempVector));
                    partsInFocus++;
                }
            }
        }
        
        if (partsInFocus > 0) {
            focusPos.divideScalar(partsInFocus);
        }
        cinematicCamera.lookAt(focusPos);

        cinematicCamera.updateProjectionMatrix();
        TWEEN.update(); // Tweenアニメーションを更新
        renderer.render(scene, cinematicCamera);
        return;
    }

    if (!isGameRunning) {
        renderer.render(scene, camera);
        return;
    }

    const weaponDisplay = document.getElementById('player-weapon-display');
    if (weaponDisplay) {
        let weaponName = currentWeapon;
        let ammoCount = '∞';
        switch (currentWeapon) {
            case WEAPON_MG:
                weaponName = 'Machinegun';
                ammoCount = ammoMG;
                break;
            case WEAPON_RR:
                weaponName = 'Rocket';
                ammoCount = ammoRR;
                break;
            case WEAPON_SR:
                weaponName = 'Sniper';
                ammoCount = ammoSR;
                break;
            case WEAPON_PISTOL:
                weaponName = 'Pistol';
                break;
        }
        weaponDisplay.innerHTML = `Weapon: ${weaponName}<br>Ammo: ${ammoCount}`;
    }

    if (isMouseButtonDown && currentWeapon === WEAPON_MG) {
        shoot();
    }

    if (isScoping) {
        document.getElementById('crosshair').style.display = 'none';
    }
    else {
        if (scopeOverlay.style.display === 'none') {
            document.getElementById('crosshair').style.display = 'block';
        }
    }
    
    // キー入力を毎フレーム処理
    keyboardMoveVector.set(0, 0);
    if (keySet.has('KeyW')) keyboardMoveVector.y += 1;
    if (keySet.has('KeyS')) keyboardMoveVector.y -= 1;
    if (keySet.has('KeyA')) keyboardMoveVector.x -= 1;
    if (keySet.has('KeyD')) keyboardMoveVector.x += 1;
    let finalMoveVector = joystickMoveVector.length() > 0 ? joystickMoveVector.clone() : keyboardMoveVector.clone();

                if (isElevating) {

                    const elevateSpeed = 5.0;

                    player.position.y += elevateSpeed * delta;

            

                            // 目標の高さに到達したかチェック

            

                            if (player.position.y >= elevatingTargetY) {

            

                                player.position.y = elevatingTargetY; // 目標高度に到達

            

                                isElevating = false; // エレベーターを終了

            

                                isLanding = true; // 着地シーケンスを開始

            

                                landingTimer = 1.0; // 1秒間の水平移動猶予

            

                            }

                    } else if (isLanding) {
                        // 着地シーケンス中 (水平移動のみ許可)
                        landingTimer -= delta;
                        if (landingTimer <= 0) {
                            isLanding = false;
                            elevatingTargetObstacle = null; // 登った障害物をクリア
                        }
                
                        if (finalMoveVector.length() > 0) finalMoveVector.normalize();
                        const forwardMove = finalMoveVector.y * currentMoveSpeed * delta;
                        const rightMove = finalMoveVector.x * currentMoveSpeed * delta;
                        const oldPlayerPosition = player.position.clone();
                        const forwardVector = new THREE.Vector3();
                        player.getWorldDirection(forwardVector);
                        forwardVector.y = 0;
                        forwardVector.normalize();
                        const rightVector = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forwardVector);
                        const moveX = rightVector.x * rightMove + forwardVector.x * -forwardMove;
                        const moveZ = rightVector.z * rightMove + forwardVector.z * -forwardMove;
                        
                        player.position.z += moveZ;
                        // 登った障害物との衝突は無視
                        if (checkCollision(player, obstacles, elevatingTargetObstacle)) {
                            player.position.z = oldPlayerPosition.z;
                        }
                        player.position.x += moveX;
                        if (checkCollision(player, obstacles, elevatingTargetObstacle)) {
                            player.position.x = oldPlayerPosition.x;
                        }
                        
                    } else { // 通常の移動ロジック
                        let inSensorArea = false;
                        // センサーエリアとの接触をチェック
                        // プレイヤーのBoundingBoxを作成
                        const playerBoundingBox = new THREE.Box3().setFromCenterAndSize(
                            player.position.clone().add(new THREE.Vector3(0, playerTargetHeight/2, 0)), // プレイヤーの体全体
                            new THREE.Vector3(1, playerTargetHeight, 1) // プレイヤーのサイズ (幅1, 高さBODY_HEIGHT, 奥行き1)
                        );
                
                        for (const sensorArea of ladderSwitches) { // ladderSwitches配列にセンサーエリアを格納している
                            const sensorBoundingBox = new THREE.Box3().setFromObject(sensorArea);
                            
                            if (playerBoundingBox.intersectsBox(sensorBoundingBox)) {
                                                inSensorArea = true;                                const obs = sensorArea.userData.obstacle;
                
                                isElevating = true;
                                elevatingTargetObstacle = obs;
                                elevatingTargetY = (obs.position.y + obs.geometry.parameters.height / 2) + 2.1;
                
                                // プレイヤーを梯子の中心に固定し、上昇を開始
                                const ladderPos = sensorArea.userData.ladderPos;
                                if (ladderPos) {
                                    player.position.x = ladderPos.x;
                                    player.position.z = ladderPos.z;
                                }
                                break;
                            }
                        }
                        // スイッチに乗っていなければ、通常の移動処理
                        if (!inSensorArea) {
                            if (finalMoveVector.length() > 0) finalMoveVector.normalize();
                            const forwardMove = finalMoveVector.y * currentMoveSpeed * delta;
                            const rightMove = finalMoveVector.x * currentMoveSpeed * delta;
                            const oldPlayerPosition = player.position.clone();
                            const forwardVector = new THREE.Vector3();
                            player.getWorldDirection(forwardVector);
                            forwardVector.y = 0;
                            forwardVector.normalize();
                            const rightVector = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forwardVector);
                            const moveX = rightVector.x * rightMove + forwardVector.x * -forwardMove;
                            const moveZ = rightVector.z * rightMove + forwardVector.z * -forwardMove;
                            
                            const originalY = player.position.y;
                
                            player.position.z += moveZ;
                            if (checkCollision(player, obstacles, currentGroundObstacle)) player.position.z = oldPlayerPosition.z; 
                            player.position.x += moveX;
                            if (checkCollision(player, obstacles, currentGroundObstacle)) player.position.x = oldPlayerPosition.x; 
                            
                            const playerDistFromCenter = Math.sqrt(player.position.x * player.position.x + player.position.z * player.position.z);
                            if (playerDistFromCenter > ARENA_PLAY_AREA_RADIUS) {
                                const ratio = ARENA_PLAY_AREA_RADIUS / playerDistFromCenter;
                                player.position.x *= ratio;
                                player.position.z *= ratio;
                            }
                
                            // Y座標の処理 (重力および高さ調整)
                            let onGround = false;
                            currentGroundObstacle = null;
                            let groundY = 0; // 現在立っている地面のY座標

                            const playerFeetY = player.position.y - playerTargetHeight;

                            for (const obs of obstacles) {
                                const obstacleBox = new THREE.Box3().setFromObject(obs);
                                const topOfObstacle = obs.position.y + obs.geometry.parameters.height / 2;

                                const playerHorizontalBox = new THREE.Box2(
                                    new THREE.Vector2(player.position.x - 0.5, player.position.z - 0.5),
                                    new THREE.Vector2(player.position.x + 0.5, player.position.z + 0.5)
                                );
                                const obstacleHorizontalBox = new THREE.Box2(
                                    new THREE.Vector2(obstacleBox.min.x, obstacleBox.min.z),
                                    new THREE.Vector2(obstacleBox.max.x, obstacleBox.max.z)
                                );

                                if (playerHorizontalBox.intersectsBox(obstacleHorizontalBox)) {
                                    if (playerFeetY >= topOfObstacle - 1.5 && playerFeetY <= topOfObstacle + 0.5) {
                                        onGround = true;
                                        currentGroundObstacle = obs;
                                        groundY = topOfObstacle;
                                        break;
                                    }
                                }
                            }
                
                            if (!onGround && playerFeetY < 0.1) {
                                onGround = true;
                                groundY = 0;
                            }
                            
                            if (onGround) {
                                const targetY = groundY + playerTargetHeight;
                                player.position.y = THREE.MathUtils.lerp(player.position.y, targetY, 0.2);
                            } else {
                                player.position.y -= GRAVITY * delta;
                            }                        }
                    }
    for (let i = weaponPickups.length - 1; i >= 0; i--) {
        const pickup = weaponPickups[i];
        if (!pickup.parent) continue; 
        const pickupBoundingBox = new THREE.Box3().setFromObject(pickup);
        
        const playerPos = player.position;
        const playerCollisionBox = new THREE.Box3();
        playerCollisionBox.min.set(playerPos.x - 0.5, playerPos.y - 2.0, playerPos.z - 0.5);
        playerCollisionBox.max.set(playerPos.x + 0.5, playerPos.y + 0.5, playerPos.z + 0.5);
                        if (playerCollisionBox.intersectsBox(pickupBoundingBox)) {
                            let weaponName = '';
                            switch (pickup.userData.weaponType) {
                                case WEAPON_MG: 
                                    currentWeapon = WEAPON_MG; 
                                    ammoMG = MAX_AMMO_MG; 
                                    weaponName = 'MACHINEGUN';
                                    break;
                                case WEAPON_RR: 
                                    currentWeapon = WEAPON_RR; 
                                    ammoRR = MAX_AMMO_RR; 
                                    weaponName = 'ROCKET LAUNCHER';
                                    break;
                                case WEAPON_SR: 
                                    currentWeapon = WEAPON_SR; 
                                    ammoSR = MAX_AMMO_SR; 
                                    weaponName = 'SNIPER RIFLE';
                                    break;
                            }
                
                            // 音声再生
                            const setSound = document.getElementById('setSound');
                            if (setSound) setSound.cloneNode(true).play();
                
                            // 画面表示
                            const weaponGetDisplay = document.getElementById('weapon-get-display');
                            if (weaponGetDisplay) {
                                weaponGetDisplay.textContent = `${weaponName} GET!`;
                                weaponGetDisplay.style.display = 'block';
                                setTimeout(() => {
                                    weaponGetDisplay.style.display = 'none';
                                }, 1000); // 1秒後に非表示
                            }
                
                            scene.remove(pickup);
                            weaponPickups.splice(i, 1);
                            respawningPickups.push({ weaponType: pickup.userData.weaponType, respawnTime: timeElapsed + RESPAWN_DELAY });
                            continue; 
                        }    }
    
    for (let i = respawningPickups.length - 1; i >= 0; i--) {
        const respawnItem = respawningPickups[i];
        if (timeElapsed >= respawnItem.respawnTime) {
            const weaponText = respawnItem.weaponType === WEAPON_MG ? 'MG' :
                               respawnItem.weaponType === WEAPON_RR ? 'RR' : 'SR';
            createWeaponPickup(weaponText, getRandomSafePosition(), respawnItem.weaponType);
            respawningPickups.splice(i, 1);
        }
    }
    
    ais.forEach((ai, index) => {
            // AIの移動速度をしゃがみ状態に応じて調整
            const currentAISpeed = ai.isCrouching ? AI_SPEED / 2 : AI_SPEED;

            aiCheckPickup(ai);
            const isAISeen = isVisibleToPlayer(ai);
            const distanceToTarget = ai.position.distanceTo(ai.targetPosition);
            const isArrived = distanceToTarget < ARRIVAL_THRESHOLD;
            const isMoving = !isArrived;
    
                                    // AIのしゃがみロジック: HIDING状態ならしゃがみ、それ以外なら立つ
    
                                    if (ai.state === 'HIDING') {
    
                                        ai.isCrouching = true;
    
                                    } else {
    
                                        ai.isCrouching = false;
    
                                    }
    
                                
    
                        
    
            
    
                    // AIのYスケール調整 (見た目の変更) と位置調整
    
                    ai.scale.y = ai.isCrouching ? 0.7 : 1.0; // 縮小率を0.7に変更
    
                    // スケール変更によってAIの足元が地面に埋まらないように、position.yを調整
    
                    ai.position.y = -FLOOR_HEIGHT - (ai.isCrouching ? (BODY_HEIGHT + HEAD_RADIUS * 2) * 0.15 : 0); // 調整量を0.15に変更 (3 * 0.15 = 0.45)
    
                
                if (ai.state === 'ATTACKING' || isMoving) {
            ai.rotation.y = THREE.MathUtils.lerp(ai.rotation.y, Math.atan2(player.position.x - ai.position.x, player.position.z - ai.position.z), 5 * delta);
        }

        switch (ai.state) {
            case 'HIDING':
                ai.avoiding = false;
                if (ai.currentWeapon === WEAPON_SR && ai.ammoSR > 0) {
                    ai.rotation.y = THREE.MathUtils.lerp(ai.rotation.y, Math.atan2(player.position.x - ai.position.x, player.position.z - ai.position.z), 2 * delta);
                    aiShoot(ai, timeElapsed);
                    if (isAISeen && (timeElapsed - ai.lastHiddenTime) > 1.0) {
                        if (findNewHidingSpot(ai)) {
                             ai.lastHiddenTime = timeElapsed;
                        }
                    }
                } else {
                    if (!findAndTargetWeapon(ai)) {
                                            if (isAISeen) {
                                                ai.state = 'ATTACKING';
                                                ai.currentAttackTime = timeElapsed;
                                                ai.strafeDirection = (Math.random() > 0.5 ? 1 : -1);
                                            } else if ((timeElapsed - ai.lastHiddenTime) >= HIDE_DURATION) {
                            findNewHidingSpot(ai);
                        }
                    }
                }
                break;
            case 'MOVING':
                ai.avoiding = false;
                if (isAISeen) {
                    ai.targetWeaponPickup = null;
                    ai.state = 'ATTACKING';
                    ai.currentAttackTime = timeElapsed;
                    ai.strafeDirection = (Math.random() > 0.5 ? 1 : -1);
                } else if (isArrived) {
                    ai.state = 'HIDING';
                    ai.lastHiddenTime = timeElapsed;
                    ai.targetWeaponPickup = null; 
                }
                break;
            case 'EVADING':
            case 'AVOIDING':
                if (isArrived) {
                    ai.state = 'HIDING';
                    ai.lastHiddenTime = timeElapsed;
                }
                break;
            case 'ATTACKING':
                ai.avoiding = false;
                const oldAIPosition_attack = ai.position.clone();
                const directionToPlayer = new THREE.Vector3().subVectors(player.position, ai.position).normalize();
                const strafeVector = new THREE.Vector3(directionToPlayer.z, 0, -directionToPlayer.x);
                const strafeSpeed = currentAISpeed * 0.5;
                const moveVectorDelta_attack = strafeVector.multiplyScalar(ai.strafeDirection * strafeSpeed * delta);
                ai.position.add(moveVectorDelta_attack);
                if (checkCollision(ai, obstacles)) {
                    ai.position.copy(oldAIPosition_attack);
                    ai.strafeDirection *= -1;
                }
                aiShoot(ai, timeElapsed);
                if ((timeElapsed - ai.currentAttackTime) >= ATTACK_DURATION || !isAISeen) {
                    if (!findAndTargetWeapon(ai)) {
                        findEvasionSpot(ai);
                    }
                }
                break;
        }
        
        if (isMoving && ai.state !== 'HIDING' && ai.state !== 'ATTACKING') { 
            const oldAIPosition = ai.position.clone();
            const moveDirection = new THREE.Vector3().subVectors(ai.targetPosition, ai.position).normalize();
            const moveVectorDelta = moveDirection.clone().multiplyScalar(currentAISpeed * delta);
            raycaster.set(oldAIPosition.clone().add(new THREE.Vector3(0, 1.0, 0)), moveDirection); 
            const intersects = raycaster.intersectObjects(obstacles, true);
            if (intersects.length > 0 && intersects[0].distance < AVOIDANCE_RAY_DISTANCE && !ai.avoiding && ai.state !== 'EVADING') {
                findObstacleAvoidanceSpot(ai, moveDirection); 
            } else {
                ai.position.add(moveVectorDelta); 
                if (checkCollision(ai, obstacles)) {
                    ai.position.copy(oldAIPosition); 
                    findObstacleAvoidanceSpot(ai, moveDirection); 
                }
            }
        } 
        
        const aiDistFromCenter = Math.sqrt(ai.position.x * ai.position.x + ai.position.z * ai.position.z);
        if (aiDistFromCenter > ARENA_PLAY_AREA_RADIUS) {
            const ratio = ARENA_PLAY_AREA_RADIUS / aiDistFromCenter;
            ai.position.x *= ratio;
            ai.position.z *= ratio;
        }
        
    });

    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];

        // Sniper bullet tunneling fix using raycasting
        if (p.isSniper) {
            const moveVector = p.velocity.clone().multiplyScalar(delta);
            const moveDistance = moveVector.length();
            if (moveDistance > 0) { // Only cast if the bullet is moving
                raycaster.set(p.mesh.position, moveVector.normalize());
                raycaster.far = moveDistance;
                const intersects = raycaster.intersectObjects(obstacles, true);

                if (intersects.length > 0) {
                    // We have a hit, handle it and remove the projectile
                    createSmokeEffect(intersects[0].point);
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    continue; // Skip the rest of the logic for this projectile
                }
            }
        }

        p.mesh.position.add(p.velocity.clone().multiplyScalar(delta));

        if (p.isRocket) {
            createRocketTrail(p.mesh.position.clone());
        }

        let hitSomething = false;
        const bulletSphere = new THREE.Sphere(p.mesh.position, p.isRocket ? 0.5 : 0.1);
        
        for (let j = obstacles.length - 1; j >= 0; j--) {
            const obstacle = obstacles[j];
            if (new THREE.Box3().setFromObject(obstacle).intersectsSphere(bulletSphere)) {
                hitSomething = true;
                if (p.isRocket) destroyObstacle(obstacle, p.mesh.position);
                break;
            }
        }

        if (!hitSomething && new THREE.Box3().setFromObject(floor).intersectsSphere(bulletSphere)) {
            hitSomething = true;
        }
        
        if (!hitSomething && p.source === 'player') {
            for (let j = ais.length - 1; j >= 0; j--) {
                const ai = ais[j];
                if (new THREE.Box3().setFromObject(ai).intersectsSphere(bulletSphere)) {
                    hitSomething = true;
                    // SR弾がHP無限でないAIに命中した場合
                    if (p.isSniper && ai.hp !== Infinity) {
                        ai.hp = 0;
                        aiFallDownCinematicSequence(p.velocity, ai);
                    } 
                    // ロケット弾の場合
                    else if (p.isRocket) { 
                        ai.hp = 0; 
                        startAIDeathSequence(p.velocity, ai);
                    } 
                    // 通常弾の場合
                    else {
                        if (ai.hp !== Infinity) {
                            ai.hp--;
                            // 赤い煙エフェクトを追加
                            createRedSmokeEffect(ai.position.clone().add(new THREE.Vector3(0, 1.5, 0))); 
                        }
                        if (ai.hp <= 0) {
                            aiFallDownCinematicSequence(p.velocity, ai);
                        } else {
                            findEvasionSpot(ai);
                        }
                    }

                    if (ai.hp <= 0) {
                        ais.splice(j, 1);
                    }
                    break; 
                }
            }
        }
        
        if (!hitSomething && p.source === 'ai') {
            const playerPos = player.position;
            const playerBoundingBox = new THREE.Box3();
            playerBoundingBox.min.set(playerPos.x - 0.5, playerPos.y - 2.0, playerPos.z - 0.5);
            playerBoundingBox.max.set(playerPos.x + 0.5, playerPos.y + 0.5, playerPos.z + 0.5);
            if (playerBoundingBox.intersectsSphere(bulletSphere)) {
                hitSomething = true;
                
                if (playerHP !== Infinity) {
                    if (p.isSniper || p.isRocket) {
                        playerHP = 0;
                    } else {
                        playerHP -= 1;
                    }
                    
                    screenShakeDuration = SHAKE_DURATION_MAX;
                    redFlashOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                    setTimeout(() => { redFlashOverlay.style.backgroundColor = 'transparent'; }, 100);
                }

                if (playerHP <= 0 && !isPlayerDeathPlaying) {
                     startPlayerDeathSequence(p);
                }
            }
        }
        
        if (hitSomething) {
            if (p.isRocket) {
                // ロケット弾が障害物に当たった場合の処理
                let obstacleHitByRocket = null;
                // ロケット弾が当たった障害物を特定するため、再度intersectsObjectsを呼び出す
                // (前段のhitSomething判定ではintersectsSphereを使っているため、正確なオブジェクト特定が難しい場合がある)
                raycaster.set(p.mesh.position, p.velocity.clone().normalize());
                const rocketIntersects = raycaster.intersectObjects(obstacles, true);
                if (rocketIntersects.length > 0) {
                    obstacleHitByRocket = rocketIntersects[0].object;
                }

                if (obstacleHitByRocket && obstacleHitByRocket.userData.isTower) {
                    // 命中したのが塔本体だった場合
                    obstacleHitByRocket.userData.hp -= 1; // ロケット弾1発でHPを1減らす
                    explosionSound.cloneNode(true).play().catch(e => console.error("Explosion audio playback failed:", e));
                    createExplosionEffect(p.mesh.position.clone()); // 爆発エフェクトは出す
                    
                    if (obstacleHitByRocket.userData.hp <= 0) {
                        // HPが0以下になったら破壊する
                        destroyObstacle(obstacleHitByRocket, p.mesh.position);
                    }
                } else {
                    // 塔以外の障害物、または塔の屋上フロア/カバーウォールに当たった場合は即破壊 (HPを持たないので)
                    // または、上記rocketIntersectsで障害物が特定できなかった場合
                    explosionSound.cloneNode(true).play().catch(e => console.error("Explosion audio playback failed:", e));
                    createExplosionEffect(p.mesh.position.clone());
                    if (obstacleHitByRocket) { // 実際に障害物に当たっていれば破壊
                        destroyObstacle(obstacleHitByRocket, p.mesh.position);
                    }
                }
            } else {
                // ロケット弾以外の通常の弾が当たった場合
                createSmokeEffect(p.mesh.position);
            }
            scene.remove(p.mesh);
            projectiles.splice(i, 1);
            continue; 
        }

        if (p.mesh.position.length() > 200) {
            scene.remove(p.mesh);
            projectiles.splice(i, 1);
        }
    }

    const ai1HPDisplay = document.getElementById('ai-hp-display');
    const ai2HPDisplay = document.getElementById('ai2-hp-display');
    
    const ai1 = ais[0];
    const ai2 = ais[1];

    if (ai1) {
        ai1HPDisplay.textContent = `AI 1 HP: ${ai1.hp < 0 ? 0 : (ai1.hp === Infinity ? '∞' : ai1.hp)}`;
    } else {
        ai1HPDisplay.textContent = 'AI 1 HP: 0';
    }

    if (ai2) {
        ai2HPDisplay.style.display = 'block';
        ai2HPDisplay.textContent = `AI 2 HP: ${ai2.hp < 0 ? 0 : (ai2.hp === Infinity ? '∞' : ai2.hp)}`;
    } else {
        ai2HPDisplay.style.display = 'none';
        ai2HPDisplay.textContent = 'AI 2 HP: 0';
    }

    if (ais.length === 0 && isGameRunning && !isAIDeathPlaying) {
        showWinScreen();
    }
    playerHPDisplay.textContent = `HP: ${playerHP === Infinity ? '∞' : playerHP}`;


    if (screenShakeDuration > 0) {
        screenShakeDuration -= delta;
        const shakeFactor = screenShakeDuration / SHAKE_DURATION_MAX;
        camera.position.x = (Math.random() - 0.5) * SHAKE_INTENSITY * shakeFactor;
        camera.position.y = (Math.random() - 0.5) * SHAKE_INTENSITY * shakeFactor;
    } else camera.position.set(0, 0, 0);
    
    TWEEN.update();
    renderer.render(scene, camera);
}
// Start Game Event (with safe check)
const startBtn = document.getElementById('start-game-btn');
if (startBtn) {
    startBtn.addEventListener('click', () => {
        gameSettings.playerHP = document.getElementById('player-hp').value;
        gameSettings.aiHP = document.getElementById('ai-hp').value;
        gameSettings.mgCount = parseInt(document.getElementById('mg-count').value, 10);
        gameSettings.rrCount = parseInt(document.getElementById('rr-count').value, 10);
        gameSettings.srCount = parseInt(document.getElementById('sr-count').value, 10);
        gameSettings.fieldState = document.querySelector('input[name="field-state"]:checked').value;
        gameSettings.mapType = document.querySelector('input[name="map-type"]:checked').value;
        gameSettings.aiCount = parseInt(document.querySelector('input[name="ai-count"]:checked').value, 10);

        startGame();
    });
}

const rButtons = document.querySelectorAll('.restart-button');
rButtons.forEach(button => button.addEventListener('click', () => { restartGame(); if (!('ontouchstart' in window)) canvas.requestPointerLock(); }));

const settingsLinks = document.querySelectorAll('.settings-link');
settingsLinks.forEach(link => {
    link.addEventListener('click', (e) => {
        e.preventDefault();
        const screenToHideId = link.dataset.screenToHide;
        document.getElementById(screenToHideId).style.display = 'none';
        startScreen.style.display = 'flex';
    });
});
window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
animate();
    </script>
</body>
</html>
