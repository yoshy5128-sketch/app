<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Map Editor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #2c3e50; 
            color: #ecf0f1; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }
        #editor-container { 
            position: relative; 
        }
        #ui-container { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(44, 62, 80, 0.85); 
            padding: 15px; 
            border-radius: 8px;
            border: 1px solid #34495e;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            max-width: 250px;
        }
        h2 { 
            margin-top: 0; 
            color: #1abc9c;
            border-bottom: 1px solid #16a085;
            padding-bottom: 5px;
        }
        p { 
            margin: 5px 0 10px 0; 
            font-size: 0.9em;
        }
        button { 
            width: 100%;
            margin-top: 10px; 
            padding: 10px 12px; 
            cursor: pointer; 
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        #back-button {
            background-color: #e74c3c;
        }
        #back-button:hover {
            background-color: #c0392b;
        }
        hr {
            border: none;
            border-top: 1px solid #34495e;
            margin: 15px 0;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
        }
        #notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1abc9c;
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="editor-container">
        <div id="canvas-container"></div>
        <div id="ui-container">
            <h2>Map Editor</h2>
            <p><b>左クリック:</b> 障害物を追加</p>
            <p><b>ドラッグ:</b> 障害物を移動</p>
            <p><b>右クリック:</b> 障害物を削除</p>

            <div id="properties-editor" style="display: none; margin-top: 15px;">
                <h4>Properties</h4>
                <label style="display: block; margin-bottom: 5px;">Width (X): <input type="number" id="prop-width" step="0.5" style="width: 60px;"></label>
                <label style="display: block; margin-bottom: 5px;">Height (Y): <input type="number" id="prop-height" step="0.5" style="width: 60px;"></label>
                <label style="display: block; margin-bottom: 10px;">Depth (Z): <input type="number" id="prop-depth" step="0.5" style="width: 60px;"></label>
                <button id="apply-props-button" style="width: auto; padding: 5px 10px; font-size: 0.9em;">Apply Size</button>
            </div>

            <hr>
            <p style="font-size: 0.8em; text-align: center; opacity: 0.7;">-- Browser Storage --</p>
            <button id="save-browser-button">Save to Browser</button>
            <button id="load-browser-button">Load from Browser</button>
            <hr>
            <p style="font-size: 0.8em; text-align: center; opacity: 0.7;">-- File I/O --</p>
            <button id="export-file-button">Export to File</button>
            <button id="import-file-button">Import from File</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
            <hr>
            <button id="reset-button">New Map</button>
            <hr>
            <a href="index.html"><button id="back-button">Back to Game</button></a>
        </div>
    </div>
    <div id="notification"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- CONSTANTS ---
        const ARENA_RADIUS = 60;
        const ARENA_EDGE_THICKNESS = 1;
        const OBSTACLE_DEFAULT_SIZE = 4;
        const OBSTACLE_HEIGHT = 4;
        const PLAYER_INITIAL_POSITIONS = [
            {x: 0, z: -20, color: 0x0000ff}, // Player
            {x: 0, z: 20, color: 0x00ff00},  // AI 1
            {x: 15, z: 20, color: 0x00ffff}  // AI 2
        ];

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2c3e50);

        const canvasContainer = document.getElementById('canvas-container');
        
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 150;
        const camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 1, 1000);
        camera.position.set(0, 100, 0);
        camera.lookAt(scene.position);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        canvasContainer.appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(50, 100, 25);
        scene.add(directionalLight);

        // --- ARENA ---
        const floorGeometry = new THREE.CircleGeometry(ARENA_RADIUS, 64);
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x34495e });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.name = 'floor';
        scene.add(floor);

        const edgeGeometry = new THREE.TorusGeometry(ARENA_RADIUS, ARENA_EDGE_THICKNESS, 8, 100);
        const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x95a5a6 });
        const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
        edge.rotation.x = Math.PI / 2;
        scene.add(edge);
        
        // --- SPAWN POINTS ---
        PLAYER_INITIAL_POSITIONS.forEach(pos => {
            const spawnGeo = new THREE.CylinderGeometry(2, 2, 0.5, 32);
            const spawnMat = new THREE.MeshBasicMaterial({ color: pos.color, transparent: true, opacity: 0.5 });
            const spawnMesh = new THREE.Mesh(spawnGeo, spawnMat);
            spawnMesh.position.set(pos.x, 0.25, pos.z);
            scene.add(spawnMesh);
        });

        // --- STATE ---
        let obstacles = [];
        let selectedObstacle = null;
        let isDragging = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

        // --- FUNCTIONS ---
        function createAndAttachLadder(obstacle) {
            const LADDER_WIDTH = 1.5;
            const RUNG_SPACING = 0.5;
            const RUNG_THICKNESS = 0.1;

            const ladderGroup = new THREE.Group();
            ladderGroup.name = 'ladder'; // 削除時に識別するため名前をつける
            const obstacleSize = new THREE.Vector3();
            new THREE.Box3().setFromObject(obstacle).getSize(obstacleSize);

            const numRungs = Math.floor(obstacleSize.y / RUNG_SPACING);

            const sideMaterial = new THREE.MeshLambertMaterial({ color: 0x607d8b }); // Editor color
            const rungMaterial = new THREE.MeshLambertMaterial({ color: 0x90a4ae }); // Editor color

            const sideGeometry = new THREE.BoxGeometry(RUNG_THICKNESS * 2, obstacleSize.y, RUNG_THICKNESS * 2);
            const leftSide = new THREE.Mesh(sideGeometry, sideMaterial);
            const rightSide = new THREE.Mesh(sideGeometry, sideMaterial);
            leftSide.position.set(-LADDER_WIDTH / 2, 0, 0);
            rightSide.position.set(LADDER_WIDTH / 2, 0, 0);
            ladderGroup.add(leftSide);
            ladderGroup.add(rightSide);

            for (let i = 0; i < numRungs; i++) {
                const rungGeometry = new THREE.BoxGeometry(LADDER_WIDTH, RUNG_THICKNESS, RUNG_THICKNESS);
                const rung = new THREE.Mesh(rungGeometry, rungMaterial);
                rung.position.y = -obstacleSize.y / 2 + RUNG_SPACING * (i + 0.5);
                ladderGroup.add(rung);
            }
            
            const face = Math.floor(Math.random() * 4);
            const offset = 0.1;

            switch (face) {
                case 0: // +Z
                    ladderGroup.position.set(0, 0, obstacleSize.z / 2 + offset);
                    break;
                case 1: // -Z
                    ladderGroup.position.set(0, 0, -obstacleSize.z / 2 - offset);
                    break;
                case 2: // +X
                    ladderGroup.position.set(obstacleSize.x / 2 + offset, 0, 0);
                    ladderGroup.rotation.y = Math.PI / 2;
                    break;
                case 3: // -X
                    ladderGroup.position.set(-obstacleSize.x / 2 - offset, 0, 0);
                    ladderGroup.rotation.y = -Math.PI / 2;
                    break;
            }
            obstacle.add(ladderGroup);
        }

        function createObstacle(x, z, width = OBSTACLE_DEFAULT_SIZE, height = OBSTACLE_HEIGHT, depth = OBSTACLE_DEFAULT_SIZE, isNew = true) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ color: 0x1abc9c });
            const obstacle = new THREE.Mesh(geometry, material);
            obstacle.position.set(x, height / 2, z);
            
            if (isNew) {
                const halfWidth = width / 2;
                const halfDepth = depth / 2;
                const corners = [
                    new THREE.Vector2(x - halfWidth, z - halfDepth), new THREE.Vector2(x + halfWidth, z - halfDepth),
                    new THREE.Vector2(x - halfWidth, z + halfDepth), new THREE.Vector2(x + halfWidth, z + halfDepth)
                ];
                for (const corner of corners) {
                    if (corner.length() > ARENA_RADIUS) {
                        showNotification('Cannot place obstacle outside the arena.', true);
                        return; // アリーナ外には配置しない
                    }
                }
            }

            scene.add(obstacle);
            obstacles.push(obstacle);
            
            // 高さチェックと梯子設置
            if (height > OBSTACLE_HEIGHT * 2) {
                createAndAttachLadder(obstacle);
            }
        }

        function saveMap() {
            const mapData = obstacles.map(obs => {
                const ladder = obs.getObjectByName('ladder');
                return {
                    x: obs.position.x,
                    z: obs.position.z,
                    width: obs.geometry.parameters.width,
                    height: obs.geometry.parameters.height,
                    depth: obs.geometry.parameters.depth,
                    // Note: ラダーの情報は保存せず、ロード時に再生成する
                };
            });
            localStorage.setItem('customMapData', JSON.stringify(mapData));
            showNotification('Map saved successfully!');
        }

        function loadMap() {
            resetMap();
            const mapData = localStorage.getItem('customMapData');
            if (mapData) {
                const parsedData = JSON.parse(mapData);
                parsedData.forEach(data => createObstacle(data.x, data.z, data.width, data.height, data.depth, false));
                showNotification('Map loaded!');
            } else {
                showNotification('No saved map found.', true);
            }
        }
        
        function resetMap() {
            obstacles.forEach(obs => scene.remove(obs));
            obstacles = [];
            if(selectedObstacle) {
                setSelected(null); // エディタも非表示にする
            }
        }
        
        function showNotification(message, isError = false) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.backgroundColor = isError ? '#e74c3c' : '#1abc9c';
            notification.style.opacity = '1';
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 2000);
        }

        function setSelected(object) {
            const editor = document.getElementById('properties-editor');
            const widthInput = document.getElementById('prop-width');
            const heightInput = document.getElementById('prop-height');
            const depthInput = document.getElementById('prop-depth');

            if (selectedObstacle) {
                selectedObstacle.material.emissive.setHex(0x000000);
            }
            
            if (object && obstacles.includes(object)) {
                selectedObstacle = object;
                selectedObstacle.material.emissive.setHex(0x555555);
                
                widthInput.value = selectedObstacle.geometry.parameters.width;
                heightInput.value = selectedObstacle.geometry.parameters.height;
                depthInput.value = selectedObstacle.geometry.parameters.depth;
                
                editor.style.display = 'block';
            } else {
                selectedObstacle = null;
                editor.style.display = 'none';
            }
        }
        
        function applyProperties() {
            if (!selectedObstacle) return;

            const width = parseFloat(document.getElementById('prop-width').value);
            const height = parseFloat(document.getElementById('prop-height').value);
            const depth = parseFloat(document.getElementById('prop-depth').value);

            if (isNaN(width) || isNaN(height) || isNaN(depth) || width <= 0 || height <= 0 || depth <= 0) {
                showNotification('Invalid dimensions.', true);
                return;
            }
            
            const halfWidth = width / 2;
            const halfDepth = depth / 2;
            const x = selectedObstacle.position.x;
            const z = selectedObstacle.position.z;
            const corners = [
                new THREE.Vector2(x - halfWidth, z - halfDepth), new THREE.Vector2(x + halfWidth, z - halfDepth),
                new THREE.Vector2(x - halfWidth, z + halfDepth), new THREE.Vector2(x + halfWidth, z + depth)
            ];
            for (const corner of corners) {
                if (corner.length() > ARENA_RADIUS) {
                    showNotification('Resized obstacle would be outside the arena.', true);
                    return;
                }
            }

            // 古い梯子を削除
            const oldLadder = selectedObstacle.getObjectByName('ladder');
            if (oldLadder) {
                selectedObstacle.remove(oldLadder);
            }

            selectedObstacle.geometry.dispose();
            selectedObstacle.geometry = new THREE.BoxGeometry(width, height, depth);
            selectedObstacle.position.y = height / 2;

            // 新しい高さで再度梯子を付けるか判断
            if (height > OBSTACLE_HEIGHT * 2) {
                createAndAttachLadder(selectedObstacle);
            }

            showNotification('Size applied!');
        }

        // --- EVENT LISTENERS ---
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging && selectedObstacle) {
                raycaster.setFromCamera(mouse, camera);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                selectedObstacle.position.x = intersection.x;
                selectedObstacle.position.z = intersection.z;
            }
        }

        function onMouseDown(event) {
            // 左クリック
            if (event.button === 0) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(obstacles);

                if (intersects.length > 0) { // 障害物をクリックした場合
                    isDragging = true;
                    setSelected(intersects[0].object);
                } else { // 障害物以外をクリックした場合
                    setSelected(null); // まず選択を解除
                    const floorIntersects = raycaster.intersectObject(floor);
                    if (floorIntersects.length > 0) { // 床をクリックした場合は、新しい障害物を生成
                        const pos = floorIntersects[0].point;
                        createObstacle(pos.x, pos.z);
                    }
                }
            } 
            // 右クリック
            else if (event.button === 2) {
                 raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(obstacles);
                if (intersects.length > 0) {
                    const toDelete = intersects[0].object;
                    scene.remove(toDelete);
                    obstacles = obstacles.filter(obs => obs !== toDelete);
                    setSelected(null); // 削除したら選択も解除
                }
            }
        }

        function onMouseUp(event) {
            if (event.button === 0) {
                isDragging = false;
            }
        }
        
        function onKeyDown(event) {
            if (event.key === 'Delete' && selectedObstacle) {
                scene.remove(selectedObstacle);
                obstacles = obstacles.filter(obs => obs !== selectedObstacle);
                setSelected(null); // 削除したら選択も解除
            }
        }
        
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('resize', onWindowResize);
        
        // --- NEW I/O FUNCTIONS ---
        function exportMapToFile() {
            const mapData = obstacles.map(obs => ({
                x: obs.position.x,
                z: obs.position.z,
                width: obs.geometry.parameters.width,
                height: obs.geometry.parameters.height,
                depth: obs.geometry.parameters.depth,
            }));
            const jsonString = JSON.stringify(mapData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gunfight-map-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('Map exported to file!');
        }

        function importMapFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const mapData = JSON.parse(e.target.result);
                    if (!Array.isArray(mapData)) throw new Error('Invalid map format.');
                    
                    resetMap();
                    mapData.forEach(data => createObstacle(data.x, data.z, data.width, data.height, data.depth, false));
                    showNotification('Map imported successfully!');
                } catch (error) {
                    showNotification('Error: Could not read map file.', true);
                    console.error('Map import error:', error);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input to allow re-importing the same file
        }

        // --- ATTACH EVENT LISTENERS ---
        document.getElementById('save-browser-button').addEventListener('click', saveMap);
        document.getElementById('load-browser-button').addEventListener('click', loadMap);
        document.getElementById('reset-button').addEventListener('click', () => {
            resetMap();
            showNotification('New map created.');
        });
        document.getElementById('apply-props-button').addEventListener('click', applyProperties);
        
        document.getElementById('export-file-button').addEventListener('click', exportMapToFile);
        document.getElementById('import-file-button').addEventListener('click', () => document.getElementById('import-file-input').click());
        document.getElementById('import-file-input').addEventListener('change', importMapFromFile);

        // UI上でのクリックが3Dシーンに影響しないようにイベントの伝播を停止
        document.getElementById('ui-container').addEventListener('mousedown', (event) => {
            event.stopPropagation();
        });

        // --- RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
        loadMap(); // ページ読み込み時に自動で前回保存したマップを読み込む
    </script>
</body>
</html>