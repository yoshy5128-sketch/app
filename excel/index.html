<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Excel / CSV 整理ツール (ブラウザ)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;line-height:1.4;padding:18px;background:#f7fafc;color:#111}
    h1{font-size:20px;margin:0 0 10px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
    button,input,select{padding:8px;border-radius:8px;border:1px solid #ddd;background:#fff}
    #sheetPreview{width:100%;overflow:auto;border:1px solid #e3e8ef;background:#fff;padding:8px;margin-top:12px}
    table{border-collapse:collapse;width:100%;min-width:600px}
    th,td{border:1px solid #eee;padding:6px;text-align:left;max-width:260px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    th{background:#f1f5f9;position:sticky;top:0}
    .small{font-size:13px;color:#555}
    footer{margin-top:14px;font-size:13px;color:#666}
  </style>
</head>
<body>
  <h1>Excel / CSV 整理ツール（ブラウザ実行・ファイルはローカルで処理されます）</h1>
  <div class="controls">
    <input id="fileInput" type="file" accept=".xlsx,.xls,.csv" />
    <button id="loadSample">サンプル読み込み</button>
    <select id="sheetSelect" style="min-width:160px"></select>
    <button id="previewBtn">プレビュー表示</button>
    <button id="exportXlsx">XLSXで保存</button>
    <button id="exportCsv">CSVで保存</button>
  </div>

  <div class="controls">
    <button id="trimBtn">全セルの前後空白を削除</button>
    <button id="removeEmptyRows">空行を削除</button>
    <button id="removeEmptyCols">空列を削除</button>
    <button id="toNumber">数値へ変換（可能なセル）</button>
    <button id="normalizeDates">日付を正規化（ISO）</button>
    <button id="dedupeRows">重複行を削除</button>
    <label class="small">ソート列: <input id="sortCol" style="width:60px" value="0" /></label>
    <button id="sortBtn">ソート</button>
  </div>

  <div id="sheetPreview" aria-live="polite">ファイルを選択してください（ブラウザ内で処理します）。</div>

  <footer>
    <div>使い方：ファイルを読み込み → シートを選択 → プレビュー表示。整理ボタンで編集→ エクスポート。</div>
    <div class="small">注意：ブラウザ内で処理するためファイルはサーバへ送信されません。複雑な変換（日本語日付など）は一部変換できない場合があります。</div>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    // グローバル状態
    let workbook = null;
    let currentSheetName = null;
    let sheetData = []; // array of arrays

    const fileInput = document.getElementById('fileInput');
    const sheetSelect = document.getElementById('sheetSelect');
    const sheetPreview = document.getElementById('sheetPreview');

    fileInput.addEventListener('change', async (e)=>{
      const f = e.target.files[0];
      if(!f) return;
      const data = await f.arrayBuffer();
      workbook = XLSX.read(data, {type:'array'});
      populateSheets();
      sheetPreview.innerText = 'シートを選択して「プレビュー表示」を押してください。';
    });

    document.getElementById('loadSample').addEventListener('click', ()=>{
      // 小さなサンプルデータ
      workbook = XLSX.utils.book_new();
      const a = [
        ["名前","年齢","入社日","備考"],
        [" 山田 太郎 "," 30","2020/04/01","新入"],
        ["佐藤花子","25","2021-11-15",""],
        ["山田 太郎","30","2020-04-01","重複サンプル"]
      ];
      const ws = XLSX.utils.aoa_to_sheet(a);
      XLSX.utils.book_append_sheet(workbook, ws, 'サンプル');
      populateSheets();
      sheetPreview.innerText = 'サンプルを読み込みました。シートを選択してプレビューを表示します。';
    });

    function populateSheets(){
      sheetSelect.innerHTML = '';
      workbook.SheetNames.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name; opt.textContent = name;
        sheetSelect.appendChild(opt);
      });
      currentSheetName = workbook.SheetNames[0];
    }

    document.getElementById('previewBtn').addEventListener('click', ()=>{
      currentSheetName = sheetSelect.value;
      const ws = workbook.Sheets[currentSheetName];
      sheetData = XLSX.utils.sheet_to_json(ws, {header:1, defval:''});
      renderPreview();
    });

    function renderPreview(){
      if(!sheetData.length){ sheetPreview.innerText = 'シートにデータがありません'; return; }
      const table = document.createElement('table');
      // header
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      const maxCols = Math.max(...sheetData.map(r=>r.length));
      for(let c=0;c<maxCols;c++){
        const th = document.createElement('th'); th.textContent = c; headRow.appendChild(th);
      }
      thead.appendChild(headRow);
      table.appendChild(thead);
      // body
      const tbody = document.createElement('tbody');
      sheetData.forEach((row,ridx)=>{
        const tr = document.createElement('tr');
        for(let c=0;c<maxCols;c++){
          const td = document.createElement('td');
          td.contentEditable = true;
          td.dataset.r = ridx; td.dataset.c = c;
          td.textContent = row[c] !== undefined ? row[c] : '';
          td.addEventListener('blur', (ev)=>{
            const rr = parseInt(ev.target.dataset.r); const cc = parseInt(ev.target.dataset.c);
            sheetData[rr] = sheetData[rr] || [];
            sheetData[rr][cc] = ev.target.textContent;
          });
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      sheetPreview.innerHTML = ''; sheetPreview.appendChild(table);
    }

    // ユーティリティ関数
    function trimAll(){
      sheetData = sheetData.map(row => row.map(cell => typeof cell === 'string' ? cell.trim() : cell));
    }

    function removeEmptyRowsFunc(){
      sheetData = sheetData.filter(row => row.some(cell => String(cell).trim() !== ''));
    }

    function removeEmptyColsFunc(){
      const maxCols = Math.max(...sheetData.map(r=>r.length));
      const keep = [];
      for(let c=0;c<maxCols;c++){
        let colHas = false;
        for(let r=0;r<sheetData.length;r++){
          if(String(sheetData[r][c]||'').trim() !== ''){ colHas = true; break; }
        }
        if(colHas) keep.push(c);
      }
      sheetData = sheetData.map(row => keep.map(c => row[c]));
    }

    function toNumberFunc(){
      sheetData = sheetData.map(row => row.map(cell => {
        if(typeof cell === 'string'){
          const num = cell.replace(/,/g,'');
          if(num !== '' && !isNaN(Number(num))) return Number(num);
        }
        return cell;
      }));
    }

    function normalizeDatesFunc(){
      sheetData = sheetData.map(row => row.map(cell => {
        if(typeof cell === 'string'){
          const s = cell.trim();
          // try common patterns
          const d = new Date(s);
          if(!isNaN(d)) return d.toISOString().slice(0,10); // YYYY-MM-DD
          // try yyyy/mm/dd like
          const m = s.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
          if(m){ return `${m[1]}-${String(m[2]).padStart(2,'0')}-${String(m[3]).padStart(2,'0')}`; }
        }
        return cell;
      }));
    }

    function dedupeRowsFunc(){
      const seen = new Set();
      const out = [];
      for(const row of sheetData){
        const key = row.map(v=>String(v)).join('||');
        if(!seen.has(key)){ seen.add(key); out.push(row); }
      }
      sheetData = out;
    }

    function sortByColFunc(colIndex){
      sheetData = sheetData.slice();
      const header = sheetData[0];
      const body = sheetData.slice(1);
      body.sort((a,b)=>{
        const va = a[colIndex] ?? '';
        const vb = b[colIndex] ?? '';
        // numeric if both numeric
        if(!isNaN(Number(va)) && !isNaN(Number(vb))) return Number(va)-Number(vb);
        return String(va).localeCompare(String(vb), undefined, {numeric:true});
      });
      sheetData = [header].concat(body);
    }

    // ボタンに接続
    document.getElementById('trimBtn').addEventListener('click', ()=>{ trimAll(); renderPreview(); });
    document.getElementById('removeEmptyRows').addEventListener('click', ()=>{ removeEmptyRowsFunc(); renderPreview(); });
    document.getElementById('removeEmptyCols').addEventListener('click', ()=>{ removeEmptyColsFunc(); renderPreview(); });
    document.getElementById('toNumber').addEventListener('click', ()=>{ toNumberFunc(); renderPreview(); });
    document.getElementById('normalizeDates').addEventListener('click', ()=>{ normalizeDatesFunc(); renderPreview(); });
    document.getElementById('dedupeRows').addEventListener('click', ()=>{ dedupeRowsFunc(); renderPreview(); });
    document.getElementById('sortBtn').addEventListener('click', ()=>{
      const ci = parseInt(document.getElementById('sortCol').value||0);
      sortByColFunc(ci); renderPreview();
    });

    // エクスポート
    document.getElementById('exportXlsx').addEventListener('click', ()=>{
      if(!workbook) return alert('先にファイルを読み込んでください');
      const newWb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(sheetData);
      XLSX.utils.book_append_sheet(newWb, ws, currentSheetName || 'Sheet1');
      const wbout = XLSX.write(newWb, {bookType:'xlsx', type:'array'});
      const blob = new Blob([wbout], {type:'application/octet-stream'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = (currentSheetName||'sheet') + '.xlsx'; a.click(); URL.revokeObjectURL(url);
    });

    document.getElementById('exportCsv').addEventListener('click', ()=>{
      const csv = sheetData.map(r => r.map(c=> '"'+String(c).replace(/"/g,'""')+'"').join(',')).join('\n');
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = (currentSheetName||'sheet') + '.csv'; a.click(); URL.revokeObjectURL(url);
    });

    // シートの選択が変わったら自動プレビュー（オプション）
    sheetSelect.addEventListener('change', ()=>{
      // do nothing automatically to avoid accidental overwrite
    });

  </script>
</body>
</html>
