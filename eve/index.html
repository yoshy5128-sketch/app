<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Everest Simulator - Maze Edition (Easy Oxygen)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; touch-action: none; }
        
        /* トップページ画面 */
        #top-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: url('top.png') no-repeat center center;
            background-size: cover;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 500; color: white; text-shadow: 2px 2px 10px rgba(0,0,0,0.8);
        }
        #title-logo { font-size: 36px; font-weight: bold; margin-bottom: 25px; letter-spacing: 5px; }
        .menu-btn {
            padding: 10px 25px; font-size: 16px; font-weight: bold; cursor: pointer;
            border: 2px solid white; background: rgba(0,0,0,0.5); color: white;
            margin: 8px; transition: 0.3s; width: 200px;
        }
        .menu-btn:hover { background: white; color: black; }
        
        /* 説明パネル */
        #instructions-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; max-width: 500px; background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff00; padding: 20px; color: #fff; z-index: 600;
            display: none; line-height: 1.5; font-size: 12px;
        }
        #close-btn { margin-top: 15px; padding: 8px 16px; background: #00ff00; color: #000; border: none; cursor: pointer; font-weight: bold; }

        /* インスツルメントパネル (最小化) */
        #instrument-panel {
            position: absolute; top: 10px; left: 10px; color: #00ff00; 
            background: rgba(0, 20, 0, 0.8); padding: 6px; border: 1px solid #00ff00;
            z-index: 10; font-size: 9px; pointer-events: none; min-width: 110px;
        }
        .data-value { font-weight: bold; font-size: 12px; color: #fff; }
        #o2-container { width: 100%; height: 6px; background: #003300; border: 1px solid #00ff00; margin-top: 3px; position: relative; }
        #o2-bar { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s; }

        /* STEPボタン (丸ボタン) */
        #step-btn-container {
            position: absolute; bottom: 30px; left: 30px; width: 100px; height: 100px;
            background: rgba(255, 255, 255, 0.2); border: 3px solid rgba(255,255,255,0.5); 
            border-radius: 50%; z-index: 100; display: none; align-items: center; justify-content: center;
            user-select: none; -webkit-user-select: none; touch-action: none;
        }
        #step-btn-container:active { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
        #step-btn-text { color: white; font-weight: bold; font-size: 18px; pointer-events: none; }

        /* 視点操作エリア (感度重視) */
        #touch-look-area { position: absolute; top: 0; right: 0; width: 75%; height: 100%; z-index: 5; display: none; }

        /* マップ (最小化) */
        #map-display { position: absolute; top: 10px; right: 10px; width: 85px; height: 85px; background: rgba(0, 40, 0, 0.6); border: 1px solid #00ff00; z-index: 10; }
        #summit-dot { position: absolute; width: 5px; height: 5px; background: #ff0000; left: 50%; top: 5%; transform: translate(-50%, -50%); clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        #bc-dot { position: absolute; width: 5px; height: 5px; background: #00aaff; transform: translate(-50%, -50%); border: 1px solid #fff; }
        #rescue-dot { position: absolute; width: 8px; height: 8px; background: #ffff00; clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); display: none; transform: translate(-50%, -50%); }
        #player-icon { position: absolute; width: 8px; height: 12px; background: #fff; clip-path: polygon(50% 0%, 0% 100%, 50% 75%, 100% 100%); transform-origin: center; }

        #vision-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; opacity: 0; pointer-events: none; z-index: 100; }
        #phase-notice { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); color: #ffff00; padding: 12px; border: 2px solid #ffff00; z-index: 150; display: none; text-align: center; pointer-events: none; font-size: 13px; }
        #message-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; display: none; z-index: 200; color: white; background: rgba(0,0,0,0.9); padding: 30px; border: 2px solid #fff; width: 80%; }
        .btn-retry { margin-top: 20px; padding: 10px 20px; background: #fff; border: none; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <div id="top-screen">
        <div id="title-logo">EVEREST SIMULATOR</div>
        <button class="menu-btn" id="start-climb-btn">START CLIMBING</button>
        <button class="menu-btn" id="continue-climb-btn" style="display:none;">CONTINUE CLIMB</button>
        <button class="menu-btn" id="heli-mode-btn">HELICOPTER MODE</button>
        <button class="menu-btn" id="how-to-btn">INSTRUCTIONS</button>
    </div>

    <div id="instructions-panel">
        <h3>遊び方</h3>
        <p>あなたは今から、エベレスト制覇を目指します！<br>
        ベースキャンプを出発し、エベレストの頂上を目指してください。<br>
        途中、視界不良をはじめ、落ちたら確実に死亡するクレバス、そして限りある酸素との戦いがあなたを待ち受けています。<br>
        登山のスピードを上げればそれだけ酸素も早く減ります。酸素が無くなると視界がブラックアウトし、気を失ってしまいます。<br>
        たとえ無事に登頂が成功しても、今度は下山の恐怖があなたを待ち受けています。<br>
        登頂に成功したら、まずは近くのレスキュー（黄色のテント★）を目指して酸素を補給してください。<br>
        そして無事にベースキャンプまで辿り着けたら、それが本当の意味でのエベレスト制覇です！<br>
        がんばってください。</p>
        <button id="close-btn">閉じる</button>
    </div>

    <button id="exit-heli-btn" style="position: absolute; bottom: 20px; right: 20px; z-index: 200; display: none; padding: 10px 20px; background: #ff0000; color: white; border: none; cursor: pointer; font-weight: bold;">終了</button>
    <div id="touch-move-area" style="position: absolute; top: 0; left: 0; width: 25%; height: 100%; z-index: 4; display: none;"></div>

    <div id="vision-overlay"></div>
    <div id="phase-notice"></div>

    <div id="instrument-panel">
        <div id="stage-text" style="color:#ffff00; margin-bottom: 3px;">PHASE: ASCENT</div>
        <div>ALTITUDE: <span id="alt-val" class="data-value">5364.00</span>m</div>
        <div>TO GOAL: <span id="dist-val" class="data-value">--</span>m</div>
        <div>WEATHER: <span id="weather-text" class="data-value">NORMAL</span></div>
        <div style="margin-top:5px;">OXYGEN:</div>
        <div id="o2-container"><div id="o2-bar"></div></div>
    </div>

    <div id="map-display">
        <div id="bc-dot"></div>
        <div id="summit-dot"></div>
        <div id="rescue-dot"></div>
        <div id="player-icon"></div>
    </div>

    <div id="step-btn-container"><div id="step-btn-text">STEP</div></div>
    <div id="touch-look-area"></div>

    <div id="message-screen">
        <h1 id="msg-title"></h1>
        <p id="msg-body"></p>
        <button class="btn-retry">RETRY</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 設定 ---
        const LOCAL_STORAGE_KEY = 'everestSimulatorSaveData';
        let savedGameData = null; 
        const START_ALT = 5364.00;
        const TARGET_ALT = 8848.00;
        const TERRAIN_SIZE = 6000;
        const START_POS_XZ = { x: 0, z: 2000 };
        const SUMMIT_POS_XZ = { x: 0, z: -2800 };

        let gameState = 'ASCENT';
        let oxygen = 100;
        const O2_LOSS_NORMAL = 0.001;
        const O2_LOSS_MOVING = 0.003;
        let rescuePos = null;
        let rescueObject = null;
        let isEnded = false;
        let gameStartTime = 0;
        let isStepButtonPressed = false;
        let isHeliMode = false;

        const TOUCH_SENSITIVITY = 0.014;
        let touchMoveId = null, lastMoveY = 0;

        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        if (isTouchDevice) {
            document.getElementById('step-btn-container').style.display = 'flex';
            document.getElementById('touch-look-area').style.display = 'block';
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.5, 18000);
        const listener = new THREE.AudioListener();
        camera.add(listener);
        camera.rotation.order = 'YXZ';
        const windSound = new THREE.Audio(listener);
        const heliSound = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();

        audioLoader.load('wind.mp3', (buffer) => {
            windSound.setBuffer(buffer);
            windSound.setLoop(true);
            windSound.setVolume(0);
        });
        audioLoader.load('heli.mp3', (buffer) => {
            heliSound.setBuffer(buffer);
            heliSound.setLoop(true);
            heliSound.setVolume(0.5);
        });

        const topScreen = document.getElementById('top-screen');
        const startBtn = document.getElementById('start-climb-btn');
        const howToBtn = document.getElementById('how-to-btn');
        const instructions = document.getElementById('instructions-panel');
        const closeBtn = document.getElementById('close-btn');
        const continueBtn = document.getElementById('continue-climb-btn');
        const heliModeBtn = document.getElementById('heli-mode-btn');
        const exitHeliBtn = document.getElementById('exit-heli-btn');

        howToBtn.onclick = () => instructions.style.display = 'block';
        closeBtn.onclick = () => instructions.style.display = 'none';
        exitHeliBtn.onclick = () => {
            if (heliSound.isPlaying) heliSound.stop();
            location.reload();
        };

        async function enterGame(shouldLoad = false) {
            const docElm = document.documentElement;
            const requestFs = docElm.requestFullscreen || docElm.mozRequestFullScreen || docElm.webkitRequestFullScreen || docElm.msRequestFullscreen;
            if (requestFs) {
                try {
                    await requestFs.call(docElm);
                    if (screen.orientation && screen.orientation.lock) {
                        await screen.orientation.lock('landscape').catch(() => {});
                    }
                } catch (err) {}
            }
            topScreen.style.display = 'none';
            gameStartTime = performance.now();
            if (!isHeliMode && windSound.buffer && !windSound.isPlaying) {
                windSound.play();
            }
            if (!isTouchDevice) renderer.domElement.requestPointerLock();
            if (shouldLoad) {
                document.getElementById('stage-text').innerText = `PHASE: ${gameState}`;
                document.getElementById('stage-text').style.color = "#00aaff";
                document.getElementById('o2-bar').style.width = oxygen + "%";
            }
        }

        async function enterHeliMode() {
            isHeliMode = true;
            document.getElementById('instrument-panel').style.display = 'none';
            document.getElementById('map-display').style.display = 'none';
            document.getElementById('step-btn-text').innerText = "FORWARD";
            document.getElementById('touch-move-area').style.display = 'block';
            exitHeliBtn.style.display = 'block';
            
            await enterGame(false);

            if (windSound.isPlaying) windSound.stop();
            if (heliSound.buffer && !heliSound.isPlaying) heliSound.play();

            player.pos.set(START_POS_XZ.x, baseH + 200, START_POS_XZ.z);
        }

        async function loadGame() {
            const savedDataString = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedDataString) {
                try {
                    const data = JSON.parse(savedDataString);
                    player.pos.set(data.playerPos.x, data.playerPos.y, data.playerPos.z);
                    player.rotY = data.playerRotY;
                    player.rotX = data.playerRotX;
                    oxygen = data.oxygen;
                    gameState = data.gameState;
                    await enterGame(true);
                    return true;
                } catch (e) {
                    console.error("ロード失敗:", e);
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    return false;
                }
            }
            return false;
        }

        function initGame() {
            savedGameData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedGameData) continueBtn.style.display = 'block';
            continueBtn.onclick = loadGame;
            startBtn.onclick = async () => {
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                await enterGame();
            };
            heliModeBtn.onclick = enterHeliMode;
        }
        initGame();

        const stepBtn = document.getElementById('step-btn-container');
        const startStep = (e) => { e.preventDefault(); isStepButtonPressed = true; };
        const stopStep = () => { isStepButtonPressed = false; };
        stepBtn.addEventListener('touchstart', startStep, { passive: false });
        stepBtn.addEventListener('touchend', stopStep, { passive: false });
        stepBtn.addEventListener('mousedown', startStep);
        window.addEventListener('mouseup', stopStep);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        function getRawHeight(x, z) {
            let h = (2500 - z) * 0.4;
            let distToSummit = Math.sqrt(x * x + (z + 2800) * (z + 2800));
            h += Math.max(0, 1200 - distToSummit * 0.4);
            h += Math.sin(x * 0.006) * Math.cos(z * 0.006) * 120;
            h += Math.sin(x * 0.015 + z * 0.01) * 60;
            h += Math.sin(x * 0.1) * 5 + Math.cos(z * 0.1) * 5;
            const bcX = 0, bcZ = 2000;
            const distToBC = Math.sqrt((x - bcX) ** 2 + (z - bcZ) ** 2);
            if (distToBC < 150) {
                const bcH = (2500 - bcZ) * 0.4 + Math.sin(bcX * 0.006) * Math.cos(bcZ * 0.006) * 120 + Math.sin(bcX * 0.015 + bcZ * 0.01) * 60 + (Math.sin(bcX * 0.1) * 5 + Math.cos(bcZ * 0.1) * 5);
                h = bcH;
            }
            return h;
        }

        const baseH = getRawHeight(START_POS_XZ.x, START_POS_XZ.z);
        const peakH = getRawHeight(SUMMIT_POS_XZ.x, SUMMIT_POS_XZ.z);
        const heightScale = (TARGET_ALT - START_ALT) / (peakH - baseH);
        const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, 140, 140);
        geometry.rotateX(-Math.PI / 2);
        const vertices = geometry.attributes.position.array;
        const colors = new Float32Array(vertices.length);
        const colorObj = new THREE.Color();
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i], z = vertices[i + 2];
            let h = getRawHeight(x, z);
            if (z < 1800 && z > -2400) {
                let mazeNoise = Math.sin(x * 0.02) * Math.cos(z * 0.02);
                mazeNoise += Math.sin(x * 0.01 + z * 0.01) * 0.5;
                if (mazeNoise > 0.75) h -= 800;
            }
            vertices[i + 1] = h;
            if (h < -100) {
                colorObj.setRGB(0.1, 0.1, 0.2);
            } else {
                const br = 0.8 + (Math.sin(x * 0.05) * 0.1 + Math.cos(z * 0.05) * 0.1);
                colorObj.setRGB(br, br, br + 0.05);
            }
            colors[i] = colorObj.r; colors[i + 1] = colorObj.g; colors[i + 2] = colorObj.b;
        }
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.computeVertexNormals();
        const terrainMesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ vertexColors: true, shininess: 10, flatShading: true }));
        scene.add(terrainMesh);

        try {
            const tentGeometry = new THREE.ConeGeometry(6, 9, 4);
            const tentPositions = [
                { x: 10, z: 5, c: 0x006400, r: Math.PI / 4 }, { x: -10, z: -5, c: 0x8B0000, r: -Math.PI / 3 },
                { x: 0, z: -15, c: 0x00008B, r: Math.PI / 6 }, { x: 25, z: 15, c: 0x006400, r: -Math.PI / 8 },
                { x: -20, z: 10, c: 0x8B0000, r: Math.PI / 2 }, { x: 5, z: -30, c: 0x00008B, r: -Math.PI / 5 },
            ];
            tentPositions.forEach(p => {
                const mat = new THREE.MeshPhongMaterial({ color: p.c, shininess: 5 });
                const tent = new THREE.Mesh(tentGeometry, mat);
                const groundH = getRawHeight(START_POS_XZ.x + p.x, START_POS_XZ.z + p.z);
                tent.position.set(START_POS_XZ.x + p.x, groundH + 4.5, START_POS_XZ.z + p.z);
                tent.rotation.y = p.r;
                scene.add(tent);
            });
        } catch (e) { }

        try {
            const poleGeometry = new THREE.CylinderGeometry(0.5, 0.5, 30, 8);
            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(SUMMIT_POS_XZ.x, peakH + 15, SUMMIT_POS_XZ.z);
            scene.add(pole);
            const flagGeometry = new THREE.PlaneGeometry(12, 8);
            const flagMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(SUMMIT_POS_XZ.x + 6, peakH + 25, SUMMIT_POS_XZ.z);
            scene.add(flag);
        } catch (e) { }

        const snowCount = 2500;
        const snowGeom = new THREE.BufferGeometry();
        const snowCoords = new Float32Array(snowCount * 3);
        for (let i = 0; i < snowCount * 3; i++) snowCoords[i] = (Math.random() - 0.5) * 120;
        snowGeom.setAttribute('position', new THREE.BufferAttribute(snowCoords, 3));
        const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0 });
        const snowParticles = new THREE.Points(snowGeom, snowMat);
        scene.add(snowParticles);
        scene.add(new THREE.AmbientLight(0xaaaaee, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.3);
        dirLight.position.set(-2000, 4000, -5000); scene.add(dirLight);

        let player = { pos: new THREE.Vector3(START_POS_XZ.x, baseH + 3.0, START_POS_XZ.z), velY: 0, rotY: 0, rotX: 0, isFalling: false };
        const keys = {};

        window.addEventListener('mousemove', (e) => {
            if (!isTouchDevice && document.pointerLockElement) {
                player.rotY -= e.movementX * 0.002;
                player.rotY = (player.rotY + Math.PI) % (2 * Math.PI) - Math.PI;
                player.rotX -= e.movementY * 0.002;
                player.rotX = Math.max(-1.4, Math.min(1.4, player.rotX));
            }
        });
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        const lookArea = document.getElementById('touch-look-area');
        let lookTouchId = null, lastX = 0, lastY = 0;
        lookArea.addEventListener('touchstart', e => { e.preventDefault(); const t = e.changedTouches[0]; lookTouchId = t.identifier; lastX = t.clientX; lastY = t.clientY; }, { passive: false });
        
        const moveArea = document.getElementById('touch-move-area');
        moveArea.addEventListener('touchstart', e => { e.preventDefault(); const t = e.changedTouches[0]; touchMoveId = t.identifier; lastMoveY = t.clientY; }, { passive: false });

        window.addEventListener('touchmove', e => {
            if (lookTouchId !== null) {
                for (let t of e.changedTouches) {
                    if (t.identifier === lookTouchId) {
                        const deltaX = t.clientX - lastX;
                        const deltaY = t.clientY - lastY;
                        player.rotY -= deltaX * TOUCH_SENSITIVITY;
                        player.rotY = (player.rotY + Math.PI) % (2 * Math.PI) - Math.PI;
                        player.rotX -= deltaY * TOUCH_SENSITIVITY;
                        player.rotX = Math.max(-1.4, Math.min(1.4, player.rotX));
                        lastX = t.clientX; lastY = t.clientY;
                    }
                }
            }
            if (touchMoveId !== null) {
                for (let t of e.changedTouches) {
                    if (t.identifier === touchMoveId) {
                        const deltaY = t.clientY - lastMoveY;
                        player.pos.y -= deltaY * 0.5;
                        lastMoveY = t.clientY;
                    }
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            for (let t of e.changedTouches) {
                if (t.identifier === lookTouchId) lookTouchId = null;
                if (t.identifier === touchMoveId) touchMoveId = null;
            }
        });

        const raycaster = new THREE.Raycaster();

        function animate(time) {
            if (isEnded && !isHeliMode) return;
            requestAnimationFrame(animate);

            if (isHeliMode) {
                scene.fog = new THREE.FogExp2(0x77aaff, 0.0001);
                scene.background = new THREE.Color(0x77aaff);
                snowMat.opacity = 0;
                if (windSound.isPlaying) windSound.setVolume(0);
                const speed = 2.5;
                if (keys[' '] || isStepButtonPressed) {
                    const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    player.pos.addScaledVector(fwd, speed);
                }
                if (keys.w) player.pos.y += speed;
                if (keys.s) player.pos.y -= speed;
            } else {
                let weatherCycle = (Math.sin(time * 0.0002) + 1) / 2;
                const isWhiteout = weatherCycle > 0.7;
                document.getElementById('weather-text').innerText = isWhiteout ? "WHITEOUT" : "NORMAL";
                if (gameStartTime > 0 && windSound.isPlaying) windSound.setVolume(0.1 + Math.pow(weatherCycle, 2) * 0.9);
                const fogDensity = 0.0002 + Math.pow(weatherCycle, 3) * 0.045;
                scene.background = new THREE.Color().lerpColors(new THREE.Color(0x77aaff), new THREE.Color(0xcccccc), Math.min(1, weatherCycle * 1.2));
                scene.fog = new THREE.FogExp2(scene.background, fogDensity);

                let isMoving = false;
                const speed = 0.95;
                if (!player.isFalling && gameStartTime > 0) {
                    if (isStepButtonPressed || keys.w) {
                        const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                        fwd.y = 0; fwd.normalize();
                        player.pos.addScaledVector(fwd, speed);
                        isMoving = true;
                    }
                }
                if (gameStartTime > 0) {
                    oxygen -= (isMoving ? O2_LOSS_MOVING : O2_LOSS_NORMAL);
                    if (oxygen <= 0) { oxygen = 0; document.getElementById('vision-overlay').style.opacity = 1; showEnd("登山不能", "酸素が尽きました。"); }
                    document.getElementById('o2-bar').style.width = oxygen + "%";
                    if (oxygen < 30) document.getElementById('vision-overlay').style.opacity = ((Math.sin(time * 0.002) + 1) / 2) * ((30 - oxygen) / 30) * 0.8;
                    else if (!isEnded) document.getElementById('vision-overlay').style.opacity = 0;
                }

                raycaster.set(new THREE.Vector3(player.pos.x, 8000, player.pos.z), new THREE.Vector3(0, -1, 0));
                const hit = raycaster.intersectObject(terrainMesh);
                if (hit.length > 0) {
                    const gY = hit[0].point.y;
                    const isInitialPhase = gameStartTime > 0 && performance.now() - gameStartTime < 500;
                    if (isInitialPhase) {
                        player.pos.y = gY + 3.0;
                        player.velY = 0;
                        player.isFalling = false;
                    } else {
                        if (gameStartTime > 0 && performance.now() - gameStartTime > 2000 && gY < player.pos.y - 45) player.isFalling = true;
                        if (player.isFalling) {
                            player.velY -= 0.8;
                            if (player.pos.y < gY + 3) showEnd("滑落", "クレバスに転落しました。");
                        } else {
                            const targetY = gY + 3.0;
                            if (player.pos.y > targetY) player.velY -= 0.2;
                            else {
                                if (gameStartTime > 0 && performance.now() - gameStartTime > 2000 && player.velY < -22) showEnd("滑落", "急斜面から滑落しました。");
                                player.pos.y = targetY; player.velY = 0;
                            }
                        }
                    }
                }
                player.pos.y += player.velY;

                if (gameState === 'DESCENT' && rescueObject) {
                    const distToRescue = player.pos.distanceTo(rescueObject.position);
                    if (distToRescue < 20) {
                        oxygen = 100;
                        const el = document.getElementById('phase-notice');
                        el.innerHTML = "酸素回復！ベースキャンプを目指せ！";
                        el.style.display = 'block';
                        setTimeout(() => el.style.display = 'none', 3000);
                        scene.remove(rescueObject);
                        rescueObject = null;
                        document.getElementById('rescue-dot').style.display = 'none';
                    }
                }
                document.getElementById('alt-val').innerText = (START_ALT + (player.pos.y - (baseH + 3.0)) * heightScale).toFixed(2);
                const dToS = player.pos.distanceTo(new THREE.Vector3(SUMMIT_POS_XZ.x, peakH, SUMMIT_POS_XZ.z));
                const dToB = player.pos.distanceTo(new THREE.Vector3(START_POS_XZ.x, baseH + 3.0, START_POS_XZ.z));
                if (gameState === 'ASCENT') {
                    document.getElementById('dist-val').innerText = Math.floor(dToS);
                    if (gameStartTime > 0 && dToS < 15) {
                        gameState = 'DESCENT'; document.getElementById('stage-text').innerText = "PHASE: DESCENT";
                        document.getElementById('stage-text').style.color = "#00aaff";
                        const el = document.getElementById('phase-notice'); el.innerHTML = "登頂成功！<br>レスキュー(★)で酸素補給せよ"; el.style.display = 'block'; setTimeout(() => el.style.display = 'none', 5000);
                        const randomX = SUMMIT_POS_XZ.x + (Math.random() - 0.5) * 400;
                        const randomZ = SUMMIT_POS_XZ.z + (Math.random() - 0.5) * 400;
                        raycaster.set(new THREE.Vector3(randomX, 8000, randomZ), new THREE.Vector3(0, -1, 0));
                        const hitRescue = raycaster.intersectObject(terrainMesh);
                        if (hitRescue.length > 0) {
                            const groundY = hitRescue[0].point.y;
                            rescuePos = new THREE.Vector3(randomX, groundY, randomZ);
                            const tentGeometry = new THREE.ConeGeometry(6, 9, 4);
                            const yellowMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 5 });
                            rescueObject = new THREE.Mesh(tentGeometry, yellowMaterial);
                            rescueObject.position.set(rescuePos.x, rescuePos.y + 4.5, rescuePos.z);
                            rescueObject.rotation.y = Math.random() * Math.PI * 2;
                            scene.add(rescueObject);
                            const rescueDot = document.getElementById('rescue-dot');
                            rescueDot.style.display = 'block';
                            rescueDot.style.left = (50 + (rescuePos.x / TERRAIN_SIZE) * 100) + '%';
                            rescueDot.style.top = (50 + (rescuePos.z / TERRAIN_SIZE) * 100) + '%';
                        }
                        const saveData = { playerPos: { x: player.pos.x, y: player.pos.y, z: player.pos.z }, playerRotY: player.rotY, playerRotX: player.rotX, oxygen: 100, gameState: gameState };
                        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(saveData));
                    }
                } else {
                    document.getElementById('dist-val').innerText = Math.floor(dToB);
                    if (dToB < 30) showEnd("完全登頂成功", "エベレスト制覇おめでとう！");
                }
                snowParticles.position.copy(player.pos);
                const pAttr = snowParticles.geometry.attributes.position.array;
                for (let i = 0; i < snowCount; i++) {
                    pAttr[i * 3] += 0.5 + weatherCycle * 4.0; pAttr[i * 3 + 1] -= 0.15;
                    if (pAttr[i * 3] > 60) pAttr[i * 3] = -60; if (pAttr[i * 3 + 1] < -30) pAttr[i * 3 + 1] = 30;
                }
                snowParticles.geometry.attributes.position.needsUpdate = true;
                snowMat.opacity = Math.max(0, (weatherCycle - 0.2) * 0.9);
                const pIcon = document.getElementById('player-icon');
                pIcon.style.left = (50 + (player.pos.x / TERRAIN_SIZE) * 100) + '%'; pIcon.style.top = (50 + (player.pos.z / TERRAIN_SIZE) * 100) + '%';
                pIcon.style.transform = `translate(-50%, -50%) rotate(${-player.rotY * 180 / Math.PI}deg)`;
                document.getElementById('bc-dot').style.left = (50 + (START_POS_XZ.x / TERRAIN_SIZE) * 100) + '%';
                document.getElementById('bc-dot').style.top = (50 + (START_POS_XZ.z / TERRAIN_SIZE) * 100) + '%';
            }
            camera.position.copy(player.pos); camera.rotation.set(player.rotX, player.rotY, 0, 'YXZ');
            renderer.render(scene, camera);
        }

        function resetToPenitentiary() {
            if (!isEnded) return;
            player.pos.set(START_POS_XZ.x, baseH + 3.0, START_POS_XZ.z);
            player.velY = 0;
            player.isFalling = false;
            oxygen = 100;
            document.getElementById('message-screen').style.display = 'none';
            document.getElementById('vision-overlay').style.opacity = 0;
            if (windSound.buffer && !windSound.isPlaying) {
                windSound.play();
            }
            if (!isTouchDevice) {
                renderer.domElement.requestPointerLock();
            }
            isEnded = false;
        }

        function showEnd(t, b) {
            if (isEnded) return; isEnded = true;
            if (windSound.isPlaying) windSound.stop();
            if (document.pointerLockElement) document.exitPointerLock();
            document.getElementById('message-screen').style.display = 'block';
            document.getElementById('msg-title').innerText = t; document.getElementById('msg-body').innerText = b;
            const retryBtn = document.querySelector('.btn-retry');
            if (t !== "完全登頂成功") {
                retryBtn.innerText = "RETRY";
                retryBtn.onclick = resetToPenitentiary;
            } else {
                retryBtn.innerText = "BACK TO TOP";
                retryBtn.onclick = () => location.reload();
            }
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate(0);
    </script>
</body>
</html>
