<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Three.js Drive - Long Haul Mission</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
    /* UI系スタイル */
    #msg { position: absolute; top: 40%; width: 100%; text-align: center; color: #ff3333; font-family: sans-serif; font-size: 40px; font-weight: bold; text-shadow: 2px 2px 0 #000; display: none; pointer-events: none; z-index: 1020; }
    .touch-area { position: absolute; top: 0; width: 50%; height: 100%; z-index: 1000; display: none; }
    .touch-left { left: 0; }
    .touch-right { right: 0; }
    @media (pointer: coarse) { .touch-area { display: block; } }
    #fullscreenButton { position: absolute; top: 15px; left: 15px; font-family: sans-serif; font-size: 24px; color: #fff; background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 8px; cursor: pointer; user-select: none; z-index: 1010; line-height: 1; }
    #zoomSlider { position: absolute; right: -75px; top: 50%; transform: translateY(-50%) rotate(-90deg); width: 200px; height: 10px; -webkit-appearance: none; background: rgba(255, 255, 255, 0.3); outline: none; border-radius: 5px; opacity: 0.7; transition: opacity .2s; z-index: 1010; }
    #zoomSlider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #4CAF50; cursor: pointer; }
    @media (pointer: coarse) { #zoomSlider { display: block; } }
    
    #hud { position: absolute; top: 5px; width: 100%; display: flex; justify-content: flex-start; gap: 40px; color: white; font-family: sans-serif; font-weight: bold; text-shadow: 2px 2px 2px #000; pointer-events: none; z-index: 1010; padding-left: 15px; }
    #mission-info { position: absolute; top: 5px; width: 100%; text-align: right; color: #ffff00; font-family: sans-serif; font-weight: bold; text-shadow: 2px 2px 2px #000; pointer-events: none; z-index: 1010; font-size: 18px; padding-right: 15px; }
</style>
</head>
<body>

<div id="hud">
    <div>PLAYER HP: <span id="p-hp">100</span></div>
    <div>STAGE: <span id="stage-num">1</span></div>
</div>
<div id="mission-info">
    MISSION: <span id="mission-type">PICKUP</span> (Target: <span id="cargo-count">0</span>/<span id="cargo-max">1</span>)
</div>

<div id="msg">MESSAGE</div>
<div class="touch-area touch-left"></div>
<div class="touch-area touch-right"></div>
<div id="fullscreenButton">★</div>
<input type="range" id="zoomSlider" min="0" max="2" step="0.01" value="0.8">
<div id="redFlash" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0; pointer-events: none; z-index: 1030; transition: opacity 0.1s ease-out;"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// --- 物理設定（速度ダウン・調整済み） ---
const MAX_SPEED = 2.5, ACCEL = 0.08, FRICTION = 0.96, GRAVITY = 0.1, MAX_ZOOM_LEVEL = 2.0;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 8000); // 描画距離延長
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

function updateCamera() {
    const width = window.innerWidth, height = window.innerHeight, aspect = width / height;
    renderer.setSize(width, height);
    camera.aspect = aspect;
    const baseFov = 75; 
    if (aspect < 1) camera.fov = (2 * Math.atan(Math.tan((baseFov * Math.PI / 180) / 2) / aspect)) * 180 / Math.PI;
    else camera.fov = baseFov;
    camera.updateProjectionMatrix();
}
window.addEventListener('resize', updateCamera);
updateCamera();

scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const sun = new THREE.DirectionalLight(0xffffff, 1.5);
sun.position.set(100, 150, 100); sun.castShadow = true;
sun.shadow.camera.left = -100; sun.shadow.camera.right = 100;
sun.shadow.camera.top = 100; sun.shadow.camera.bottom = -100;
sun.shadow.mapSize.set(2048, 2048); scene.add(sun);

const mirrorCamera = new THREE.PerspectiveCamera(40, 3.0, 0.1, 500);
const mirrorRenderTarget = new THREE.WebGLRenderTarget(256, 85);
const mirrorMaterial = new THREE.MeshBasicMaterial({ map: mirrorRenderTarget.texture });
const mirrorMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.25, 0.08), mirrorMaterial);
scene.add(mirrorMesh);

function getHeight(x, z) {
    return Math.sin(x * 0.04) * 5 + Math.cos(z * 0.03) * 7 + Math.sin((x + z) * 0.02) * 4;
}

const chunks = new Map();
function updateChunks(px, pz) {
    const cx = Math.floor(px/400), cz = Math.floor(pz/400);
    for(let x=cx-1; x<=cx+1; x++) {
        for(let z=cz-1; z<=cz+1; z++) {
            const key = `${x},${z}`;
            if(!chunks.has(key)) {
                const geo = new THREE.PlaneGeometry(400, 400, 40, 40); geo.rotateX(-Math.PI/2);
                const pos = geo.attributes.position;
                for(let i=0; i<pos.count; i++) pos.setY(i, getHeight(pos.getX(i)+x*400, pos.getZ(i)+z*400));
                geo.computeVertexNormals();
                const m = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x998877, roughness: 0.8, metalness: 0.2 }));
                m.position.set(x*400, 0, z*400); m.receiveShadow = true;
                scene.add(m); chunks.set(key, m);
            }
        }
    }
}

const particles = [];
function spawnDust(pos, isSpark = false, isSmoke = false) {
    let color = isSpark ? 0xffffff : 0xd2c08a; if (isSmoke) color = 0x333333;
    const p = new THREE.Mesh(new THREE.SphereGeometry(isSpark?0.2:(isSmoke?0.6:0.4), 4, 4), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.6 }));
    p.position.copy(pos);
    const vel = isSmoke ? new THREE.Vector3((Math.random()-0.5)*0.2, 0.2+Math.random()*0.2, (Math.random()-0.5)*0.2) : new THREE.Vector3((Math.random()-0.5)*0.3, Math.random()*0.5 + 0.2, (Math.random()-0.5)*0.3);
    p.userData = { life: 1.0, vel: vel, type: isSmoke ? 'smoke' : 'dust' };
    scene.add(p); particles.push(p);
}

function spawnDebris(pos, color, scale, count = 5) {
    const geo = new THREE.BoxGeometry(scale, scale, scale);
    const mat = new THREE.MeshStandardMaterial({ color });
    for(let i=0; i<count; i++) {
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*2, (Math.random())*2, (Math.random()-0.5)*2));
        p.userData = { life: 1.0+Math.random(), vel: new THREE.Vector3((Math.random()-0.5)*1.5, Math.random()*0.8+0.5, (Math.random()-0.5)*1.5), rot: new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5), type: 'debris' };
        scene.add(p); particles.push(p);
    }
}

function createCar(color) {
    const group = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.3 });
    const glassMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1, metalness: 0.8, transparent: true, opacity: 0.85 });
    const baseBody = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.7, 4.6), bodyMat);
    baseBody.position.y = 0.85; baseBody.castShadow = true; baseBody.receiveShadow = true;
    group.add(baseBody);
    const cabin = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.6, 0.75, 4).rotateY(Math.PI/4), [glassMat, bodyMat, bodyMat]);
    cabin.scale.set(1.0, 1.0, 1.3); cabin.position.set(0, 1.55, 0.25); cabin.castShadow = true; group.add(cabin);
    const lightGeo = new THREE.BoxGeometry(0.6, 0.2, 0.1);
    const headL = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
    headL.position.set(0.8, 0.9, -2.3); group.add(headL);
    const headR = headL.clone(); headR.position.x = -0.8; group.add(headR);
    const tailL = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
    tailL.position.set(0.8, 0.9, 2.3); group.add(tailL);
    const tailR = tailL.clone(); tailR.position.x = -0.8; group.add(tailR);
    const wheels = [];
    [[1.35,0.6,-1.6],[-1.35,0.6,-1.6],[1.35,0.6,1.6],[-1.35,0.6,1.6]].forEach(off => {
        const wheelGroup = new THREE.Group();
        wheelGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,0.5,16).rotateZ(Math.PI/2), new THREE.MeshStandardMaterial({ color: 0x111111 })));
        wheelGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.55,8).rotateZ(Math.PI/2), new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })));
        wheelGroup.position.set(...off); wheelGroup.castShadow = true; group.add(wheelGroup); wheels.push(wheelGroup);
    });
    return { group, wheels, bodyMat, color, hp: 100, dead: false };
}

// --- プレイヤー作成 ---
const player = { ...createCar(0xcc2222), speed: 0, lastSpeed: 0, vY: 0, yaw: 0, pitch: 0, roll: 0, impactV: new THREE.Vector3() };
scene.add(player.group);

// --- 敵AI管理システム ---
let enemies = [];
const enemyColors = [0x00cc00, 0xcccc00, 0xcc22cc, 0xeeeeee, 0x2244cc, 0xcc5500];

function spawnEnemyAt(x, z) {
    const col = enemyColors[Math.floor(Math.random() * enemyColors.length)];
    const aiTypes = ['chaser', 'evasive', 'flanker']; // Define AI types
    const assignedType = aiTypes[Math.floor(Math.random() * aiTypes.length)]; // Randomly assign one
    const ent = { 
        ...createCar(col), 
        speed: 0, lastSpeed: 0, yaw: Math.random()*Math.PI*2, pitch: 0, roll: 0, 
        attackTimer: 0, mode: 'follow', impactV: new THREE.Vector3(),
        aiType: assignedType // Assign AI type
    };
    ent.group.position.set(x, 10, z);
    scene.add(ent.group);
    enemies.push(ent);
}

function updateEnemiesCount(count) {
    enemies.forEach(e => scene.remove(e.group));
    enemies = [];
    for(let i=0; i<count; i++) {
        const angle = player.yaw + Math.PI + (Math.random()-0.5);
        const dist = 40 + Math.random() * 20;
        const ex = player.group.position.x + Math.sin(angle) * dist;
        const ez = player.group.position.z + Math.cos(angle) * dist;
        spawnEnemyAt(ex, ez);
    }
}

// --- ゲーム進行・ミッションロジック ---
let currentStage = 1;
let currentCargo = 0;
let maxCargo = 1;
let missionState = 'pickup';
let stageEnemyCount = 0;

// ビーコン（光の柱）：巨大化
const beaconGeo = new THREE.CylinderGeometry(40, 40, 5000, 32); // 半径を15から40に太くする
const beaconRedMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
const beaconGreenMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });

const beaconMesh = new THREE.Mesh(beaconGeo, beaconRedMat);
// 初期位置は仮
beaconMesh.position.y = 2500;
scene.add(beaconMesh);

let targetPos = new THREE.Vector3();

function setNextObjective(type) {
    missionState = type;
    
    // 距離を10倍に修正 (3000〜6000の距離)
    const angle = Math.random() * Math.PI * 2;
    const dist = 3000 + Math.random() * 3000;
    
    targetPos.set(
        player.group.position.x + Math.sin(angle) * dist,
        0,
        player.group.position.z + Math.cos(angle) * dist
    );

    if (type === 'pickup') {
        beaconMesh.material = beaconRedMat;
        document.getElementById('mission-type').innerText = "PICKUP (RED BEAM)";
        document.getElementById('mission-type').style.color = "#ff3333";
    } else {
        beaconMesh.material = beaconGreenMat;
        document.getElementById('mission-type').innerText = "DELIVER (GREEN BEAM)";
        document.getElementById('mission-type').style.color = "#33ff33";
    }
    
    document.getElementById('cargo-count').innerText = currentCargo;
    document.getElementById('cargo-max').innerText = maxCargo;
    document.getElementById('stage-num').innerText = currentStage;
}

function initStage(stage) {
    currentStage = stage;
    currentCargo = 0;
    
    if (stage === 1) {
        maxCargo = 1;
        stageEnemyCount = 1;
        updateEnemiesCount(stageEnemyCount);
    } else if (stage === 2) {
        maxCargo = 2;
        stageEnemyCount = 1;
        updateEnemiesCount(stageEnemyCount);
    } else if (stage === 3) {
        maxCargo = 3;
        stageEnemyCount = 2;
        updateEnemiesCount(stageEnemyCount);
    } else {
        maxCargo = 3;
        stageEnemyCount = 3;
        updateEnemiesCount(stageEnemyCount);
    }
    
    setNextObjective('pickup');
    showMsg("STAGE " + stage + " START");
}

function showMsg(text, duration = 3000) {
    const m = document.getElementById('msg');
    m.innerText = text; m.style.display = 'block';
    setTimeout(() => { m.style.display = 'none'; }, duration);
}

// ゲーム開始時の初期化
initStage(1);

function playSFX(filename) {
    if (!audioCtx) initAudio(); // Ensure audio context is initialized
    if (!audioCtx) return; // If initialization failed, don't proceed

    const source = audioCtx.createBufferSource();
    fetch(filename)
        .then(response => response.arrayBuffer())
        .then(buffer => audioCtx.decodeAudioData(buffer))
        .then(decodedBuffer => {
            source.buffer = decodedBuffer;
            source.connect(audioCtx.destination);
            source.start(0);
        })
        .catch(e => console.error("Error playing sound:", e));
}

function flashRedScreen() {
    const flashDiv = document.getElementById('redFlash');
    if (flashDiv) {
        flashDiv.style.opacity = '0.6'; // Make it visible
        setTimeout(() => {
            flashDiv.style.opacity = '0'; // Fade out
        }, 100); // Flash for 100ms
    }
}

// --- 入力・システム系 ---
let audioCtx, pOsc, pGain;
function initAudio() { if (audioCtx) return; try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return; } pOsc = audioCtx.createOscillator(); pOsc.type = 'sawtooth'; pGain = audioCtx.createGain(); pGain.gain.value = 0; pOsc.connect(pGain).connect(audioCtx.destination); pOsc.start(); }

const keys = {};
window.addEventListener("keydown", e => { keys[e.code] = true; initAudio(); if(audioCtx) audioCtx.resume(); });
window.addEventListener("keyup", e => { keys[e.code] = false; });

let lookYaw = 0, lookPitch = 0, zoomLevel = 0.8, smoothedCamPos = new THREE.Vector3();
let touchLeftId = -1, touchRightId = -1, touchState = { left: { startX: 0, startY: 0, currentX: 0, currentY: 0 }, right: { startX: 0, startY: 0, currentX: 0, currentY: 0 } };

addEventListener("wheel", e => { zoomLevel = Math.max(0, Math.min(MAX_ZOOM_LEVEL, zoomLevel + e.deltaY*0.001)); }, {passive:true});
renderer.domElement.addEventListener("mousedown", () => { renderer.domElement.requestPointerLock(); initAudio(); if(audioCtx) audioCtx.resume(); });
document.addEventListener("mousemove", e => { if (document.pointerLockElement === renderer.domElement) { lookYaw -= e.movementX * 0.003; lookPitch = Math.max(-0.6, Math.min(0.6, lookPitch - e.movementY * 0.003)); } });
document.getElementById('zoomSlider').addEventListener('input', e => { zoomLevel = parseFloat(e.target.value); });

window.addEventListener('touchstart', e => {
    initAudio(); if(audioCtx) audioCtx.resume();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.clientX < window.innerWidth / 2) { touchLeftId = t.identifier; touchState.left = { startX: t.clientX, startY: t.clientY, currentX: t.clientX, currentY: t.clientY }; }
        else { touchRightId = t.identifier; touchState.right = { startX: t.clientX, startY: t.clientY, currentX: t.clientX, currentY: t.clientY }; }
    }
}, {passive: false});

window.addEventListener('touchmove', e => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === touchLeftId) { touchState.left.currentX = t.clientX; touchState.left.currentY = t.clientY; }
        else if (t.identifier === touchRightId) { lookYaw -= (t.clientX - touchState.right.currentX) * 0.005; lookPitch = THREE.MathUtils.clamp(lookPitch - (t.clientY - touchState.right.currentY) * 0.005, -0.6, 0.6); touchState.right.currentX = t.clientX; touchState.right.currentY = t.clientY; }
    }
}, {passive: false});

// ③フルスクリーンボタンの有効化
document.getElementById('fullscreenButton').addEventListener('click', () => {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => console.warn(err));
    else document.exitFullscreen();
});

window.addEventListener('touchend', e => {
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === touchLeftId) { touchLeftId = -1; keys.KeyW = keys.KeyS = keys.KeyA = keys.KeyD = false; }
        else if (t.identifier === touchRightId) touchRightId = -1;
    }
}, {passive: false});

function animate() {
    requestAnimationFrame(animate);
    const now = audioCtx ? audioCtx.currentTime : 0;
    
    // --- ビーコン更新：巨大化対応でY座標調整 ---
    const hT = getHeight(targetPos.x, targetPos.z);
    beaconMesh.position.set(targetPos.x, hT + 2495, targetPos.z); // 少し地面に埋める
    
    // 距離判定（ビーコンの半径+αで緩めに）
    const distToTarget = Math.sqrt((player.group.position.x - targetPos.x)**2 + (player.group.position.z - targetPos.z)**2);
    if (distToTarget < 30) {
        if (missionState === 'pickup') {
            showMsg("CARGO PICKED UP!");
            player.hp = 100; // Player HP restored at pickup point
            document.getElementById('p-hp').innerText = 100;
            setNextObjective('deliver');
        } else {
            currentCargo++;
            player.hp = 100;
            document.getElementById('p-hp').innerText = 100;
            
            if (currentCargo >= maxCargo) {
                showMsg("STAGE CLEARED!");
                // ステージ番号バグ修正：より安全な整数変換で確実に加算
                setTimeout(() => {
                    let nextStage = parseInt(currentStage, 10);
                    nextStage = nextStage + 1;
                    initStage(nextStage);
                }, 2000);
                // 連鎖的なステージ進行を防ぐため、ターゲットビーコンを即座に遠くへ移動させる
                targetPos.set(999999, 999999, 999999); // ターゲットを遠くへ移動
            } else {
                showMsg("DELIVERED! NEXT CARGO...");
                setTimeout(() => { setNextObjective('pickup'); }, 1500);
            }
        }
    }

    updateChunks(player.group.position.x, player.group.position.z);
    sun.position.set(player.group.position.x + 50, 150, player.group.position.z + 50); sun.target = player.group;

    for(let i = particles.length - 1; i >= 0; i--){
        const p = particles[i]; p.userData.life -= 0.015; p.position.add(p.userData.vel);
        if (p.userData.type === 'debris') {
            p.rotation.x += p.userData.rot.x; p.userData.vel.y -= 0.02;
            const h = getHeight(p.position.x, p.position.z);
            if(p.position.y < h) { p.position.y = h; p.userData.vel.y *= -0.5; }
            p.scale.setScalar(p.userData.life * 0.5);
        } else {
            p.scale.setScalar(p.userData.type === 'smoke' ? (1 + (1.0 - p.userData.life) * 3) : (1 + (1.0 - p.userData.life) * 4)); 
            p.material.opacity = p.userData.life * 0.6;
        }
        if(p.userData.life <= 0){ scene.remove(p); particles.splice(i, 1); }
    }

    const entities = [player, ...enemies]; 

    // ★AIが規定数に満たない場合に即座にリスポーンさせる
    if (enemies.length < stageEnemyCount) {
        const spawnAngle = player.yaw + Math.PI + (Math.random() - 0.5) * 1.5;
        const spawnDist = 100 + Math.random() * 50;
        const ex = player.group.position.x + Math.sin(spawnAngle) * spawnDist;
        const ez = player.group.position.z + Math.cos(spawnAngle) * spawnDist;
        spawnEnemyAt(ex, ez);
    }

    entities.forEach(ent => {
        const isP = (ent === player);
        if (!isP && ent.dead) return; 

        if (ent.dead) { ent.speed *= 0.95; if (Math.random() > 0.8) spawnDust(ent.group.position.clone().add(new THREE.Vector3(0,1,0)), false, true); }
        else if (ent.hp <= 30 && Math.random() > 0.9) spawnDust(ent.group.position.clone().add(new THREE.Vector3(0,1,0)), false, true);

        ent.lastSpeed = ent.speed;
        let turnInput = 0;
        
        if(isP && !ent.dead) {
            if(keys.KeyW) ent.speed += ACCEL; if(keys.KeyS) ent.speed -= ACCEL;
            if(keys.KeyA) { ent.yaw += 0.05; turnInput = 1; } if(keys.KeyD) { ent.yaw -= 0.05; turnInput = -1; }
            if (touchLeftId !== -1) {
                const dy = touchState.left.currentY - touchState.left.startY, dx = touchState.left.currentX - touchState.left.startX;
                if (dy < -20) ent.speed += ACCEL; else if (dy > 20) ent.speed -= ACCEL;
                if (dx < -20) { ent.yaw += 0.05; turnInput = 1; } else if (dx > 20) { ent.yaw -= 0.05; turnInput = -1; }
            }
            ent.speed *= FRICTION;
        } else if (!isP && !ent.dead) {
            // AI separation logic (Request ①)
            const separationForce = new THREE.Vector3();
            for (let i = 0; i < enemies.length; i++) {
                const otherEnt = enemies[i];
                if (ent === otherEnt || otherEnt.dead) continue; // Don't compare with self or dead enemies

                const distance = ent.group.position.distanceTo(otherEnt.group.position);
                const separationRadius = 8; // Adjust based on car size
                const maxRepelForce = 0.1; // Max force to prevent jitter

                if (distance < separationRadius && distance > 0.001) { // Prevent division by zero / very small distance
                    const repelVector = new THREE.Vector3().subVectors(ent.group.position, otherEnt.group.position).normalize();
                    const repelStrength = Math.min(maxRepelForce, (separationRadius - distance) / separationRadius);
                    separationForce.add(repelVector.multiplyScalar(repelStrength));
                }
            }
            ent.group.position.add(separationForce.multiplyScalar(0.2)); // Apply separation force (scaled down)

            // Original AI movement logic
            const toPlayer = new THREE.Vector3().subVectors(player.group.position, ent.group.position);
            const dist = toPlayer.length();
            ent.attackTimer += 0.01;
            
            // Initialize tYaw and tSpeed with default values (e.g., chaser behavior)
            let tYaw = Math.atan2(toPlayer.x, toPlayer.z) + Math.PI; 
            let tSpeed = Math.max(1.0, Math.abs(player.speed) + 0.6); 
            if (dist < 10) tSpeed *= 0.8;

            switch (ent.aiType) {
                case 'chaser':
                    tSpeed = Math.max(1.2, Math.abs(player.speed) + 0.8); // Slightly more aggressive speed
                    if (dist < 10) tSpeed *= 0.8; // Slow down if too close
                    break;
                case 'evasive':
                    const desiredDistEvasive = 40;
                    let targetAngle = Math.atan2(toPlayer.x, toPlayer.z) + Math.PI; // Always have player as a general target
                    if (dist < desiredDistEvasive - 10) { // Too close, move away
                        // Evade by moving slightly away and to the side
                        tYaw = targetAngle + (Math.random() > 0.5 ? Math.PI / 3 : -Math.PI / 3); // Point away and to side
                        tSpeed = Math.max(1.0, Math.abs(player.speed) + 0.6); // Slightly faster to create distance
                    } else if (dist > desiredDistEvasive + 10) { // Too far, move towards
                        tYaw = targetAngle; // Point directly at player
                        tSpeed = Math.max(1.1, Math.abs(player.speed) + 0.7); // Faster to close gap
                    } else { // Ideal distance, circle
                        const perpendicularAngle = Math.atan2(toPlayer.z, toPlayer.x) + (Math.random() > 0.5 ? Math.PI / 2 : -Math.PI / 2);
                        tYaw = targetAngle + (Math.random() > 0.5 ? Math.PI / 6 : -Math.PI / 6); // Small deviation to orbit
                        tSpeed = Math.max(0.8, Math.abs(player.speed) + 0.4); // Maintain moderate speed
                    }
                    break;
                case 'flanker':
                    const flankAngleOffset = (Math.random() > 0.5 ? Math.PI / 2 : -Math.PI / 2) * 0.5; // +/- 45 degrees
                    tYaw = Math.atan2(toPlayer.x, toPlayer.z) + Math.PI + flankAngleOffset;
                    tSpeed = Math.max(1.0, Math.abs(player.speed) + 0.6); // Standard speed
                    if (dist < 15) tSpeed *= 0.7; // Slow down if too close
                    break;
                // No default needed now as tYaw and tSpeed are initialized
            }
            
            ent.speed = THREE.MathUtils.lerp(ent.speed, tSpeed, 0.02);
            let dy = tYaw - ent.yaw;
            while(dy < -Math.PI) dy += Math.PI*2; while(dy > Math.PI) dy -= Math.PI*2;
            const step = dy * 0.025; 
            ent.yaw += step;
            turnInput = THREE.MathUtils.clamp(step * 20, -1, 1);
        }

        const forwardVec = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), ent.yaw);
        ent.group.position.addScaledVector(forwardVec, ent.speed);
        ent.group.position.add(ent.impactV); ent.impactV.multiplyScalar(0.9);

        const fD = 2.3, sD = 1.25; 
        const rightVec = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), ent.yaw);
        
        const hF = getHeight(ent.group.position.x + forwardVec.x * fD, ent.group.position.z + forwardVec.z * fD);
        const hB = getHeight(ent.group.position.x - forwardVec.x * fD, ent.group.position.z - forwardVec.z * fD);
        const hR = getHeight(ent.group.position.x + rightVec.x * sD, ent.group.position.z + rightVec.z * sD);
        const hL = getHeight(ent.group.position.x - rightVec.x * sD, ent.group.position.z - rightVec.z * sD);

        const avgY = (hF + hB + hR + hL) / 4 + 0.22;
        if(isP) { 
            ent.vY -= GRAVITY; 
            ent.group.position.y += ent.vY; 
            if(ent.group.position.y <= avgY) { 
                ent.group.position.y = avgY; 
                ent.vY = 0; 
            } 
        } else { 
            ent.group.position.y = avgY; 
        }

        const terrainPitch = Math.atan2(hF - hB, fD * 2);
        const terrainRoll = Math.atan2(hR - hL, sD * 2);
        const accelPitch = (ent.speed - ent.lastSpeed) * 1.8;
        const centrifugalRoll = -turnInput * Math.abs(ent.speed) * 0.06;

        ent.pitch = THREE.MathUtils.lerp(ent.pitch, terrainPitch + accelPitch, 0.12);
        ent.roll = THREE.MathUtils.lerp(ent.roll, terrainRoll + centrifugalRoll, 0.08);

        ent.group.quaternion.setFromEuler(new THREE.Euler(ent.pitch, ent.yaw, ent.roll, 'YXZ'));

        if(!ent.dead && Math.abs(ent.speed) > 0.5 && ent.group.position.y <= avgY + 0.5) {
            [[-1.2,0,-1.5], [1.2,0,-1.5]].forEach(off => {
                const wPos = new THREE.Vector3(...off).applyQuaternion(ent.group.quaternion).add(ent.group.position);
                if(Math.random() > 0.6) spawnDust(wPos);
            });
        }
    });

    if (!player.dead) {
        enemies.forEach((enemy, idx) => {
            if(enemy.dead) return;
            const dist = player.group.position.distanceTo(enemy.group.position);
            if (dist < 3.8) {
                const dirP2E = new THREE.Vector3().subVectors(enemy.group.position, player.group.position).normalize();
                const pForward = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
                
                if (pForward.dot(dirP2E) > 0.3) {
                    enemy.hp -= 20; 
                    enemy.impactV.add(dirP2E.clone().multiplyScalar(1.5)); 
                    playSFX('crs.mp3'); // Player deals damage
                    // Intense sparks
                    for (let i = 0; i < 5; i++) {
                        spawnDust(enemy.group.position, true); 
                    }

                    if(enemy.hp <= 0) {
                        enemy.dead = true;
                        enemy.bodyMat.color.set(0x000000);
                        spawnDebris(enemy.group.position, 0x000000, 0.8, 30);
                        spawnDebris(enemy.group.position, 0xffaa00, 1.5, 15);
                        playSFX('crash.mp3'); // AI car destroyed
                        setTimeout(() => { scene.remove(enemy.group); enemies.splice(idx, 1); }, 2000);
                    }
                } else {
                    player.hp -= 5; 
                    player.impactV.add(dirP2E.clone().multiplyScalar(-0.8)); 
                    spawnDust(player.group.position, false);
                    playSFX('crs.mp3'); // Player takes damage
                    flashRedScreen(); // Flash screen red
                }
                document.getElementById('p-hp').innerText = Math.max(0, player.hp);
                
                if (player.hp <= 0) { 
                    player.dead = true; 
                    document.getElementById('msg').innerText = "GAME OVER"; 
                    document.getElementById('msg').style.display = 'block'; 
                    playSFX('crash.mp3'); // Player destroyed
                    setTimeout(() => location.reload(), 5000); 
                }
            }
        });
    }

    const cockpitPos = new THREE.Vector3(0, 2.4, 0.5), tpsPos = new THREE.Vector3(0, 4.5, 12), dronePos = new THREE.Vector3(0, 70, 150);
    let currentOffset;
    if (zoomLevel <= 1.0) currentOffset = new THREE.Vector3().lerpVectors(cockpitPos, tpsPos, zoomLevel);
    else currentOffset = new THREE.Vector3().lerpVectors(tpsPos, dronePos, Math.min(1.0, (zoomLevel - 1.0) / (MAX_ZOOM_LEVEL - 1.0)));

    const baseQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, player.yaw, 0));
    const mouseQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(lookPitch, lookYaw, 0, 'YXZ'));
    let finalQuat;
    if (zoomLevel <= 1.0) finalQuat = new THREE.Quaternion().slerpQuaternions(player.group.quaternion.clone(), baseQuat, zoomLevel).multiply(mouseQuat);
    else {
        const cameraPosForLookAt = player.group.position.clone().add(currentOffset.clone().applyQuaternion(baseQuat));
        const tempCam = new THREE.Camera(); tempCam.position.copy(cameraPosForLookAt); tempCam.lookAt(player.group.position);
        finalQuat = tempCam.quaternion.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, lookYaw, 0)));
    }
    const targetCamPos = player.group.position.clone().add(currentOffset.clone().applyQuaternion(finalQuat));
    smoothedCamPos.lerp(targetCamPos, zoomLevel < 0.15 ? 1.0 : (zoomLevel < 1.0 ? 0.2 : 0.3));
    camera.position.copy(smoothedCamPos); camera.quaternion.copy(finalQuat);

    if (zoomLevel < 0.15) {
        mirrorMesh.visible = true; mirrorMesh.position.copy(camera.position).add(new THREE.Vector3(0, 0.2, -0.4).applyQuaternion(camera.quaternion));
        mirrorMesh.quaternion.copy(camera.quaternion);
        mirrorCamera.position.copy(player.group.position).add(new THREE.Vector3(0, 2.6, 0).applyQuaternion(player.group.quaternion));
        mirrorCamera.quaternion.setFromEuler(new THREE.Euler(0, player.yaw + Math.PI, 0));
        renderer.setRenderTarget(mirrorRenderTarget); renderer.render(scene, mirrorCamera); renderer.setRenderTarget(null);
    } else mirrorMesh.visible = false;

    if(audioCtx && !player.dead) { pGain.gain.setTargetAtTime(0.3, now, 0.05); pOsc.frequency.setTargetAtTime(70 + Math.abs(player.speed) * 60, now, 0.05); }
    else if(pGain) pGain.gain.setTargetAtTime(0, now, 0.05);
    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
