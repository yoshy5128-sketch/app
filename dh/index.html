<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Three.js Drive - Mission & Battle</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
    /* UI系スタイル */
    #msg { position: absolute; top: 40%; width: 100%; text-align: center; color: #ff3333; font-family: sans-serif; font-size: 40px; font-weight: bold; text-shadow: 2px 2px 0 #000; display: none; pointer-events: none; z-index: 1020; }
    .touch-area { position: absolute; top: 0; width: 50%; height: 100%; z-index: 1000; display: none; }
    .touch-left { left: 0; }
    .touch-right { right: 0; }
    @media (pointer: coarse) { .touch-area { display: block; } }
    #fullscreenButton { position: absolute; top: 15px; left: 15px; font-family: sans-serif; font-size: 24px; color: #fff; background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 8px; cursor: pointer; user-select: none; z-index: 1010; line-height: 1; display: none; }
    #zoomSlider { position: absolute; right: -75px; top: 50%; transform: translateY(-50%) rotate(-90deg); width: 200px; height: 10px; -webkit-appearance: none; background: rgba(255, 255, 255, 0.3); outline: none; border-radius: 5px; opacity: 0.7; transition: opacity .2s; z-index: 1010; display: none; }
    #zoomSlider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #4CAF50; cursor: pointer; }
    
    #hud { position: absolute; top: 5px; width: 100%; display: flex; justify-content: flex-start; gap: 30px; color: white; font-family: sans-serif; font-weight: bold; text-shadow: 2px 2px 2px #000; pointer-events: none; z-index: 1010; padding-left: 15px; display: none; }
    #mission-info { position: absolute; top: 5px; width: 100%; text-align: right; color: #ffff00; font-family: sans-serif; font-weight: bold; text-shadow: 2px 2px 2px #000; pointer-events: none; z-index: 1010; font-size: 18px; padding-right: 15px; display: none; }

    #result-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.85); display: none;
        flex-direction: column; justify-content: center; align-items: center;
        color: white; font-family: sans-serif; z-index: 2000;
    }
    #result-title { font-size: 50px; color: #ffff00; margin-bottom: 20px; text-shadow: 0 0 10px orange; }
    #mission-bonus { font-size: 36px; color: #00ffff; margin-bottom: 10px; text-shadow: 0 0 5px cyan; }
    #result-bonus { font-size: 30px; margin-bottom: 20px; color: #00ff00; }
    #result-total { font-size: 32px; margin-bottom: 40px; color: #ffffff; border-top: 2px solid #555; padding-top: 10px; }
    
    .result-btns { display: flex; gap: 15px; }
    #next-btn, .replay-btn, .post-btn {
        padding: 15px 30px; font-size: 20px; color: white;
        border: 2px solid #fff; border-radius: 10px; cursor: pointer;
        font-weight: bold; text-shadow: 1px 1px 0 #000;
    }
    #next-btn { background: #00cc00; }
    .replay-btn { background: #0088ff; }
    #save-replay-btn { background: #ff8800; }
    
    .money-text { color: #88ff88; }

    #top-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: url('top.png') no-repeat center center;
        background-size: cover; background-color: #333;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 3000;
    }
    .top-title {
        font-family: sans-serif; font-size: 60px; color: #fff; 
        text-shadow: 4px 4px 0 #000, -1px -1px 0 #000; margin-bottom: 20px; font-weight: 900;
    }

    #debug-stage-select {
        margin-bottom: 20px; color: white; font-family: sans-serif; font-size: 20px;
        background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px;
    }
    #debug-stage-select select { font-size: 18px; padding: 5px; cursor: pointer; }

    .top-btns { display: flex; flex-direction: column; gap: 15px; align-items: center; }
    .btn-large {
        padding: 20px 60px; font-size: 30px; background: #ff4400; color: white;
        border: 3px solid #fff; border-radius: 15px; cursor: pointer;
        font-weight: bold; font-family: sans-serif; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        transition: transform 0.1s;
    }
    .btn-sub {
        padding: 10px 40px; font-size: 20px; background: #444; color: white;
        border: 2px solid #fff; border-radius: 10px; cursor: pointer;
    }
    
    #gear-btn {
        position: absolute; top: 20px; right: 20px;
        font-size: 40px; color: #fff; cursor: pointer;
        text-shadow: 2px 2px 5px #000; user-select: none;
        transition: transform 0.3s;
    }

    #settings-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.9); display: none;
        flex-direction: column; justify-content: center; align-items: center;
        z-index: 3100; font-family: sans-serif; color: #fff;
    }
    .settings-title { font-size: 40px; margin-bottom: 40px; border-bottom: 2px solid #555; padding-bottom: 10px; width: 80%; text-align: center; }
    .setting-item { margin-bottom: 30px; width: 300px; display: flex; justify-content: space-between; align-items: center; font-size: 24px; }
    input[type=range] { width: 150px; cursor: pointer; }
    #settings-close {
        margin-top: 40px; padding: 10px 30px; font-size: 20px;
        background: #555; color: #fff; border: 1px solid #aaa; border-radius: 5px; cursor: pointer;
    }

    #replay-ui {
        position: absolute; top: 15px; right: 15px; width: auto; text-align: right;
        z-index: 4000; display: none; font-family: sans-serif; pointer-events: none;
    }
    #replay-info { color: #00ccff; font-size: 16px; font-weight: bold; text-shadow: 1px 1px 2px #000; margin-bottom: 5px; }
    #exit-replay-btn {
        pointer-events: auto; padding: 5px 15px; font-size: 14px; background: #ff3333; color: white;
        border: 1px solid #fff; border-radius: 5px; cursor: pointer;
    }

    #post-replay-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.8); display: none;
        flex-direction: column; justify-content: center; align-items: center;
        color: white; font-family: sans-serif; z-index: 4100;
    }
    #post-replay-title { font-size: 40px; color: #00ccff; margin-bottom: 30px; font-weight: bold; }

    #garage-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.95); display: none;
        flex-direction: column; justify-content: center; align-items: center;
        z-index: 3500; font-family: sans-serif; color: #fff;
    }
    .garage-slot {
        margin-bottom: 15px; width: 420px; padding: 15px; background: #222;
        border: 1px solid #444; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;
    }
    .garage-slot span { font-weight: bold; font-size: 18px; }
    .load-json-btn { background: #ff9900; border: none; color: #000; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; }

    #noise-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 1035; opacity: 0;
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAV7uOTAAAABlBMVEUAAAD///+l2Z/dAAAAnUlEQVQoz9XQMQ7EIAxEUb9S7n/mSKEUKXInS9ZfGZ9mNo6XzOfz+Xw+n8/n8/l8Pp/P5/P5fD6fz+fz+Xw+n8/n8/l8Pp/P5/P5fD6fz+fz+Xw+n8/n8/l8Pp/P5/P5fD6fz+fz+Xw+n8/n8/l8Pp/P5/P5fD6fz+fz+Xw+n8/n8/l8Pp/P5/P5fD6fz+fz+Xw+nz/I5wdpAwGfALp9XAAAAABJRU5ErkJggg==");
        background-size: 200px 200px;
    }

</style>
</head>
<body>

<div id="hud">
    <div>HP: <span id="p-hp">100</span></div>
    <div class="money-text">$<span id="p-money">0</span></div>
    <div>STAGE: <span id="stage-num">1</span></div>
</div>
<div id="mission-info">
    MISSION: <span id="mission-type">PICKUP</span> (Target: <span id="cargo-count">0</span>/<span id="cargo-max">1</span>)
</div>

<div id="msg">MESSAGE</div>
<div id="noise-overlay"></div>

<div id="replay-ui">
    <div id="replay-info">REPLAY MODE</div>
    <div id="exit-replay-btn">EXIT</div>
</div>

<div id="post-replay-screen">
    <div id="post-replay-title">REPLAY FINISHED</div>
    <div class="result-btns">
        <div class="post-btn replay-btn" id="post-replay-restart">RESTART</div>
        <div class="post-btn replay-btn" style="background:#ff8800;" id="post-replay-save">SAVE</div>
        <div class="post-btn" style="background:#444;" id="post-replay-exit">BACK</div>
    </div>
</div>

<div id="garage-screen">
    <div class="settings-title">CAR GARAGE</div>
    <div class="garage-slot"><span>PLAYER CAR</span><button class="load-json-btn" onclick="openCarLoader('player')">LOAD JSON</button></div>
    <div class="garage-slot"><span>ENEMY 1</span><button class="load-json-btn" onclick="openCarLoader('enemy1')">LOAD JSON</button></div>
    <div class="garage-slot"><span>ENEMY 2</span><button class="load-json-btn" onclick="openCarLoader('enemy2')">LOAD JSON</button></div>
    <div class="garage-slot"><span>ENEMY 3</span><button class="load-json-btn" onclick="openCarLoader('enemy3')">LOAD JSON</button></div>
    <div class="garage-slot"><span>ENEMY 4</span><button class="load-json-btn" onclick="openCarLoader('enemy4')">LOAD JSON</button></div>
    <button id="settings-close" onclick="document.getElementById('garage-screen').style.display='none'; document.getElementById('top-screen').style.display='flex';">BACK</button>
</div>

<div id="top-screen">
    <div class="top-title">THREE.JS DRIVE</div>
    <div id="debug-stage-select">DEBUG STAGE SELECT: <select id="stage-choice"></select></div>
    <div class="top-btns">
        <div class="btn-large" id="start-btn">GAME START</div>
        <div class="btn-sub" onclick="document.getElementById('top-screen').style.display='none'; document.getElementById('garage-screen').style.display='flex';">GARAGE</div>
        <div class="btn-sub" id="gallery-btn">REPLAY GALLERY</div>
    </div>
    <div id="gear-btn">&#9881;</div>
</div>

<div id="settings-screen">
    <div class="settings-title">SETTINGS</div>
    <div class="setting-item"><span class="setting-label">BGM</span><input type="checkbox" id="bgm-toggle" checked></div>
    <div class="setting-item"><span class="setting-label">VOLUME</span><input type="range" id="bgm-volume" min="0" max="1" step="0.1" value="0.5"></div>
    <div id="settings-close">BACK</div>
</div>

<div id="result-screen">
    <div id="result-title">STAGE CLEAR</div>
    <div id="mission-bonus">Mission Complete $1000</div>
    <div id="result-bonus">Enemy Kill x <span id="kill-disp">0</span> x 100 = $<span id="money-bonus">0</span></div>
    <div id="result-total">TOTAL MONEY: $<span id="total-money-disp">0</span></div>
    <div class="result-btns">
        <div id="next-btn">Next Stage</div>
        <div class="replay-btn" id="local-replay-btn">Replay</div>
        <div class="replay-btn" id="save-replay-btn">Save Replay</div>
    </div>
</div>

<div class="touch-area touch-left"></div>
<div class="touch-area touch-right"></div>
<div id="fullscreenButton">★</div>
<input type="range" id="zoomSlider" min="0" max="2" step="0.01" value="0.8">
<div id="redFlash" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0; pointer-events: none; z-index: 1030; transition: opacity 0.1s ease-out;"></div>

<input type="file" id="replay-loader" style="display:none" accept=".json">
<input type="file" id="car-loader" style="display:none" accept=".json">

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
const stageChoice = document.getElementById('stage-choice');
for(let i=1; i<=30; i++){ const opt = document.createElement('option'); opt.value = i; opt.innerText = "STAGE " + i; stageChoice.appendChild(opt); }

// --- ガレージ設定 ---
const carConfigs = { player: null, enemy1: null, enemy2: null, enemy3: null, enemy4: null };
function openCarLoader(slot) {
    const l = document.getElementById('car-loader');
    l.onchange = (e) => {
        const file = e.target.files[0]; if(!file) return;
        const reader = new FileReader();
        reader.onload = (f) => { try { carConfigs[slot] = JSON.parse(f.target.result); alert(slot.toUpperCase() + " LOADED!"); } catch(e){ alert("Invalid JSON"); } };
        reader.readAsText(file);
    };
    l.click();
}

function createCarFromConfig(design, defCol) {
    const p = design || {
        color: '#' + defCol.toString(16).padStart(6, '0'),
        width: 2.2, totalLength: 5.0, lift: 0.4, noseH: 0.6, noseSlant: 0.2, spoilerAngle: 0.5,
        hoodL: 1.6, hoodH: 0.8, fSlant: 0.8, roofH: 1.5, roofL: 1.5, rSlant: 1.0, trunkH: 0.9, tailH: 0.7,
        wheelSizeFront: 0.45, wheelSizeRear: 0.45, wheelTread: 0.1, wheelColor: '#ffffff',
        headlights: 'Round_2', tailLights: 'Dual', mufflerType: 'Single',
        bumperF: true, bumperR: true, bumperColor: '#dddddd', frontGrill: true, grillColor: '#111111',
        rearGarnish: true, garnishColor: '#111111'
    };

    const container = new THREE.Group();
    const visual = new THREE.Group(); 
    container.add(visual);

    const bodyMat = new THREE.MeshStandardMaterial({ color: p.color, roughness: 0.4, metalness: 0.5 });
    const glassMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.1, metalness: 1, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
    const wheelMat = new THREE.MeshStandardMaterial({ color: p.wheelColor, metalness: 0.9, roughness: 0.1 });
    const tireMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
    const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
    const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const bumperMat = new THREE.MeshStandardMaterial({ color: p.bumperColor });
    const grillMat = new THREE.MeshStandardMaterial({ color: p.grillColor });
    const garnishMat = new THREE.MeshStandardMaterial({ color: p.garnishColor });
    const mufflerMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 1.0 });

    const halfL = p.totalLength / 2; const halfW = p.width / 2;
    const faceAngle = Math.atan2(p.noseSlant, p.noseH);

    const bShape = new THREE.Shape();
    bShape.moveTo(halfL, 0); 
    bShape.lineTo(halfL - p.noseSlant, p.noseH);
    bShape.lineTo(halfL - p.hoodL, p.hoodH);
    bShape.lineTo(halfL - p.hoodL - p.fSlant - p.roofL - p.rSlant, p.trunkH);
    bShape.lineTo(-halfL, p.tailH);
    bShape.lineTo(-halfL, 0);
    bShape.closePath();
    const bodyBase = new THREE.Mesh(new THREE.ExtrudeGeometry(bShape, { depth: p.width, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05 }), bodyMat);
    bodyBase.position.set(0, p.lift, -halfW); bodyBase.castShadow = bodyBase.receiveShadow = true;
    visual.add(bodyBase);

    const roof = new THREE.Mesh(new THREE.BoxGeometry(p.roofL, 0.05, p.width), bodyMat);
    roof.position.set(halfL - p.hoodL - p.fSlant - (p.roofL / 2), p.lift + p.roofH, 0); visual.add(roof);

    const addG = (s, e) => {
        const dx = e[0]-s[0], dy = e[1]-s[1], len = Math.sqrt(dx*dx+dy*dy);
        const g = new THREE.Mesh(new THREE.BoxGeometry(len, 0.02, p.width*0.96), glassMat);
        g.position.set(s[0]+dx/2, p.lift+s[1]+dy/2, 0); g.rotation.z = Math.atan2(dy, dx); visual.add(g);
    };
    addG([halfL-p.hoodL, p.hoodH], [halfL-p.hoodL-p.fSlant, p.roofH]);
    addG([halfL-p.hoodL-p.fSlant-p.roofL, p.roofH], [halfL-p.hoodL-p.fSlant-p.roofL-p.rSlant, p.trunkH]);
    
    const sideShape = new THREE.Shape();
    sideShape.moveTo(halfL - p.hoodL, p.hoodH);
    sideShape.lineTo(halfL - p.hoodL - p.fSlant, p.roofH);
    sideShape.lineTo(halfL - p.hoodL - p.fSlant - p.roofL, p.roofH);
    sideShape.lineTo(halfL - p.hoodL - p.fSlant - p.roofL - p.rSlant, p.trunkH);
    const sL = new THREE.Mesh(new THREE.ShapeGeometry(sideShape), glassMat); sL.position.set(0, p.lift, halfW + 0.01); visual.add(sL);
    const sR = sL.clone(); sR.position.z = -halfW - 0.01; visual.add(sR);

    const wheels = []; const wheelZ = halfW + 0.15 + p.wheelTread;
    const wPosArr = [
        {x:halfL-0.9, z:wheelZ, s:p.wheelSizeFront, side:1}, {x:halfL-0.9, z:-wheelZ, s:p.wheelSizeFront, side:-1}, 
        {x:-halfL+0.9, z:wheelZ, s:p.wheelSizeRear, side:1}, {x:-halfL+0.9, z:-wheelZ, s:p.wheelSizeRear, side:-1}
    ];
    wPosArr.forEach(pos => {
        const wg = new THREE.Group();
        wg.add(new THREE.Mesh(new THREE.CylinderGeometry(pos.s, pos.s, 0.3, 32).rotateX(Math.PI/2), tireMat));
        wg.add(new THREE.Mesh(new THREE.CylinderGeometry(pos.s*0.75, pos.s*0.75, 0.31, 32).rotateX(Math.PI/2), wheelMat));
        for(let i=0; i<5; i++) {
            const spoke = new THREE.Mesh(new THREE.BoxGeometry(pos.s*1.45, 0.08, 0.08), wheelMat);
            spoke.position.z = 0.16 * pos.side; spoke.rotation.z = (i/5)*Math.PI; wg.add(spoke);
        }
        wg.position.set(pos.x, pos.s, pos.z); visual.add(wg); wheels.push(wg);
    });

    const hlRelY = p.noseH - 0.22; const hlX = halfL - (hlRelY / p.noseH) * p.noseSlant;
    const createHL = (zSide) => {
        const g = new THREE.Group();
        if(p.headlights === 'Round_2') g.add(new THREE.Mesh(new THREE.CircleGeometry(0.18, 24).rotateY(Math.PI/2), lightMat));
        else if(p.headlights === 'Square_2') g.add(new THREE.Mesh(new THREE.PlaneGeometry(0.35, 0.22).rotateY(Math.PI/2), lightMat));
        else if(p.headlights === 'Square_4') { [0.12,-0.12].forEach(o=>{ const m=new THREE.Mesh(new THREE.PlaneGeometry(0.2,0.14).rotateY(Math.PI/2), lightMat); m.position.z=o; g.add(m); }); }
        g.position.set(hlX+0.061, p.lift+hlRelY, zSide); g.rotation.z = faceAngle; visual.add(g);
    };
    createHL(halfW - 0.25); createHL(-halfW + 0.25);

    if(p.frontGrill) {
        const grill = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.25, p.width*0.45), grillMat);
        grill.position.set(hlX+0.051, p.lift+hlRelY, 0); grill.rotation.z = faceAngle; visual.add(grill);
    }

    const tlY = p.lift + p.tailH - 0.25;
    const createTL = (zSide) => {
        const g = new THREE.Group();
        if(p.tailLights === 'Round') g.add(new THREE.Mesh(new THREE.CircleGeometry(0.15, 24), tailMat));
        else if(p.tailLights === 'Dual') { [0.12,-0.12].forEach(o=>{ const m=new THREE.Mesh(new THREE.CircleGeometry(0.1, 24), tailMat); m.position.x=o; g.add(m); }); }
        else g.add(new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.2), tailMat));
        g.rotation.y = -Math.PI/2; g.position.set(-halfL-0.06, tlY, zSide); visual.add(g);
    };
    createTL(halfW - 0.25); createTL(-halfW + 0.25);
    if(p.rearGarnish) {
        const garn = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.2, p.width*0.45), garnishMat);
        garn.position.set(-halfL - 0.051, tlY, 0); visual.add(garn);
    }

    if(p.bumperF) {
        const bf = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, p.width + 0.2), bumperMat);
        bf.position.set(halfL - (0.15/p.noseH)*p.noseSlant + 0.08, p.lift + 0.15, 0); bf.rotation.z = faceAngle; visual.add(bf);
    }
    if(p.bumperR) {
        const br = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, p.width + 0.2), bumperMat);
        br.position.set(-halfL - 0.08, p.lift + 0.1, 0); visual.add(br);
    }

    if(p.spoilerAngle > 0) {
        const sS = new THREE.Shape(); sS.moveTo(0,0); sS.lineTo(p.spoilerAngle,0); sS.lineTo(0,0.15); sS.closePath();
        const sp = new THREE.Mesh(new THREE.ExtrudeGeometry(sS, {depth:p.width, bevelEnabled:false}), bodyMat);
        sp.position.set(halfL - 0.05, p.lift, -halfW); visual.add(sp);
    }

    const createM = (z) => {
        const m = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.6, 16).rotateZ(Math.PI/2), mufflerMat);
        m.position.set(-halfL-0.1, p.lift-0.05, z); visual.add(m);
    };
    const mO = halfW - 0.4;
    if(p.mufflerType === 'Single') createM(-mO); else if(p.mufflerType === 'Dual') { createM(-mO+0.1); createM(-mO-0.1); } else if(p.mufflerType === 'Double') { createM(-mO); createM(mO); }

    visual.rotation.y = Math.PI / 2;

    return { group: container, wheels, bodyMat, color: parseInt(p.color.replace('#','0x')), hp: 100, dead: false, design: p };
}

function createCar(color) { return createCarFromConfig(null, color); }

const MAX_SPEED = 2.5, ACCEL = 0.08, FRICTION = 0.96, GRAVITY = 0.1, MAX_ZOOM_LEVEL = 2.0;
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87ceeb); scene.fog = new THREE.Fog(0x87ceeb, 200, 1500);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 8000);
const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement);
function updateCamera() { const w = window.innerWidth, h = window.innerHeight; renderer.setSize(w, h); camera.aspect = w/h; camera.updateProjectionMatrix(); }
window.addEventListener('resize', updateCamera); updateCamera();
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const sun = new THREE.DirectionalLight(0xffffff, 1.5); sun.position.set(100, 150, 100); sun.castShadow = true;
sun.shadow.camera.left = -100; sun.shadow.camera.right = 100; sun.shadow.camera.top = 100; sun.shadow.camera.bottom = -100; sun.shadow.mapSize.set(2048, 2048); scene.add(sun);
const mirrorCamera = new THREE.PerspectiveCamera(40, 3.0, 0.1, 500); const mirrorRenderTarget = new THREE.WebGLRenderTarget(256, 85);
const mirrorMaterial = new THREE.MeshBasicMaterial({ map: mirrorRenderTarget.texture }); const mirrorMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.25, 0.08), mirrorMaterial); scene.add(mirrorMesh);
function getHeight(x, z) { return Math.sin(x * 0.04) * 5 + Math.cos(z * 0.03) * 7 + Math.sin((x + z) * 0.02) * 4; }
const chunks = new Map();
function updateChunks(px, pz) {
    const cx = Math.floor(px/400), cz = Math.floor(pz/400);
    for(let x=cx-2; x<=cx+2; x++) {
        for(let z=cz-2; z<=cz+2; z++) {
            const key = `${x},${z}`;
            if(!chunks.has(key)) {
                const geo = new THREE.PlaneGeometry(400, 400, 40, 40); geo.rotateX(-Math.PI/2);
                const pos = geo.attributes.position; for(let i=0; i<pos.count; i++) pos.setY(i, getHeight(pos.getX(i)+x*400, pos.getZ(i)+z*400));
                geo.computeVertexNormals(); const m = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x998877, roughness: 0.8, metalness: 0.2 }));
                m.position.set(x*400, 0, z*400); m.receiveShadow = true; scene.add(m); chunks.set(key, m);
            }
        }
    }
}
const particles = [];
function spawnDust(pos, isSpark = false, isSmoke = false, isSand = false) {
    let color = isSpark ? 0xffffff : 0xd2c08a; if (isSmoke) color = 0x333333; if (isSand) color = 0x8b7355;
    const p = new THREE.Mesh(new THREE.SphereGeometry(isSpark?0.2:(isSmoke?0.6:0.4), 4, 4), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.6 }));
    p.position.copy(pos); const vel = isSmoke ? new THREE.Vector3((Math.random()-0.5)*0.2, 0.2+Math.random()*0.2, (Math.random()-0.5)*0.2) : new THREE.Vector3((Math.random()-0.5)*0.3, Math.random()*0.5 + 0.2, (Math.random()-0.5)*0.3);
    if (isSand) vel.set((Math.random()-0.5)*15, (Math.random()-0.2)*0.5, (Math.random()-0.5)*15);
    p.userData = { life: 1.0, vel: vel, type: isSmoke ? 'smoke' : (isSand ? 'sand' : 'dust') }; scene.add(p); particles.push(p);
}
function spawnDebris(pos, color, scale, count = 5) {
    const geo = new THREE.BoxGeometry(scale, scale, scale); const mat = new THREE.MeshStandardMaterial({ color });
    for(let i=0; i<count; i++) {
        const p = new THREE.Mesh(geo, mat); p.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*2, Math.random()*2, (Math.random()-0.5)*2));
        p.userData = { life: 1.0+Math.random(), vel: new THREE.Vector3((Math.random()-0.5)*1.5, Math.random()*0.8+0.5, (Math.random()-0.5)*1.5), rot: new THREE.Vector3(Math.random()*0.5, Math.random()*0.5, Math.random()*0.5), type: 'debris' };
        scene.add(p); particles.push(p);
    }
}

let player = createCarFromConfig(carConfigs.player, 0xcc2222);
player.speed = player.lastSpeed = player.vY = player.yaw = player.pitch = player.roll = 0; player.impactV = new THREE.Vector3(); scene.add(player.group);

let enemies = [];
const enemyColors = [0x00cc00, 0xcccc00, 0xcc22cc, 0xeeeeee, 0x2244cc, 0xcc5500];
function spawnEnemyAt(x, z) {
    const slotIdx = 1 + Math.floor(Math.random()*4);
    const slotDesign = carConfigs['enemy'+slotIdx];
    const col = enemyColors[Math.floor(Math.random()*enemyColors.length)];
    const ent = { ...createCarFromConfig(slotDesign, col), speed: 0, lastSpeed: 0, yaw: Math.random()*Math.PI*2, pitch: 0, roll: 0, attackTimer: 0, impactV: new THREE.Vector3(), color: col };
    ent.group.position.set(x, 10, z); scene.add(ent.group); enemies.push(ent);
}
function updateEnemiesCount(count) {
    enemies.forEach(e => scene.remove(e.group)); enemies = [];
    for(let i=0; i<count; i++) { const a = player.yaw + Math.PI + (Math.random()-0.5); spawnEnemyAt(player.group.position.x + Math.sin(a)*60, player.group.position.z + Math.cos(a)*60); }
}

let gameState = 'TOP', killCount = 0, playerMoney = 0, currentStage = 1, currentCargo = 0, maxCargo = 1, missionState = 'pickup', stageEnemyCount = 0;
let sandstormIntensity = 0, sandstormPeak = false, sandstormCycleTimer = 0;
const sandstormClouds = new THREE.Group(); scene.add(sandstormClouds);
const cloudTex = (() => { const c=document.createElement('canvas'); c.width=c.height=256; const ctx=c.getContext('2d'); const g=ctx.createRadialGradient(128,128,0,128,128,128); g.addColorStop(0,'rgba(90,74,58,1)'); g.addColorStop(1,'rgba(90,74,58,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,256,256); return new THREE.CanvasTexture(c); })();
function createSandWall() { sandstormClouds.clear(); const mat=new THREE.MeshBasicMaterial({map:cloudTex,transparent:true,opacity:0,fog:false,depthWrite:false}); for(let i=0; i<15; i++){ const m=new THREE.Mesh(new THREE.PlaneGeometry(1200,800),mat); m.position.set((Math.random()-0.5)*1500,300+(Math.random()-0.5)*200,(Math.random()-0.5)*400); m.rotation.z=Math.random()*Math.PI; sandstormClouds.add(m); } }
createSandWall();

// --- リプレイ ---
let replayBuffer = [], replayIndex = 0, isReplaying = false;
function recordFrame() {
    replayBuffer.push({
        p: { pos: {x:player.group.position.x, y:player.group.position.y, z:player.group.position.z}, quat: {_x:player.group.quaternion.x, _y:player.group.quaternion.y, _z:player.group.quaternion.z, _w:player.group.quaternion.w}, hp: player.hp, dead: player.dead, speed: player.speed, design: player.design },
        e: enemies.map(en => ({ pos: {x:en.group.position.x, y:en.group.position.y, z:en.group.position.z}, quat: {_x:en.group.quaternion.x, _y:en.group.quaternion.y, _z:en.group.quaternion.z, _w:en.group.quaternion.w}, hp: en.hp, dead: en.dead, speed: en.speed, color: en.color, design: en.design })),
        sand: { intensity: sandstormIntensity, peak: sandstormPeak, cycle: sandstormCycleTimer },
        target: {x:targetPos.x, y:targetPos.y, z:targetPos.z},
        mission: { type: missionState, cargo: currentCargo, max: maxCargo, stage: currentStage }
    });
}
function startReplay(data) {
    if (!data || data.length === 0) return;
    replayBuffer = data; replayIndex = 0; isReplaying = true; gameState = 'PLAY'; const f = data[0];
    
    scene.remove(player.group); 
    player = { ...createCarFromConfig(f.p.design, 0xcc2222), speed:0, lastSpeed:0, vY:0, yaw:0, pitch:0, roll:0, impactV: new THREE.Vector3() };
    player.group.position.set(f.p.pos.x, f.p.pos.y, f.p.pos.z); scene.add(player.group); smoothedCamPos.copy(player.group.position);
    
    enemies.forEach(e => scene.remove(e.group));
    enemies = f.e.map(ed => { const ent = { ...createCarFromConfig(ed.design, ed.color), dead: false, speed: 0, color: ed.color }; ent.group.position.set(ed.pos.x, ed.pos.y, ed.pos.z); scene.add(ent.group); return ent; });
    
    document.getElementById('top-screen').style.display='none'; document.getElementById('result-screen').style.display='none'; document.getElementById('post-replay-screen').style.display='none';
    document.getElementById('replay-ui').style.display='block'; document.getElementById('hud').style.display='flex'; document.getElementById('mission-info').style.display='block'; document.getElementById('zoomSlider').style.display='block';
    initAudio(); const pl=['mh.mp3','as.mp3','fu.mp3','vp.mp3','pr.mp3']; bgmAudio.src=pl[(f.mission.stage-1)%pl.length]; bgmAudio.play().catch(e=>{});
}
function exitReplay() { isReplaying = false; document.getElementById('replay-ui').style.display = 'none'; document.getElementById('post-replay-screen').style.display = 'flex'; }
function saveCurrentReplay() { const b = new Blob([JSON.stringify(replayBuffer)], {type:'application/json'}); const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href=u; a.download=`replay_st${currentStage}.json`; a.click(); }

document.getElementById('save-replay-btn').addEventListener('click', saveCurrentReplay);
document.getElementById('post-replay-save').addEventListener('click', saveCurrentReplay);
document.getElementById('gallery-btn').addEventListener('click', () => { document.getElementById('replay-loader').click(); });
document.getElementById('replay-loader').addEventListener('change', (e) => { const file = e.target.files[0]; if(!file)return; const r=new FileReader(); r.onload=(f)=>{startReplay(JSON.parse(f.target.result));}; r.readAsText(file); });
document.getElementById('local-replay-btn').addEventListener('click', () => { startReplay([...replayBuffer]); });
document.getElementById('post-replay-restart').addEventListener('click', () => { startReplay([...replayBuffer]); });
document.getElementById('exit-replay-btn').addEventListener('click', exitReplay);
document.getElementById('post-replay-exit').addEventListener('click', () => { document.getElementById('post-replay-screen').style.display = 'none'; if(replayBuffer.length>0&&(gameState==='CLEAR'||gameState==='PLAY')){ document.getElementById('result-screen').style.display='flex'; gameState='CLEAR'; } else document.getElementById('top-screen').style.display='flex'; document.getElementById('hud').style.display='none'; document.getElementById('mission-info').style.display='none'; });

let bgmEnabled = true, bgmVolume = 0.5; const bgmAudio = new Audio(); bgmAudio.loop = true;
function updateBgmVolume() { if(!bgmEnabled){ bgmAudio.volume=0; if(!bgmAudio.paused)bgmAudio.pause(); } else { bgmAudio.volume=bgmVolume; if(bgmAudio.paused&&gameState==='PLAY')bgmAudio.play().catch(e=>{}); } }

const beaconRedMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5, fog: false });
const beaconGreenMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5, fog: false });
const beaconMesh = new THREE.Mesh(new THREE.CylinderGeometry(40,40,5000,32), beaconRedMat); beaconMesh.position.y = 2500; scene.add(beaconMesh);
let targetPos = new THREE.Vector3();
function setNextObjective(type) {
    missionState = type; const a = Math.random()*Math.PI*2; targetPos.set(player.group.position.x + Math.sin(a)*5250, 0, player.group.position.z + Math.cos(a)*5250);
    if(type==='pickup'){ beaconMesh.material=beaconRedMat; document.getElementById('mission-type').innerText="PICKUP (RED BEAM)"; document.getElementById('mission-type').style.color="#ff3333"; }
    else { beaconMesh.material=beaconGreenMat; document.getElementById('mission-type').innerText="DELIVER (GREEN BEAM)"; document.getElementById('mission-type').style.color="#33ff33"; }
    document.getElementById('cargo-count').innerText=currentCargo; document.getElementById('cargo-max').innerText=maxCargo; document.getElementById('stage-num').innerText=currentStage;
}
function initStage(stage) {
    currentStage = stage; currentCargo = killCount = 0; gameState = 'PLAY'; replayBuffer = []; isReplaying = false;
    scene.remove(player.group); player = { ...createCarFromConfig(carConfigs.player, 0xcc2222), speed:0, lastSpeed:0, vY:0, yaw:0, pitch:0, roll:0, impactV: new THREE.Vector3() }; scene.add(player.group);
    document.getElementById('hud').style.display='flex'; document.getElementById('mission-info').style.display='block'; document.getElementById('fullscreenButton').style.display='block';
    if(window.matchMedia("(pointer: coarse)").matches) document.getElementById('zoomSlider').style.display='block';
    maxCargo = stage >= 10 ? 3 : (stage >= 4 ? 2 : 1); stageEnemyCount = stage <= 2 ? 1 : (stage === 3 ? 2 : 3);
    updateEnemiesCount(stageEnemyCount); setNextObjective('pickup'); showMsg("STAGE " + stage + " START");
    if(bgmEnabled){ const pl=['mh.mp3','as.mp3','fu.mp3','vp.mp3','pr.mp3']; bgmAudio.src=pl[(stage-1)%pl.length]; bgmAudio.play().catch(e=>{}); }
}
function showMsg(t, dur=3000){ const m=document.getElementById('msg'); m.innerText=t; m.style.display='block'; setTimeout(()=>m.style.display='none',dur); }
function showResultScreen(){ gameState='CLEAR'; document.getElementById('result-screen').style.display='flex'; bgmAudio.pause(); if(pGain){pGain.gain.cancelScheduledValues(audioCtx.currentTime);pGain.gain.setValueAtTime(0,audioCtx.currentTime);} playSFX('jin.mp3'); playerMoney+=1000+killCount*100; document.getElementById('p-money').innerText=playerMoney; document.getElementById('kill-disp').innerText=killCount; document.getElementById('money-bonus').innerText=killCount*100; document.getElementById('total-money-disp').innerText=playerMoney; }

document.getElementById('next-btn').addEventListener('click', () => { document.getElementById('result-screen').style.display='none'; initStage(parseInt(currentStage,10)+1); });
document.getElementById('start-btn').addEventListener('click', () => { document.getElementById('top-screen').style.display='none'; initAudio(); initStage(parseInt(document.getElementById('stage-choice').value, 10)); });
document.getElementById('gear-btn').addEventListener('click', () => { document.getElementById('top-screen').style.display='none'; document.getElementById('settings-screen').style.display='flex'; });
document.getElementById('settings-close').addEventListener('click', () => { document.getElementById('settings-screen').style.display='none'; document.getElementById('top-screen').style.display='flex'; });
document.getElementById('bgm-toggle').addEventListener('change', (e) => { bgmEnabled = e.target.checked; updateBgmVolume(); });
document.getElementById('bgm-volume').addEventListener('input', (e) => { bgmVolume = parseFloat(e.target.value); updateBgmVolume(); });

let audioCtx, pOsc, pGain;
function initAudio() { if (audioCtx) { if (audioCtx.state === 'suspended') audioCtx.resume(); return; } try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return; } pOsc = audioCtx.createOscillator(); pOsc.type = 'sawtooth'; pGain = audioCtx.createGain(); pGain.gain.value = 0; pOsc.connect(pGain).connect(audioCtx.destination); pOsc.start(); }
function playSFX(f) { if (!audioCtx) initAudio(); if (!audioCtx) return; const s = audioCtx.createBufferSource(); fetch(f).then(r => r.arrayBuffer()).then(b => audioCtx.decodeAudioData(b)).then(d => { s.buffer = d; s.connect(audioCtx.destination); s.start(0); }).catch(e => {}); }

const keys = {}; window.addEventListener("keydown", e => { keys[e.code] = true; if(gameState==='PLAY') initAudio(); }); window.addEventListener("keyup", e => { keys[e.code] = false; });
let lookYaw = 0, lookPitch = 0, zoomLevel = 0.8, smoothedCamPos = new THREE.Vector3();
let touchLeftId = -1, touchRightId = -1, touchState = { left: { startX: 0, startY: 0, currentX: 0, currentY: 0 }, right: { startX: 0, startY: 0, currentX: 0, currentY: 0 } };
addEventListener("wheel", e => { zoomLevel = Math.max(0, Math.min(MAX_ZOOM_LEVEL, zoomLevel + e.deltaY*0.001)); }, {passive:true});
renderer.domElement.addEventListener("mousedown", () => { if(gameState==='PLAY') { renderer.domElement.requestPointerLock(); initAudio(); } });
document.addEventListener("mousemove", e => { if (document.pointerLockElement === renderer.domElement) { lookYaw -= e.movementX * 0.003; lookPitch = Math.max(-0.6, Math.min(0.6, lookPitch - e.movementY * 0.003)); } });
document.getElementById('zoomSlider').addEventListener('input', e => { zoomLevel = parseFloat(e.target.value); });
window.addEventListener('touchstart', e => { if(gameState==='PLAY') initAudio(); for (let i = 0; i < e.changedTouches.length; i++) { const t = e.changedTouches[i]; if (t.clientX < window.innerWidth / 2) { touchLeftId = t.identifier; touchState.left = { startX: t.clientX, startY: t.clientY, currentX: t.clientX, currentY: t.clientY }; } else { touchRightId = t.identifier; touchState.right = { startX: t.clientX, startY: t.clientY, currentX: t.clientX, currentY: t.clientY }; } } }, {passive: false});
window.addEventListener('touchmove', e => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { const t = e.changedTouches[i]; if (t.identifier === touchLeftId) { touchState.left.currentX = t.clientX; touchState.left.currentY = t.clientY; } else if (t.identifier === touchRightId) { lookYaw -= (t.clientX - touchState.right.currentX) * 0.005; lookPitch = THREE.MathUtils.clamp(lookPitch - (t.clientY - touchState.right.currentY) * 0.005, -0.6, 0.6); touchState.right.currentX = t.clientX; touchState.right.currentY = t.clientY; } } }, {passive: false});
window.addEventListener('touchend', e => { for (let i = 0; i < e.changedTouches.length; i++) { const t = e.changedTouches[i]; if (t.identifier === touchLeftId) { touchLeftId = -1; keys.KeyW = keys.KeyS = keys.KeyA = keys.KeyD = false; } else if (t.identifier === touchRightId) touchRightId = -1; } }, {passive: false});
document.getElementById('fullscreenButton').addEventListener('click', () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => console.warn(err)); else document.exitFullscreen(); });

function animate() {
    requestAnimationFrame(animate);
    if (gameState === 'TOP' || gameState === 'SETTINGS') { renderer.render(scene, camera); if(pGain && audioCtx) pGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05); return; }
    if (gameState === 'CLEAR' && !isReplaying) { renderer.render(scene, camera); return; }

    const now = audioCtx ? audioCtx.currentTime : 0;
    if (isReplaying) {
        const f = replayBuffer[replayIndex]; if (!f) { exitReplay(); return; }
        const prevF = replayIndex > 0 ? replayBuffer[replayIndex-1] : null;
        if (prevF && f.p.hp < prevF.p.hp) { playSFX(f.p.hp <= 0 ? 'crash.mp3' : 'ecrs.mp3'); if(f.p.hp <= 0) spawnDebris(player.group.position, player.color, 1.5, 15); }
        player.group.position.set(f.p.pos.x, f.p.pos.y, f.p.pos.z); player.group.quaternion.set(f.p.quat._x, f.p.quat._y, f.p.quat._z, f.p.quat._w);
        player.hp = f.p.hp; player.dead = f.p.dead; player.speed = f.p.speed;
        
        // 記録されたデザインから色をセット
        const pCol = (f.p.design ? f.p.design.color : 0xcc2222);
        player.bodyMat.color.set(!player.dead ? pCol : 0);
        
        sandstormIntensity = f.sand.intensity; sandstormPeak = f.sand.peak; sandstormCycleTimer = f.sand.cycle;
        targetPos.set(f.target.x, f.target.y, f.target.z);
        document.getElementById('p-hp').innerText = Math.floor(player.hp); document.getElementById('cargo-count').innerText = f.mission.cargo; document.getElementById('stage-num').innerText = f.mission.stage;
        document.getElementById('replay-info').innerText = `REPLAY - STAGE ${f.mission.stage} (${Math.floor(replayIndex/60)}s / ${Math.floor(replayBuffer.length/60)}s)`;
        f.e.forEach((ed, i) => { if(enemies[i]) { 
            const pe = prevF ? prevF.e[i] : null;
            if (pe && ed.dead && !pe.dead) { enemies[i].bodyMat.color.set(0); spawnDebris(new THREE.Vector3(ed.pos.x, ed.pos.y, ed.pos.z), ed.color, 1.5, 15); playSFX('crash.mp3'); }
            else if (pe && ed.hp < pe.hp) { playSFX('crs.mp3'); for(let k=0;k<5;k++) spawnDust(enemies[i].group.position, true); }
            const eCol = (ed.design ? ed.design.color : ed.color);
            if(!ed.dead) enemies[i].bodyMat.color.set(eCol); else enemies[i].bodyMat.color.set(0);
            enemies[i].group.position.set(ed.pos.x, ed.pos.y, ed.pos.z); enemies[i].group.quaternion.set(ed.quat._x, ed.quat._y, ed.quat._z, ed.quat._w); enemies[i].speed = ed.speed; enemies[i].dead = ed.dead;
        }});
        replayIndex++; if (replayIndex >= replayBuffer.length) exitReplay();
    } else {
        if (currentStage >= 5) { sandstormCycleTimer += 1/60; if (sandstormCycleTimer > 15 && sandstormCycleTimer <= 25) sandstormIntensity = (sandstormCycleTimer-15)/10; else if (sandstormCycleTimer > 25 && sandstormCycleTimer <= 30) { if(!sandstormPeak){sandstormPeak=true; showMsg("SANDSTORM PEAK!", 2000);} sandstormIntensity=1.0; } else if (sandstormCycleTimer > 30) { sandstormCycleTimer=0; sandstormPeak=false; } else sandstormIntensity = THREE.MathUtils.lerp(sandstormIntensity, 0, 0.01); } else sandstormIntensity = 0;
        recordFrame();
    }

    const stormCol = new THREE.Color(0x8b7355).lerp(new THREE.Color(0x87ceeb), 1.0 - sandstormIntensity);
    scene.background.copy(stormCol); if (scene.fog) { scene.fog.color.copy(stormCol); scene.fog.near = THREE.MathUtils.lerp(200, sandstormPeak?2:15, sandstormIntensity); scene.fog.far = THREE.MathUtils.lerp(1500, sandstormPeak?25:100, sandstormIntensity); }
    sandstormClouds.visible = !sandstormPeak && sandstormIntensity > 0.1;
    if (sandstormClouds.visible) { const d = new THREE.Vector3().subVectors(targetPos, player.group.position).normalize(); sandstormClouds.position.copy(player.group.position).add(d.multiplyScalar(400)); sandstormClouds.lookAt(player.group.position); sandstormClouds.children.forEach(m => m.material.opacity = sandstormIntensity * 0.8); }
    beaconMesh.visible = (sandstormIntensity < 0.8);
    const noise = document.getElementById('noise-overlay'); noise.style.opacity = sandstormIntensity * 0.4;
    if (sandstormIntensity > 0) noise.style.backgroundPosition = `${Math.random()*1000}px ${Math.random()*1000}px`;
    if (sandstormIntensity > 0.4 && Math.random() < sandstormIntensity) { const cd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); spawnDust(camera.position.clone().add(cd.multiplyScalar(3)).add(new THREE.Vector3((Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*15)), false, false, true); }
    beaconMesh.position.set(targetPos.x, getHeight(targetPos.x, targetPos.z) + 2495, targetPos.z);
    
    if (!isReplaying) {
        const d2t = player.group.position.distanceTo(targetPos);
        if (d2t < 30) { if (missionState === 'pickup') { showMsg("CARGO PICKED UP!"); player.hp = 100; setNextObjective('deliver'); } else { currentCargo++; player.hp = 100; if (currentCargo >= maxCargo) showResultScreen(); else { showMsg("Next one!"); targetPos.set(999999, 999999, 999999); setTimeout(() => setNextObjective('pickup'), 1500); } } }
    }

    updateChunks(player.group.position.x, player.group.position.z);
    sun.position.set(player.group.position.x + 50, 150, player.group.position.z + 50); sun.target = player.group;

    for(let i = particles.length - 1; i >= 0; i--){
        const p = particles[i]; p.userData.life -= 0.015; p.position.add(p.userData.vel);
        if (p.userData.type === 'debris') { p.rotation.x += p.userData.rot.x; p.userData.vel.y -= 0.02; const h = getHeight(p.position.x, p.position.z); if(p.position.y < h) { p.position.y = h; p.userData.vel.y *= -0.5; } p.scale.setScalar(p.userData.life * 0.5); }
        else if (p.userData.type === 'sand') { p.material.opacity = p.userData.life * 0.4; p.scale.setScalar(1 + (1.0 - p.userData.life) * 8); }
        else { p.scale.setScalar(p.userData.type === 'smoke' ? (1 + (1.0 - p.userData.life) * 3) : (1 + (1.0 - p.userData.life) * 4)); p.material.opacity = p.userData.life * 0.6; }
        if(p.userData.life <= 0){ scene.remove(p); particles.splice(i, 1); }
    }

    const entities = [player, ...enemies];
    if (!isReplaying) {
        if (enemies.length < stageEnemyCount) { const sa = player.yaw + Math.PI + (Math.random()-0.5); spawnEnemyAt(player.group.position.x + Math.sin(sa)*70, player.group.position.z + Math.cos(sa)*70); }
        entities.forEach(ent => {
            const isP = (ent === player); if (ent.dead) ent.speed *= 0.95; if (!isP && ent.dead && ent.group.parent === null) return;
            ent.lastSpeed = ent.speed; let turnInput = 0;
            if(isP && !ent.dead) {
                if(keys.KeyW) ent.speed += ACCEL; if(keys.KeyS) ent.speed -= ACCEL;
                if(keys.KeyA) { ent.yaw += 0.05; turnInput = 1; } if(keys.KeyD) { ent.yaw -= 0.05; turnInput = -1; }
                if (touchLeftId !== -1) { const dy = touchState.left.currentY - touchState.left.startY, dx = touchState.left.currentX - touchState.left.startX; if (dy < -15) ent.speed += ACCEL * 1.5; else if (dy > 20) ent.speed -= ACCEL; if (dx < -20) { ent.yaw += 0.05; turnInput = 1; } else if (dx > 20) { ent.yaw -= 0.05; turnInput = -1; } }
                ent.speed *= FRICTION;
            } else if (!isP && !ent.dead) {
                enemies.forEach(other => { if (ent === other || other.dead) return; if (ent.group.position.distanceTo(other.group.position) < 5.5) ent.group.position.add(new THREE.Vector3().subVectors(ent.group.position, other.group.position).normalize().multiplyScalar(0.12)); });
                const tpv = new THREE.Vector3().subVectors(player.group.position, ent.group.position);
                ent.speed = THREE.MathUtils.lerp(ent.speed, Math.abs(player.speed) + 0.5, 0.02);
                let dy = (Math.atan2(tpv.x, tpv.z) + Math.PI) - ent.yaw; while(dy < -Math.PI) dy += Math.PI*2; while(dy > Math.PI) dy -= Math.PI*2;
                const step = dy * 0.025; ent.yaw += step; turnInput = THREE.MathUtils.clamp(step * 20, -1, 1);
            }
            const fw = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), ent.yaw);
            ent.group.position.addScaledVector(fw, ent.speed); ent.group.position.add(ent.impactV); ent.impactV.multiplyScalar(0.9);
            const hF = getHeight(ent.group.position.x + fw.x*2.3, ent.group.position.z + fw.z*2.3), hB = getHeight(ent.group.position.x - fw.x*2.3, ent.group.position.z - fw.z*2.3);
            const rw = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), ent.yaw);
            const hR = getHeight(ent.group.position.x + rw.x*1.25, ent.group.position.z + rw.z*1.25), hL = getHeight(ent.group.position.x - rw.x*1.25, ent.group.position.z - rw.z*1.25);
            const avgY = (hF + hB + hR + hL) / 4 + 0.12; if(isP) { ent.vY -= GRAVITY; ent.group.position.y += ent.vY; if(ent.group.position.y <= avgY) { ent.group.position.y = avgY; ent.vY = 0; } } else ent.group.position.y = avgY;
            ent.pitch = THREE.MathUtils.lerp(ent.pitch, Math.atan2(hF - hB, 4.6), 0.1); ent.roll = THREE.MathUtils.lerp(ent.roll, Math.atan2(hR - hL, 2.5) - turnInput*Math.abs(ent.speed)*0.06, 0.1);
            ent.group.quaternion.setFromEuler(new THREE.Euler(ent.pitch, ent.yaw, ent.roll, 'YXZ'));
        });
        if (!player.dead) {
            enemies.forEach((enemy, idx) => {
                if(enemy.dead) return; const dist = player.group.position.distanceTo(enemy.group.position);
                if (dist < 3.8) {
                    const dir = new THREE.Vector3().subVectors(enemy.group.position, player.group.position).normalize();
                    if (new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw)).dot(dir) > 0.3) {
                        enemy.hp -= 20; player.hp += 5; enemy.impactV.add(dir.multiplyScalar(1.5)); playSFX('crs.mp3'); for (let i=0; i<5; i++) spawnDust(enemy.group.position, true);
                        if(enemy.hp <= 0) { enemy.dead = true; killCount++; player.hp += 10; enemy.bodyMat.color.set(0); spawnDebris(enemy.group.position, 0, 0.8, 30); playSFX('crash.mp3'); setTimeout(() => { scene.remove(enemy.group); enemies.splice(idx, 1); }, 2000); }
                    } else { player.hp -= 5; player.impactV.add(dir.multiplyScalar(-0.8)); spawnDust(player.group.position, false); playSFX('ecrs.mp3'); document.getElementById('redFlash').style.opacity = '0.6'; setTimeout(() => document.getElementById('redFlash').style.opacity = '0', 100); }
                    document.getElementById('p-hp').innerText = Math.floor(Math.max(0, player.hp));
                    if (player.hp <= 0) { player.dead = true; player.speed = 0; document.getElementById('msg').innerText = "GAME OVER"; document.getElementById('msg').style.display = 'block'; playSFX('crash.mp3'); setTimeout(() => location.reload(), 5000); }
                }
            });
        }
    }

    entities.forEach(ent => {
        if (ent.dead && Math.random() > 0.8) spawnDust(ent.group.position.clone().add(new THREE.Vector3(0, 1.2, 0)), false, true);
        const ay = getHeight(ent.group.position.x, ent.group.position.z) + 0.12;
        if(!ent.dead && Math.abs(ent.speed) > 0.4 && ent.group.position.y <= ay + 0.5) {
            [[1.35,0,-1.6],[-1.35,0,-1.6],[1.35,0,1.6],[-1.35,0,1.6]].forEach(off => {
                if(Math.random() > 0.8) spawnDust(new THREE.Vector3(...off).applyQuaternion(ent.group.quaternion).add(ent.group.position));
            });
        }
    });

    const cp = new THREE.Vector3(0, 2.4, 0.5), tp = new THREE.Vector3(0, 4.5, 12), dp = new THREE.Vector3(0, 70, 150);
    let co = (zoomLevel <= 1.0) ? new THREE.Vector3().lerpVectors(cp, tp, zoomLevel) : new THREE.Vector3().lerpVectors(tp, dp, Math.min(1.0, (zoomLevel - 1.0)/(MAX_ZOOM_LEVEL - 1.0)));
    const bq = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, isReplaying ? 0 : player.yaw, 0));
    const mq = new THREE.Quaternion().setFromEuler(new THREE.Euler(lookPitch, lookYaw, 0, 'YXZ'));
    let fq; if (zoomLevel <= 1.0) fq = new THREE.Quaternion().slerpQuaternions(player.group.quaternion.clone(), bq, zoomLevel).multiply(mq);
    else { const cpl = player.group.position.clone().add(co.clone().applyQuaternion(bq)), tc = new THREE.Camera(); tc.position.copy(cpl); tc.lookAt(player.group.position); fq = tc.quaternion.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, lookYaw, 0))); }
    smoothedCamPos.lerp(player.group.position.clone().add(co.clone().applyQuaternion(fq)), zoomLevel < 0.15 ? 1.0 : (zoomLevel < 1.0 ? 0.2 : 0.3));
    camera.position.copy(smoothedCamPos); camera.quaternion.copy(fq);

    if (zoomLevel < 0.15) {
        mirrorMesh.visible = true; mirrorMesh.position.copy(camera.position).add(new THREE.Vector3(0, 0.2, -0.4).applyQuaternion(camera.quaternion)); mirrorMesh.quaternion.copy(camera.quaternion);
        mirrorCamera.position.copy(player.group.position).add(new THREE.Vector3(0, 2.6, 0).applyQuaternion(player.group.quaternion)); mirrorCamera.quaternion.setFromEuler(new THREE.Euler(0, (isReplaying ? 0 : player.yaw) + Math.PI, 0));
        renderer.setRenderTarget(mirrorRenderTarget); renderer.render(scene, mirrorCamera); renderer.setRenderTarget(null);
    } else mirrorMesh.visible = false;

    if(audioCtx && !player.dead && gameState === 'PLAY') { pGain.gain.setTargetAtTime(0.3, now, 0.05); pOsc.frequency.setTargetAtTime(70 + Math.abs(player.speed) * 60, now, 0.05); }
    else if(pGain) pGain.gain.setTargetAtTime(0, now, 0.05);
    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>