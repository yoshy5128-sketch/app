<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Map Editor (Complete - Grid Snap)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #2c3e50; 
            color: #ecf0f1; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none; 
            display: flex; /* 横並びレイアウトの基本 */
        }
        #editor-container { 
            display: contents; /* コンテナを透過させ、子要素をbodyのflexアイテムにする */
        }
        #ui-container {
            position: relative;
            width: 50vw; /* 画面幅の半分 */
            height: 100vh; /* 画面の高さ全体 */
            background: rgba(44, 62, 80, 0.95);
            padding: 5px;
            box-sizing: border-box;
            border-left: 1px solid #34495e; /* 左側に境界線 */
            box-shadow: -4px 0 15px rgba(0,0,0,0.6); /* 影の方向を調整 */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            overflow-y: hidden; /* 親コンテナのスクロールを無効化 */
        }
        #ui-container h2 {
            margin: 3px 0;
            color: #1abc9c;
            border-bottom: 1px solid #16a085;
            padding-bottom: 2px;
            width: 100%;
            text-align: center;
            flex-shrink: 0;
        }
        #ui-container h3, #ui-container h4 {
            margin: 5px 0 3px 0;
            color: #bdc3c7;
            text-align: center;
        }
        #ui-container p {
            margin: 1px 0;
            font-size: 0.75em;
            text-align: center;
            flex-shrink: 0;
        }
        #ui-content-wrapper {
            display: flex;
            flex-direction: column; /* UIパネル内の要素を縦積みに変更 */
            width: 100%;
            gap: 10px;
            padding: 5px;
            box-sizing: border-box;
            flex-grow: 1; /* 残りの高さをすべて埋める */
            overflow-y: auto; /* この要素でスクロールを制御 */
            min-height: 0; /* flexアイテムの縮小問題を解決 */
        }
        #left-panel, #right-panel {
            flex-shrink: 0; /* パネルが縮まないようにする */
            min-width: 0;
            padding: 5px;
            border: 1px solid #34495e;
            border-radius: 5px;
            overflow-y: auto;
        }
        #canvas-container {
            width: 50vw; /* 画面幅の半分 */
            height: 100vh; /* 画面の高さ全体 */
            position: relative; /* absoluteから変更 */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #properties-editor, #light-properties-editor {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            display: none; /* 初期状態では非表示 */
        }
        #properties-editor {
            border: 1px solid #1abc9c;
            background: rgba(26, 188, 156, 0.1);
        }
         #light-properties-editor {
            border: 1px solid #f1c40f;
            background: rgba(241, 196, 15, 0.1);
        }
        #properties-editor label, #light-properties-editor label {
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        #properties-editor input[type="number"], #light-properties-editor input[type="number"] {
            width: 60px;
            padding: 3px;
            border: 1px solid #3498db;
            background: #34495e;
            color: #ecf0f1;
            border-radius: 3px;
            margin-left: 5px;
        }
        #properties-editor input[type="color"], #light-properties-editor input[type="color"] {
            padding: 0;
            border: none;
            width: 50px;
            height: 25px;
        }
        #spawn-editor {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #f39c12;
            border-radius: 5px;
            background: rgba(243, 156, 18, 0.1);
            display: none;
        }
        #spawn-editor p {
            font-size: 0.9em;
            text-align: left;
            margin: 2px 0;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            text-align: center;
            text-decoration: none;
            display: block;
            font-size: 14px;
            margin: 4px auto;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
            width: 95%;
        }
        button:hover {
            background-color: #2980b9;
        }
        #apply-props-button {
            background-color: #1abc9c;
        }
        #apply-props-button:hover {
            background-color: #16a085;
        }
        #notification {
            position: fixed;
            bottom: 20px; /* 右下隅に調整 */
            right: 20px; /* 右下隅に調整 */
            left: auto;
            transform: none;
            background-color: #1abc9c;
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 110;
        }
    </style>
</head>
<body>
    <div id="editor-container">
        <div id="canvas-container"></div>
        <div id="ui-container">
            <h2>Map Editor</h2>
            <p style="margin-bottom: 5px;">**PC:** L-Click: Add/Select/Move | R-Click: Delete | R-Drag: Pan | Scroll: Zoom</p>

            <div id="ui-content-wrapper">
                <div id="left-panel">
                    <h3>Map Actions</h3>
                    <p style="font-size: 0.8em; color: #88c;">**Grid Snap:** $\pm$ **3.0** units</p>
                    <button id="reset-button">New Map</button>
                    <div style="display: flex; justify-content: space-around; margin: 5px 0;">
                        <button id="add-obstacle-button" style="width: 24%; margin: 0;">Add Obstacle</button>
                        <button id="add-light-button" style="width: 24%; margin: 0;">Add Light</button>
                        <button id="add-tower-button" style="width: 24%; margin: 0; background-color: #ff6b35;">Add Tower</button>
                        <button id="add-house-button" style="width: 24%; margin: 0; background-color: #9b59b6;">Add House</button>
                    </div>

                    <div id="properties-editor">
                        <h4>Obstacle Properties</h4>
                        <label>Width (X): <input type="number" id="prop-width" step="0.5"></label>
                        <label>Height (Y): <input type="number" id="prop-height" step="0.5"></label>
                        <label>Depth (Z): <input type="number" id="prop-depth" step="0.5"></label>
                        <label>HP (Rocket Hits): <input type="number" id="prop-hp" step="1" min="1"></label>
                        <label style="margin-bottom: 10px;">Color: <input type="color" id="prop-color"></label>
                        <div id="recent-colors-palette" style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px; padding: 5px; border: 1px dashed #555; border-radius: 3px;">
                            </div>
                        <button id="apply-props-button">Apply Properties</button>
                    </div>

                    <div id="house-properties-editor" style="display: none;">
                        <h4>House Properties</h4>
                        <label>Width (X): <input type="number" id="house-width" step="0.5" value="8"></label>
                        <label>Height (Y): <input type="number" id="house-height" step="0.5" value="5"></label>
                        <label>Depth (Z): <input type="number" id="house-depth" step="0.5" value="8"></label>
                        <label>HP: <input type="number" id="house-hp" step="1" min="1" value="8"></label>
                        <label style="margin-bottom: 10px;">Color: <input type="color" id="house-color" value="#ff6666"></label>
                        <button id="apply-house-props-button">Apply House Properties</button>
                    </div>

                    <div id="light-properties-editor">
                        <h4>Light Properties</h4>
                        <label>Intensity: <input type="number" id="light-intensity" step="0.1" min="0"></label>
                        <label>Color: <input type="color" id="light-color"></label>
                        <button id="apply-light-props-button" style="background-color: #f1c40f; color: #2c3e50;">Apply Light Properties</button>
                    </div>

                    <div id="tower-properties-editor" style="display: none;">
                        <h4>Tower Properties</h4>
                        <label>Width (X): <input type="number" id="tower-width" step="0.5" value="6"></label>
                        <label>Depth (Z): <input type="number" id="tower-depth" step="0.5" value="6"></label>
                        <label>Height (Y): <input type="number" id="tower-height" step="0.5" value="12"></label>
                        <label style="margin-bottom: 10px;">Color: <input type="color" id="tower-color" value="#ff6b35"></label>
                        <button id="apply-tower-props-button" style="background-color: #ff6b35; color: white;">Apply Tower Properties</button>
                    </div>

                    <div id="spawn-editor">
                        <h4>Spawn Point</h4>
                        <p>Type: <b id="spawn-type"></b></p>
                        <p>X Position: <b id="spawn-x"></b></p>
                        <p>Z Position: <b id="spawn-z"></b></p>
                    </div>
                </div>
                <div id="right-panel">
                    <h3>Map Management</h3>
                    <p>Map Name:</p>
                    <input type="text" id="map-name-input" placeholder="Enter map name" style="width: 90%; padding: 5px; margin: 0 auto 10px auto; display: block; background: #34495e; border: 1px solid #3498db; color: #ecf0f1; border-radius: 3px;">
                    <button id="save-map-button">Save Map</button>
                    
                    <p style="margin-top: 15px;">Load/Delete Maps:</p>
                    <select id="saved-maps-select" style="width: 95%; padding: 5px; margin: 0 auto 10px auto; display: block; background: #34495e; border: 1px solid #3498db; color: #ecf0f1; border-radius: 3px;"></select>
                    <button id="load-map-button" style="background-color: #1abc9c;">Load Map</button>
                    <button id="delete-map-button" style="background-color: #e74c3c;">Delete Map</button>
                    
                    <button id="export-file-button" style="background-color: #27ae60;">Export to File (.json)</button>
                    <button id="import-file-button" style="background-color: #f39c12;">Import from File (.json)</button>
                    <input type="file" id="import-file-input" accept=".json" style="display: none;">
                    <a href="index.html"><button id="back-button" style="background-color: #e74c3c;">Back to Game</button></a>
                    
                    <div style="margin-top: 10px; border-top: 1px solid #34495e; padding-top: 5px;">
                        <h4 style="text-align: center; margin-bottom: 5px;">How to Use (Touch)</h4>
                        <p style="font-size: 0.7em; margin: 2px 0;"><b>1-Finger Tap:</b> Add/Select</p>
                        <p style="font-size: 0.7em; margin: 2px 0;"><b>1-Finger Drag:</b> Move Selected</p>
                        <p style="font-size: 0.7em; margin: 2px 0;"><b>1-Finger Long Press:</b> Delete</p>
                        <p style="font-size: 0.7em; margin: 2px 0;"><b>2-Finger Drag:</b> Pan Camera</p>
                        <p style="font-size: 0.7em; margin: 2px 0;"><b>2-Finger Pinch:</b> Zoom Camera</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="notification"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- CONSTANTS ---
        const ARENA_RADIUS = 60;
        const ARENA_EDGE_THICKNESS = 1;
        const FRUSTUM_SIZE = 200;
        
        // --- GRID CONSTANTS (New) ---
        const GRID_SIZE = ARENA_RADIUS * 2; // 120
        const GRID_DIVISIONS = 40; // 120 / 40 = 3 => 3ユニットごとのグリッド
        const GRID_STEP = GRID_SIZE / GRID_DIVISIONS; // 3.0

        let PERSISTENT_OBSTACLE_SIZE = { 
            width: 4, 
            height: 4, 
            depth: 4, 
            color: 0x7f8c8d,
            hp: 1
        };

        let SPAWN_POINTS_DATA = [
            { id: 0, x: 0, z: -20, color: 0x0000ff, name: 'Player' },
            { id: 1, x: 0, z: 20, color: 0x00ff00, name: 'AI 1' },
            { id: 2, x: 15, z: 20, color: 0x00ffff, name: 'AI 2' },
            { id: 3, x: -15, z: 20, color: 0xffb6c1, name: 'AI 3' }
        ];

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2c3e50);

        const canvasContainer = document.getElementById('canvas-container');
        
        let aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
        const camera = new THREE.OrthographicCamera(
            FRUSTUM_SIZE * aspect / -2, FRUSTUM_SIZE * aspect / 2, 
            FRUSTUM_SIZE / 2, FRUSTUM_SIZE / -2, 
            1, 1000
        );
        camera.position.set(0, 100, 0);
        camera.lookAt(scene.position);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        canvasContainer.appendChild(renderer.domElement);
        
        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(50, 100, 25);
        scene.add(directionalLight);

        // --- ARENA ---
        const floorGeometry = new THREE.CircleGeometry(ARENA_RADIUS, 64);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x34495e }); 
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.name = 'floor';
        scene.add(floor);

        const edgeGeometry = new THREE.TorusGeometry(ARENA_RADIUS, ARENA_EDGE_THICKNESS, 8, 100);
        const edgeMaterial = new THREE.MeshBasicMaterial({ color: 0x95a5a6 }); 
        const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
        edge.rotation.x = Math.PI / 2;
        scene.add(edge);
        
        // --- GRID SETUP ---
        const gridHelper = new THREE.GridHelper(GRID_SIZE, GRID_DIVISIONS, 0x4f6b80, 0x4f6b80);
        gridHelper.rotation.x = Math.PI / 2;
        scene.add(gridHelper);
        
        // --- STATE ---
        let obstacles = [];
        let lights = []; // 追加: 電灯オブジェクトを保持する配列
        let spawnMeshes = [];
        let selectedObject = null;
        let isDragging = false;
        let isPanning = false;
        let panStart = new THREE.Vector2();
        let initialFrustumSize = FRUSTUM_SIZE;
        let addingMode = 'obstacle'; // 追加: オブジェクト追加モードを管理
        
        // --- HOUSE CREATION FUNCTION ---
        function createHouse(x, z, isNew = true) {
            const snappedX = snapToGrid(x);
            const snappedZ = snapToGrid(z);

            if (isNew) {
                const posVec = new THREE.Vector2(snappedX, snappedZ);
                if (posVec.length() > ARENA_RADIUS) {
                    showNotification('Cannot place house outside the arena.', true);
                    return null;
                }
            }

            // 建物の設定 - UIから現在の設定を読み込む
            const config = {
                width: parseFloat(document.getElementById('house-width').value) || 8,
                height: parseFloat(document.getElementById('house-height').value) || 5,
                depth: parseFloat(document.getElementById('house-depth').value) || 8,
                color: parseInt(document.getElementById('house-color').value.replace('#', '0x')),
                thickness: 0.2
            };

            const house = new THREE.Group();
            house.position.set(snappedX, 0, snappedZ);

            const material = new THREE.MeshLambertMaterial({ 
                color: config.color, 
                side: THREE.DoubleSide 
            });

            // 穴あき壁を生成する共通関数
            function createWallMesh(width, height, thickness, material, holes = []) {
                const shape = new THREE.Shape();
                shape.moveTo(-width / 2, 0);
                shape.lineTo(width / 2, 0);
                shape.lineTo(width / 2, height);
                shape.lineTo(-width / 2, height);
                shape.lineTo(-width / 2, 0);

                holes.forEach(h => {
                    const holePath = new THREE.Path();
                    holePath.moveTo(h.x - h.w / 2, h.y);
                    holePath.lineTo(h.x + h.w / 2, h.y);
                    holePath.lineTo(h.x + h.w / 2, h.y + h.h);
                    holePath.lineTo(h.x - h.w / 2, h.y + h.h);
                    holePath.lineTo(h.x - h.w / 2, h.y);
                    shape.holes.push(holePath);
                });

                const geometry = new THREE.ExtrudeGeometry(shape, {
                    depth: thickness,
                    bevelEnabled: false
                });
                const mesh = new THREE.Mesh(geometry, material);
                return mesh;
            }

            // 1. 床
            const floor = new THREE.Mesh(
                new THREE.BoxGeometry(config.width, config.thickness, config.depth),
                material
            );
            floor.position.y = config.thickness / 2;
            house.add(floor);

            // 2. 正面壁 (ドアあり)
            const frontWall = createWallMesh(config.width, config.height, config.thickness, material, [
                { x: 0, y: 0, w: 2, h: 3 } // Door
            ]);
            frontWall.position.set(0, config.thickness, config.depth / 2 - config.thickness);
            house.add(frontWall);

            // 3. 背面壁 (窓2つ)
            const backWall = createWallMesh(config.width, config.height, config.thickness, material, [
                { x: -config.width/4, y: 2, w: 1.5, h: 1.5 },
                { x: config.width/4, y: 2, w: 1.5, h: 1.5 }
            ]);
            backWall.position.set(0, config.thickness, -config.depth / 2);
            house.add(backWall);

            // 4. 左壁 (窓1つ)
            const leftWall = createWallMesh(config.depth, config.height, config.thickness, material, [
                { x: 0, y: 2, w: 2, h: 1.5 }
            ]);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-config.width / 2, config.thickness, 0);
            house.add(leftWall);

            // 5. 右壁 (窓1つ)
            const rightWall = createWallMesh(config.depth, config.height, config.thickness, material, [
                { x: 0, y: 2, w: 2, h: 1.5 }
            ]);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(config.width / 2, config.thickness, 0);
            house.add(rightWall);

            // 6. 屋根
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(config.width + 0.4, config.thickness, config.depth + 0.4),
                material
            );
            roof.position.y = config.height + config.thickness;
            house.add(roof);

            // userDataを設定
            house.userData = { 
                type: 'house',
                width: config.width,
                height: config.height,
                depth: config.depth,
                color: config.color,
                hp: 8 // 建物なので丈夫に
            };
            
            scene.add(house);
            obstacles.push(house);
            
            return house;
        }
        function createTower(x, z, isNew = true) {
            const snappedX = snapToGrid(x);
            const snappedZ = snapToGrid(z);

            if (isNew) {
                const posVec = new THREE.Vector2(snappedX, snappedZ);
                if (posVec.length() > ARENA_RADIUS) {
                    showNotification('Cannot place tower outside the arena.', true);
                    return null;
                }
            }

            // ゲーム本体と同じ塔作成ロジック - UIから現在の設定を読み込む
            const TOWER_WIDTH = parseFloat(document.getElementById('tower-width').value) || 6;
            const TOWER_DEPTH = parseFloat(document.getElementById('tower-depth').value) || 6;
            const TOWER_HEIGHT = parseFloat(document.getElementById('tower-height').value) || 12;
            const towerYPos = (TOWER_HEIGHT / 2);
            const towerGeometry = new THREE.BoxGeometry(TOWER_WIDTH, TOWER_HEIGHT, TOWER_DEPTH);
            
            const towerMaterial = new THREE.MeshLambertMaterial({ 
                color: parseInt(document.getElementById('tower-color').value.replace('#', '0x')) || 0x4A4A4A
            });
            
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.set(snappedX, towerYPos, snappedZ);
            tower.userData = { 
                type: 'tower',
                isTower: true,
                width: TOWER_WIDTH,
                height: TOWER_HEIGHT,
                depth: TOWER_DEPTH,
                color: parseInt(document.getElementById('tower-color').value.replace('#', '0x')) || 0x4A4A4A,
                hp: 6 // ゲーム本体と同じHP
            };
            
            scene.add(tower);
            obstacles.push(tower);
            
            // 梯子を作成（ゲーム本体のロジックを簡略化）
            const ladderGroup = new THREE.Group();
            const LADDER_WIDTH = 1.5;
            const RUNG_SPACING = 0.5;
            const RUNG_THICKNESS = 0.1;
            
            const ladderMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const rungMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            
            // 梯子の側面
            const sideGeometry = new THREE.BoxGeometry(RUNG_THICKNESS * 2, TOWER_HEIGHT, RUNG_THICKNESS * 2);
            const leftSide = new THREE.Mesh(sideGeometry, ladderMaterial);
            const rightSide = new THREE.Mesh(sideGeometry, ladderMaterial);
            leftSide.position.set(-LADDER_WIDTH / 2, 0, TOWER_DEPTH / 2 + 0.1);
            rightSide.position.set(LADDER_WIDTH / 2, 0, TOWER_DEPTH / 2 + 0.1);
            ladderGroup.add(leftSide);
            ladderGroup.add(rightSide);
            
            // 梯子の踏み板
            const numRungs = Math.floor(TOWER_HEIGHT / RUNG_SPACING);
            for (let i = 0; i < numRungs; i++) {
                const rungGeometry = new THREE.BoxGeometry(LADDER_WIDTH, RUNG_THICKNESS, RUNG_THICKNESS);
                const rung = new THREE.Mesh(rungGeometry, rungMaterial);
                rung.position.y = -TOWER_HEIGHT / 2 + RUNG_SPACING * (i + 0.5);
                rung.position.z = TOWER_DEPTH / 2 + 0.1;
                ladderGroup.add(rung);
            }
            
            tower.add(ladderGroup);
            
            // 屋上の特徴を追加
            const rooftopY = TOWER_HEIGHT / 2;
            
            const rooftopFeature = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1, 2),
                new THREE.MeshLambertMaterial({ color: 0xff0000 })
            );
            rooftopFeature.position.set(0, rooftopY + 0.5, 0);
            tower.add(rooftopFeature);
            
            return tower;
        }

        // 最近使用した色の管理
        const MAX_RECENT_COLORS = 8; 
        let recentColors = [];
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        
        // --- TOUCH CONTROL STATE ---
        let touchDownTimer = null;
        const LONG_PRESS_THRESHOLD = 500; 
        let touchStartPos = { x: 0, y: 0 };
        let touchMode = 'none'; 
        let initialPinchDistance = 0;
        let cameraTarget = new THREE.Vector3(0, 0, 0); 

        // --- UTILITY (Grid Snap Function) ---
        function snapToGrid(value) {
            return Math.round(value / GRID_STEP) * GRID_STEP;
        }

        // --- OBJECT CREATION ---

        function createObstacleMaterial(color) {
            const material = new THREE.MeshLambertMaterial({ 
                color: color
            });
            return material;
        }
        
        // 追加: 電灯オブジェクトを作成する関数
        function createLight(x, z, color = 0xffffff, intensity = 1.0, isNew = true) {
            const snappedX = snapToGrid(x);
            const snappedZ = snapToGrid(z);

            if (isNew) {
                const posVec = new THREE.Vector2(snappedX, snappedZ);
                if (posVec.length() > ARENA_RADIUS) {
                    showNotification('Cannot place light outside the arena.', true);
                    return null;
                }
            }

            // Three.jsのPointLightを作成
            const light = new THREE.PointLight(color, intensity, 100); // 距離100まで影響
            light.position.set(snappedX, 5, snappedZ); // 高さを5に設定

            // エディタ上で電灯を視覚的に表現するメッシュを作成
            const lightSphereGeo = new THREE.SphereGeometry(0.5, 16, 8);
            const lightSphereMat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const lightRepresentation = new THREE.Mesh(lightSphereGeo, lightSphereMat);
            lightRepresentation.position.copy(light.position);

            // メッシュにPointLightへの参照とプロパティを userData として保存
            lightRepresentation.userData = { 
                type: 'light', 
                light: light, // 実際の光源オブジェクト
                color: color, 
                intensity: intensity 
            };
            
            scene.add(light);
            scene.add(lightRepresentation);
            lights.push(lightRepresentation);

            return lightRepresentation;
        }

        function renderSpawnPoints() {
            spawnMeshes.forEach(mesh => scene.remove(mesh));
            spawnMeshes = [];

            SPAWN_POINTS_DATA.forEach((pos) => {
                const spawnGeo = new THREE.CylinderGeometry(2, 2, 0.5, 32);
                const spawnMat = new THREE.MeshBasicMaterial({ color: pos.color, transparent: true, opacity: 0.5 });
                const spawnMesh = new THREE.Mesh(spawnGeo, spawnMat);
                
                const snappedX = snapToGrid(pos.x);
                const snappedZ = snapToGrid(pos.z);
                spawnMesh.position.set(snappedX, 0.25, snappedZ);
                
                spawnMesh.userData = { 
                    type: 'spawn', 
                    id: pos.id, 
                    name: pos.name,
                    color: pos.color
                };
                scene.add(spawnMesh);
                spawnMeshes.push(spawnMesh);
            });
        }

        function createObstacle(x, z, width, height, depth, color, hp, isNew = true) {
            width = width || PERSISTENT_OBSTACLE_SIZE.width;
            height = height || PERSISTENT_OBSTACLE_SIZE.height;
            depth = depth || PERSISTENT_OBSTACLE_SIZE.depth;
            color = color || PERSISTENT_OBSTACLE_SIZE.color;
            hp = hp === undefined ? PERSISTENT_OBSTACLE_SIZE.hp : hp;

            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = createObstacleMaterial(color); 
            const obstacle = new THREE.Mesh(geometry, material);
            
            const snappedX = snapToGrid(x);
            const snappedZ = snapToGrid(z);

            obstacle.position.set(snappedX, height / 2, snappedZ);
            
            obstacle.userData = { type: 'obstacle', color: color, hp: hp };
            
            if (isNew) {
                const halfWidth = width / 2;
                const halfDepth = depth / 2;
                const corners = [
                    new THREE.Vector2(snappedX - halfWidth, snappedZ - halfDepth), new THREE.Vector2(snappedX + halfWidth, snappedZ - halfDepth),
                    new THREE.Vector2(snappedX - halfWidth, snappedZ + halfDepth), new THREE.Vector2(snappedX + halfWidth, snappedZ + halfDepth)
                ];
                for (const corner of corners) {
                    if (corner.length() > ARENA_RADIUS) {
                        showNotification('Cannot place obstacle outside the arena.', true);
                        return;
                    }
                }
            }

            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        // --- UI / STATE MANAGEMENT ---
        
        // 追加: オブジェクト追加モードを切り替える関数
        function setAddingMode(mode) {
            addingMode = mode;
            const obstacleBtn = document.getElementById('add-obstacle-button');
            const lightBtn = document.getElementById('add-light-button');
            const towerBtn = document.getElementById('add-tower-button');
            const houseBtn = document.getElementById('add-house-button');
            
            // プロパティエディタの表示制御
            const propEditor = document.getElementById('properties-editor');
            const housePropEditor = document.getElementById('house-properties-editor');
            const lightPropEditor = document.getElementById('light-properties-editor');
            const towerPropEditor = document.getElementById('tower-properties-editor');
            
            // すべてのプロパティエディタを非表示
            propEditor.style.display = 'none';
            housePropEditor.style.display = 'none';
            lightPropEditor.style.display = 'none';
            towerPropEditor.style.display = 'none';
            
            // すべてのボタンを非アクティブ色にリセット
            obstacleBtn.style.backgroundColor = '#7f8c8d';
            lightBtn.style.backgroundColor = '#7f8c8d';
            towerBtn.style.backgroundColor = '#7f8c8d';
            houseBtn.style.backgroundColor = '#7f8c8d';
            
            // アクティブなモードのボタン色とプロパティエディタを変更
            if (mode === 'obstacle') {
                obstacleBtn.style.backgroundColor = '#3498db';
                propEditor.style.display = 'block';
            } else if (mode === 'light') {
                lightBtn.style.backgroundColor = '#f1c40f';
                lightPropEditor.style.display = 'block';
            } else if (mode === 'tower') {
                towerBtn.style.backgroundColor = '#ff6b35';
                towerPropEditor.style.display = 'block';
            } else if (mode === 'house') {
                houseBtn.style.backgroundColor = '#9b59b6';
                housePropEditor.style.display = 'block';
            }
        }

        function setSelected(object) {
            const propEditor = document.getElementById('properties-editor');
            const spawnEditor = document.getElementById('spawn-editor');
            const lightPropEditor = document.getElementById('light-properties-editor'); // 追加

            // 選択解除時のハイライトリセットとエディタ非表示
            if (selectedObject) {
                if (selectedObject.material.emissive) { // emissiveプロパティがない場合があるためチェック
                    selectedObject.material.emissive.setHex(0x000000);
                }
                if (selectedObject.userData.type === 'spawn') {
                    selectedObject.material.opacity = 0.5;
                }
            }
            propEditor.style.display = 'none';
            spawnEditor.style.display = 'none';
            lightPropEditor.style.display = 'none'; // 追加

            if (object) {
                selectedObject = object;
                const userData = selectedObject.userData; // userDataを一度取得

                if (userData.type === 'obstacle') {
                    selectedObject.material.emissive.setHex(0x3498db); // ハイライト
                    propEditor.style.display = 'block';
                    document.getElementById('prop-width').value = selectedObject.geometry.parameters.width;
                    document.getElementById('prop-height').value = selectedObject.geometry.parameters.height;
                    document.getElementById('prop-depth').value = selectedObject.geometry.parameters.depth;
                    document.getElementById('prop-hp').value = userData.hp || 1;
                    document.getElementById('prop-color').value = '#' + userData.color.toString(16).padStart(6, '0');
                } else if (userData.type === 'spawn') {
                    selectedObject.material.opacity = 0.8; // ハイライト
                    spawnEditor.style.display = 'block';
                    document.getElementById('spawn-type').textContent = userData.name;
                    document.getElementById('spawn-x').textContent = selectedObject.position.x.toFixed(2);
                    document.getElementById('spawn-z').textContent = selectedObject.position.z.toFixed(2);
                } else if (userData.type === 'light') { // 追加: 電灯の選択時
                    selectedObject.material.emissive.setHex(0xf1c40f); // ハイライト (黄色)
                    lightPropEditor.style.display = 'block';
                    document.getElementById('light-intensity').value = userData.intensity;
                    document.getElementById('light-color').value = '#' + userData.color.toString(16).padStart(6, '0');
                }
            } else {
                selectedObject = null;
            }
        }
        
        function applyProperties() {
            if (!selectedObject || selectedObject.userData.type !== 'obstacle') return;

            const width = parseFloat(document.getElementById('prop-width').value);
            const height = parseFloat(document.getElementById('prop-height').value);
            const depth = parseFloat(document.getElementById('prop-depth').value);
            const hp = parseInt(document.getElementById('prop-hp').value, 10);
            const hexColor = document.getElementById('prop-color').value;
            const newColor = parseInt(hexColor.replace('#', '0x'));

            if (isNaN(width) || isNaN(height) || isNaN(depth) || isNaN(hp) || width <= 0 || height <= 0 || depth <= 0 || hp <= 0) {
                showNotification('Invalid dimensions or HP.', true);
                return;
            }
            
            selectedObject.geometry.dispose();
            selectedObject.geometry = new THREE.BoxGeometry(width, height, depth);
            selectedObject.position.y = height / 2;
            
            selectedObject.material.color.setHex(newColor);
            selectedObject.userData.color = newColor;
            selectedObject.userData.hp = hp;
            
            PERSISTENT_OBSTACLE_SIZE = { width, height, depth, color: newColor, hp: hp };
            
            addRecentColor(newColor); 
            showNotification('Obstacle properties applied!');
        }
        
        // 追加: 電灯のプロパティを適用する関数
        function applyLightProperties() {
            if (!selectedObject || selectedObject.userData.type !== 'light') return;

            const intensity = parseFloat(document.getElementById('light-intensity').value);
            const hexColor = document.getElementById('light-color').value;
            const newColor = parseInt(hexColor.replace('#', '0x'));

            if (isNaN(intensity) || intensity < 0) {
                showNotification('Invalid intensity.', true);
                return;
            }

            // 電灯のユーザーデータと実際の光源オブジェクトを更新
            selectedObject.userData.intensity = intensity;
            selectedObject.userData.color = newColor;
            selectedObject.userData.light.intensity = intensity;
            selectedObject.userData.light.color.setHex(newColor);
            selectedObject.material.color.setHex(newColor); // 表現用メッシュの色も更新

            showNotification('Light properties applied!');
        }

        function onColorChange(event) {
            if (selectedObject && selectedObject.userData.type === 'obstacle') {
                const hexColor = event.target.value;
                const newColor = parseInt(hexColor.replace('#', '0x'));
                
                selectedObject.material.color.setHex(newColor);
                selectedObject.userData.color = newColor;
                PERSISTENT_OBSTACLE_SIZE.color = newColor;
                addRecentColor(newColor); 
            }
        }
        
        function loadRecentColors() {
            const savedColors = localStorage.getItem('recentMapEditorColors');
            if (savedColors) {
                try {
                    recentColors = JSON.parse(savedColors);
                } catch (e) { recentColors = []; }
            }
        }

        function saveRecentColors() {
            localStorage.setItem('recentMapEditorColors', JSON.stringify(recentColors));
        }

        function addRecentColor(colorHex) {
            const hex = typeof colorHex === 'number' ? '#' + colorHex.toString(16).padStart(6, '0') : colorHex;
            recentColors = recentColors.filter(c => c !== hex);
            recentColors.unshift(hex); 
            if (recentColors.length > MAX_RECENT_COLORS) recentColors.pop();
            saveRecentColors();
            renderRecentColors(); 
        }

        function renderRecentColors() {
            const paletteDiv = document.getElementById('recent-colors-palette');
            if (!paletteDiv) return;
            paletteDiv.innerHTML = ''; 
            recentColors.forEach(colorHex => {
                const colorSwatch = document.createElement('div');
                colorSwatch.style.cssText = `background-color: ${colorHex}; width: 24px; height: 24px; border: 1px solid #777; cursor: pointer; border-radius: 3px;`;
                colorSwatch.title = colorHex; 
                colorSwatch.addEventListener('click', () => {
                    const propColorInput = document.getElementById('prop-color');
                    if (propColorInput) {
                        propColorInput.value = colorHex;
                        propColorInput.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                });
                paletteDiv.appendChild(colorSwatch);
            });
            if (recentColors.length === 0) paletteDiv.innerHTML = '<span style="color: #999; font-size: 0.8em;">No recent colors.</span>';
        }

        function showNotification(message, isError = false) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.backgroundColor = isError ? '#e74c3c' : '#1abc9c';
            notification.style.opacity = 1;
            setTimeout(() => { notification.style.opacity = 0; }, 3000);
        }

        // --- I/O (Save, Load, File Operations) ---

        let allCustomMaps = JSON.parse(localStorage.getItem('allCustomMaps') || '{}');

        function updateSavedMapsSelect() {
            const select = document.getElementById('saved-maps-select');
            select.innerHTML = ''; 
            const mapNames = Object.keys(allCustomMaps);
            if (mapNames.length === 0) {
                select.innerHTML = '<option value="" disabled selected>No maps saved</option>';
                document.getElementById('load-map-button').disabled = true;
                document.getElementById('delete-map-button').disabled = true;
            } else {
                mapNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    select.appendChild(option);
                });
                select.value = mapNames[0];
                document.getElementById('load-map-button').disabled = false;
                document.getElementById('delete-map-button').disabled = false;
            }
        }

        function saveMap() {
            const mapName = document.getElementById('map-name-input').value.trim();
            if (!mapName) {
                showNotification('Please enter a map name.', true);
                return;
            }

            const mapData = {
                obstacles: obstacles.map(o => {
                    if (o.userData.type === 'tower') {
                        // 塔の場合は特別なデータ形式で保存
                        return {
                            x: o.position.x, z: o.position.z,
                            type: 'tower',
                            width: o.userData.width,
                            height: o.userData.height,
                            depth: o.userData.depth,
                            hp: o.userData.hp
                        };
                    } else if (o.userData.type === 'house') {
                        // 家の場合は特別なデータ形式で保存
                        return {
                            x: o.position.x, z: o.position.z,
                            type: 'house',
                            width: o.userData.width,
                            height: o.userData.height,
                            depth: o.userData.depth,
                            color: o.userData.color,
                            hp: o.userData.hp
                        };
                    } else {
                        // 通常の障害物
                        return {
                            x: o.position.x, z: o.position.z,
                            width: o.geometry.parameters.width, height: o.geometry.parameters.height, depth: o.geometry.parameters.depth,
                            color: o.userData.color, hp: o.userData.hp
                        };
                    }
                }),
                lights: lights.map(l => ({ // 追加: 電灯データを保存
                    x: l.position.x, z: l.position.z,
                    color: l.userData.color, intensity: l.userData.intensity
                })),
                spawnPoints: SPAWN_POINTS_DATA,
                persistentSize: PERSISTENT_OBSTACLE_SIZE
            };
            
            allCustomMaps[mapName] = mapData;
            try {
                localStorage.setItem('allCustomMaps', JSON.stringify(allCustomMaps));
                showNotification(`Map "${mapName}" saved successfully!`);
                updateSavedMapsSelect();
            } catch (e) {
                showNotification('Failed to save map data.', true);
            }
        }

        function loadMap() {
            const mapName = document.getElementById('saved-maps-select').value;
            if (!mapName || !allCustomMaps[mapName]) {
                showNotification('Please select a map to load.', true);
                return;
            }
            resetMap(false);
            const mapData = allCustomMaps[mapName];
            try {
                if (mapData.obstacles) mapData.obstacles.forEach(d => {
                    if (d.type === 'tower') {
                        // 塔の場合は塔作成関数を呼び出す
                        createTower(d.x, d.z, false);
                    } else if (d.type === 'house') {
                        // 家の場合は家作成関数を呼び出す
                        createHouse(d.x, d.z, false);
                    } else {
                        // 通常の障害物
                        createObstacle(d.x, d.z, d.width, d.height, d.depth, d.color, d.hp, false);
                    }
                });
                if (mapData.lights) mapData.lights.forEach(d => createLight(d.x, d.z, d.color, d.intensity, false)); // 追加: 電灯データを読み込み
                if (mapData.spawnPoints) SPAWN_POINTS_DATA = mapData.spawnPoints.map(d => ({...d, x: snapToGrid(d.x), z: snapToGrid(d.z)}));
                if (mapData.persistentSize) PERSISTENT_OBSTACLE_SIZE = mapData.persistentSize;
                
                renderSpawnPoints();
                showNotification(`Map "${mapName}" loaded!`);
            } catch(e) {
                showNotification('Failed to load map data.', true);
                resetMap();
            }
        }

        function deleteMap() {
            const mapName = document.getElementById('saved-maps-select').value;
            if (!mapName) {
                showNotification('Please select a map to delete.', true);
                return;
            }

            if (confirm(`Are you sure you want to delete map "${mapName}"?`)) {
                delete allCustomMaps[mapName];
                try {
                    localStorage.setItem('allCustomMaps', JSON.stringify(allCustomMaps));
                    showNotification(`Map "${mapName}" deleted.`);
                    updateSavedMapsSelect();
                    resetMap();
                } catch (e) {
                    showNotification('Failed to delete map.', true);
                }
            }
        }
        
        function resetMap(showNote = true) {
            setSelected(null);
            
            obstacles.forEach(o => scene.remove(o));
            obstacles = [];

            lights.forEach(l => { // 追加: 電灯をシーンから削除
                scene.remove(l.userData.light); // 実際のPointLight
                scene.remove(l); // 表現用メッシュ
            });
            lights = []; // 電灯配列をクリア
            
            SPAWN_POINTS_DATA = [
                { id: 0, x: 0, z: -20, color: 0x0000ff, name: 'Player' }, { id: 1, x: 0, z: 20, color: 0x00ff00, name: 'AI 1' },
                { id: 2, x: 15, z: 20, color: 0x00ffff, name: 'AI 2' }, { id: 3, x: -15, z: 20, color: 0xffb6c1, name: 'AI 3' }
            ].map(d => ({...d, x: snapToGrid(d.x), z: snapToGrid(d.z)}));
            
            renderSpawnPoints();
            if (showNote) showNotification('New map created.'); 
        }

        function exportMapToFile() {
            const mapData = {
                obstacles: obstacles.map(o => ({
                    x: o.position.x, z: o.position.z,
                    width: o.geometry.parameters.width, height: o.geometry.parameters.height, depth: o.geometry.parameters.depth,
                    color: o.userData.color, hp: o.userData.hp
                })),
                lights: lights.map(l => ({ // 追加: 電灯データをエクスポート
                    x: l.position.x, z: l.position.z,
                    color: l.userData.color, intensity: l.userData.intensity
                })),
                spawnPoints: SPAWN_POINTS_DATA,
                persistentSize: PERSISTENT_OBSTACLE_SIZE
            };
            const blob = new Blob([JSON.stringify(mapData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `gunfight-map-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(a.href);
            showNotification('Map exported to file!');
        }

        function importMapFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const mapData = JSON.parse(e.target.result);
                    if (!mapData.obstacles) throw new Error('Invalid map format.'); // 障害物がない場合はエラーとする
                    
                    resetMap(false); 
                    if (mapData.obstacles) mapData.obstacles.forEach(d => createObstacle(d.x, d.z, d.width, d.height, d.depth, d.color, d.hp, false));
                    if (mapData.lights) mapData.lights.forEach(d => createLight(d.x, d.z, d.color, d.intensity, false)); // 追加: 電灯データをインポート
                    if (mapData.spawnPoints) SPAWN_POINTS_DATA = mapData.spawnPoints.map(d => ({...d, x: snapToGrid(d.x), z: snapToGrid(d.z)}));
                    if (mapData.persistentSize) PERSISTENT_OBSTACLE_SIZE = mapData.persistentSize;
                    
                    renderSpawnPoints();
                    showNotification('Map imported successfully!');
                } catch (error) {
                    showNotification('Error: Could not read map file.', true);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; 
        }

        // --- CAMERA CONTROLS & EVENT LISTENERS ---

        function updateCameraPosition() {
            camera.position.x = cameraTarget.x;
            camera.position.z = cameraTarget.z;
            camera.lookAt(cameraTarget.x, 0, cameraTarget.z);
        }

        function getNormalizedPointer(event, index = 0) {
            const canvasBounds = renderer.domElement.getBoundingClientRect();
            let clientX, clientY;
            
            if (event.touches && event.touches.length > index) {
                clientX = event.touches[index].clientX;
                clientY = event.touches[index].clientY;
            } else if (event.clientX !== undefined) {
                clientX = event.clientX;
                clientY = event.clientY;
            } else return null;

            mouse.x = ((clientX - canvasBounds.left) / canvasBounds.width) * 2 - 1;
            mouse.y = -((clientY - canvasBounds.top) / canvasBounds.height) * 2 + 1;
            return mouse;
        }

        function onMouseMove(event) {
            if (touchMode !== 'none') return;
            const mouse = getNormalizedPointer(event);

            if (isDragging && selectedObject) {
                raycaster.setFromCamera(mouse, camera);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                const snappedX = snapToGrid(intersection.x);
                const snappedZ = snapToGrid(intersection.z);

                // アリーナの範囲内に留めるためのチェック
                let canMove = true;
                if (selectedObject.userData.type === 'obstacle') {
                    const halfWidth = selectedObject.geometry.parameters.width / 2;
                    const halfDepth = selectedObject.geometry.parameters.depth / 2;
                    const corners = [
                        new THREE.Vector2(snappedX - halfWidth, snappedZ - halfDepth), new THREE.Vector2(snappedX + halfWidth, snappedZ - halfDepth),
                        new THREE.Vector2(snappedX - halfWidth, snappedZ + halfDepth), new THREE.Vector2(snappedX + halfWidth, snappedZ + halfDepth)
                    ];
                    if (corners.some(corner => corner.length() > ARENA_RADIUS)) {
                        canMove = false;
                    }
                } else {
                    if (Math.hypot(snappedX, snappedZ) > ARENA_RADIUS) {
                        canMove = false;
                    }
                }

                if (canMove) {
                    selectedObject.position.set(snappedX, selectedObject.position.y, snappedZ);
                    if (selectedObject.userData.type === 'spawn') {
                        const data = SPAWN_POINTS_DATA.find(d => d.id === selectedObject.userData.id);
                        if(data) { data.x = snappedX; data.z = snappedZ; }
                        document.getElementById('spawn-x').textContent = snappedX.toFixed(2);
                        document.getElementById('spawn-z').textContent = snappedZ.toFixed(2);
                    } else if (selectedObject.userData.type === 'light') {
                        selectedObject.userData.light.position.copy(selectedObject.position);
                    }
                }
            } else if (isPanning) {
                const deltaX = event.clientX - panStart.x;
                const deltaY = event.clientY - panStart.y;
                panStart.set(event.clientX, event.clientY);

                const panFactorX = (camera.right - camera.left) / renderer.domElement.clientWidth;
                const panFactorY = (camera.top - camera.bottom) / renderer.domElement.clientHeight;

                cameraTarget.x -= deltaX * panFactorX;
                cameraTarget.z -= deltaY * panFactorY; // Y軸の動きをZ軸に正しく反映

                const maxPanRadius = ARENA_RADIUS / 2;
                if (cameraTarget.length() > maxPanRadius) cameraTarget.normalize().multiplyScalar(maxPanRadius);
                updateCameraPosition();
            }
        }

        // 追加: オブジェクト追加ロジックの一元化
        function handleObjectAddition(pos) {
            const snappedX = snapToGrid(pos.x);
            const snappedZ = snapToGrid(pos.z);
            if (addingMode === 'obstacle') {
                createObstacle(snappedX, snappedZ, PERSISTENT_OBSTACLE_SIZE.width, PERSISTENT_OBSTACLE_SIZE.height, PERSISTENT_OBSTACLE_SIZE.depth, PERSISTENT_OBSTACLE_SIZE.color, PERSISTENT_OBSTACLE_SIZE.hp);
                showNotification('Obstacle added!');
            } else if (addingMode === 'light') {
                createLight(snappedX, snappedZ);
                showNotification('Light added!');
            } else if (addingMode === 'tower') {
                createTower(snappedX, snappedZ);
                showNotification('Tower with ladder added!');
            } else if (addingMode === 'house') {
                createHouse(snappedX, snappedZ);
                showNotification('House with interior added!');
            }
        }
        
        // 追加: オブジェクト削除ロジックの一元化
        function deleteObject(object) {
            if (!object) return;
            
            // Groupオブジェクトの場合は再帰的に親を探す
            let targetObject = object;
            while (targetObject.parent && targetObject.parent.type === 'Group') {
                targetObject = targetObject.parent;
            }
            
            // userData.typeがない場合はさらに親を探す
            if (!targetObject.userData.type && targetObject.parent) {
                targetObject = targetObject.parent;
            }
            
            const type = targetObject.userData.type;
            if (type === 'obstacle') {
                scene.remove(targetObject);
                obstacles = obstacles.filter(o => o !== targetObject);
                showNotification('Obstacle deleted!');
            } else if (type === 'light') {
                scene.remove(targetObject.userData.light); // 実際のPointLightも削除
                scene.remove(targetObject); // 表現用メッシュも削除
                lights = lights.filter(l => l !== targetObject);
                showNotification('Light deleted!');
            } else if (type === 'house') {
                scene.remove(targetObject);
                obstacles = obstacles.filter(o => o !== targetObject);
                showNotification('House deleted!');
            } else if (type === 'tower') {
                scene.remove(targetObject);
                obstacles = obstacles.filter(o => o !== targetObject);
                showNotification('Tower deleted!');
            } else {
                // デバッグ情報
                console.log('Unknown object type:', targetObject.userData);
                console.log('Object:', targetObject);
                showNotification('Cannot delete this object type', true);
            }
            setSelected(null); // 選択解除
        }

        function onMouseDown(event) {
            if (touchMode !== 'none') return;
            
            const mouse = getNormalizedPointer(event);
            raycaster.setFromCamera(mouse, camera);
            const allClickable = [...obstacles, ...spawnMeshes, ...lights]; // lightsを追加

            if (event.button === 0) { // 左クリック
                const intersects = raycaster.intersectObjects(allClickable);
                if (intersects.length > 0) {
                    isDragging = true;
                    setSelected(intersects[0].object);
                } else {
                    setSelected(null);
                    const floorIntersects = raycaster.intersectObject(floor);
                    if (floorIntersects.length > 0) {
                        handleObjectAddition(floorIntersects[0].point); // ロジックを一元化
                    }
                }
            } else if (event.button === 2) { // 右クリック (削除とパン)
                const intersects = raycaster.intersectObjects([...obstacles, ...lights], true); // recursive=trueを追加
                if (intersects.length > 0) {
                    deleteObject(intersects[0].object); // ロジックを一元化
                } else {
                    isPanning = true;
                    panStart.set(event.clientX, event.clientY);
                }
            }
        }

        function onMouseUp(event) {
            if (touchMode !== 'none') return;
            if (event.button === 0) isDragging = false;
            if (event.button === 2) isPanning = false;
        }
        
        function onWheel(event) {
            event.preventDefault();
            const zoomFactor = 1.05;
            initialFrustumSize *= (event.deltaY < 0 ? 1 / zoomFactor : zoomFactor);
            initialFrustumSize = Math.max(50, Math.min(400, initialFrustumSize));
            onWindowResize();
        }

        // --- TOUCH LISTENERS (Mobile) ---

        function onTouchStart(event) {
            event.preventDefault(); 
            const touches = event.touches;
            clearTimeout(touchDownTimer); 
            isDragging = false; isPanning = false;

            if (touches.length === 1) {
                touchMode = 'single-tap-drag';
                touchStartPos.x = touches[0].clientX; touchStartPos.y = touches[0].clientY;
                
                const mouse = getNormalizedPointer(event);
                raycaster.setFromCamera(mouse, camera);

                touchDownTimer = setTimeout(() => {
                    touchMode = 'long-press';
                    const intersects = raycaster.intersectObjects([...obstacles, ...lights], true); // recursive=trueを追加
                    if (intersects.length > 0) {
                        deleteObject(intersects[0].object);
                    }
                }, LONG_PRESS_THRESHOLD);

                const allClickable = [...obstacles, ...spawnMeshes, ...lights];
                const intersects = raycaster.intersectObjects(allClickable);

                if (intersects.length > 0) {
                    isDragging = true; // すぐにドラッグ開始
                    setSelected(intersects[0].object);
                } else {
                    isDragging = false;
                }

            } else if (touches.length === 2) {
                touchMode = 'two-finger-pan';
                isPanning = true;
                panStart.set((touches[0].clientX + touches[1].clientX) / 2, (touches[0].clientY + touches[1].clientY) / 2);
                initialPinchDistance = getPinchDistance(touches);
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            const touches = event.touches;
            
            if (touchMode === 'long-press') return;

            // ドラッグ判定の閾値を超えたら長押しタイマーをキャンセル
            if (touchMode === 'single-tap-drag') {
                const deltaX = touches[0].clientX - touchStartPos.x;
                const deltaY = touches[0].clientY - touchStartPos.y;
                if (Math.hypot(deltaX, deltaY) > 10) { 
                    clearTimeout(touchDownTimer); 
                }
            }

            if (isDragging && selectedObject && touches.length === 1) {
                const mouse = getNormalizedPointer(event);
                raycaster.setFromCamera(mouse, camera);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                const snappedX = snapToGrid(intersection.x);
                const snappedZ = snapToGrid(intersection.z);

                if (Math.hypot(snappedX, snappedZ) < ARENA_RADIUS) { 
                    selectedObject.position.set(snappedX, selectedObject.position.y, snappedZ);
                    if (selectedObject.userData.type === 'spawn') {
                        const data = SPAWN_POINTS_DATA.find(d => d.id === selectedObject.userData.id);
                        if (data) {
                            data.x = snappedX;
                            data.z = snappedZ;
                            document.getElementById('spawn-x').textContent = snappedX.toFixed(2);
                            document.getElementById('spawn-z').textContent = snappedZ.toFixed(2);
                        }
                    } else if (selectedObject.userData.type === 'light') {
                        selectedObject.userData.light.position.copy(selectedObject.position);
                    }
                }
            } else if (isPanning && touches.length === 2) {
                clearTimeout(touchDownTimer);
                touchMode = 'two-finger-pan'; 
                const canvasBounds = renderer.domElement.getBoundingClientRect();

                // Pinch-to-Zoom
                const currentDistance = getPinchDistance(touches);
                const deltaDistance = initialPinchDistance - currentDistance;
                if (Math.abs(deltaDistance) > 3) {
                    const zoomFactor = 1.0 + (deltaDistance / 200);
                    initialFrustumSize = Math.max(50, Math.min(400, initialFrustumSize * zoomFactor));
                    initialPinchDistance = currentDistance; 
                    onWindowResize();
                } 
                
                // Pan
                const newCenterX = (touches[0].clientX + touches[1].clientX) / 2;
                const newCenterY = (touches[0].clientY + touches[1].clientY) / 2;
                const deltaX = newCenterX - panStart.x;
                const deltaY = newCenterY - panStart.y;
                panStart.set(newCenterX, newCenterY);
                
                const panFactorX = (camera.right - camera.left) / canvasBounds.width;
                const panFactorY = (camera.top - camera.bottom) / canvasBounds.height;
                
                cameraTarget.x -= deltaX * panFactorX;
                cameraTarget.z -= deltaY * panFactorY; // Y軸の動きをZ軸に正しく反映
                
                const maxPanRadius = ARENA_RADIUS / 2;
                if (cameraTarget.length() > maxPanRadius) {
                    cameraTarget.normalize().multiplyScalar(maxPanRadius);
                }
                updateCameraPosition();
            }
        }

        function onTouchEnd(event) {
            clearTimeout(touchDownTimer);

            // 短いタップ(ドラッグなし)の場合はオブジェクト追加/選択
            if (touchMode === 'single-tap-drag' && Math.hypot(event.changedTouches[0].clientX - touchStartPos.x, event.changedTouches[0].clientY - touchStartPos.y) < 15) { 
                const mouse = getNormalizedPointer(event.changedTouches[0]);
                raycaster.setFromCamera(mouse, camera);
                const allClickable = [...obstacles, ...spawnMeshes, ...lights];
                
                const intersects = raycaster.intersectObjects(allClickable);
                if (intersects.length > 0) {
                    // isDraggingがtrueの場合、これはドラッグ終了なので選択状態は維持
                    // isDraggingがfalseの場合、これは純粋なタップなので選択
                    if (!isDragging) {
                        setSelected(intersects[0].object);
                    }
                } else {
                    setSelected(null);
                    const floorIntersects = raycaster.intersectObject(floor);
                    if (floorIntersects.length > 0) handleObjectAddition(floorIntersects[0].point);
                }
            }
            
            isDragging = false; 
            isPanning = false; 
            touchMode = 'none';
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.hypot(dx, dy); // Math.hypot を使用
        }

        // 追加: Deleteキーによるオブジェクト削除
        function onKeyDown(event) {
            if (event.key === 'Delete' && selectedObject) {
                deleteObject(selectedObject); // ロジックを一元化
            }
        }
        
        // --- Boilerplate ---

        function onWindowResize() {
            const currentWidth = canvasContainer.clientWidth;
            const currentHeight = canvasContainer.clientHeight;
            aspect = currentWidth / currentHeight;
            camera.left = initialFrustumSize * aspect / -2;
            camera.right = initialFrustumSize * aspect / 2;
            camera.top = initialFrustumSize / 2; 
            camera.bottom = initialFrustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(currentWidth, currentHeight);
        }
        
        // --- Event Listeners Setup ---
        function setupEventListeners() {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('contextmenu', e => e.preventDefault());
            renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('save-map-button').addEventListener('click', saveMap);
            document.getElementById('load-map-button').addEventListener('click', loadMap);
            document.getElementById('delete-map-button').addEventListener('click', deleteMap);
            document.getElementById('reset-button').addEventListener('click', () => resetMap(true));
            document.getElementById('apply-props-button').addEventListener('click', applyProperties);
            document.getElementById('apply-light-props-button').addEventListener('click', applyLightProperties); // 追加
            document.getElementById('prop-color').addEventListener('input', onColorChange);
            document.getElementById('add-obstacle-button').addEventListener('click', () => setAddingMode('obstacle')); // 追加
            document.getElementById('add-light-button').addEventListener('click', () => setAddingMode('light')); // 追加
            document.getElementById('add-tower-button').addEventListener('click', () => setAddingMode('tower')); // 追加
            document.getElementById('add-house-button').addEventListener('click', () => setAddingMode('house')); // 追加
            document.getElementById('export-file-button').addEventListener('click', exportMapToFile);
            document.getElementById('import-file-button').addEventListener('click', () => document.getElementById('import-file-input').click());
            document.getElementById('import-file-input').addEventListener('change', importMapFromFile);
            
            const uiContainer = document.getElementById('ui-container');
            uiContainer.addEventListener('mousedown', e => e.stopPropagation());
            uiContainer.addEventListener('touchstart', e => e.stopPropagation(), { passive: false });
        }
        
        // --- Initialization ---
        function init() {
            setupEventListeners();
            loadRecentColors();
            renderRecentColors();
            updateSavedMapsSelect();
            setAddingMode('obstacle'); // 初期モードを設定
            
            // 初回ロード - 最初のマップがあればそれをロード
            if (Object.keys(allCustomMaps).length > 0) {
                const firstMapName = Object.keys(allCustomMaps)[0];
                document.getElementById('saved-maps-select').value = firstMapName;
                loadMap();
            } else {
                resetMap(); // なければ新規マップを作成
            }
            onWindowResize(); // 初期サイズ設定
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        init(); // 初期化関数を呼び出す
    </script>
</body>
</html>
