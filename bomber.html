<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>爆撃ゲーム</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
      background: transparent;
      touch-action: manipulation;
    }

    #stageLabel {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 20px;
      color: white;
      z-index: 5;
    }

    #startScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #DEB887;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 60px;
      z-index: 10;
    }

    #startImage {
      max-width: 80%;
      height: auto;
      margin-bottom: 40px;
    }

    #startButton {
      position: absolute;
      bottom: 15%;
      font-size: 24px;
      padding: 12px 24px;
      background: #6E6E4B;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <div id="stageLabel">Stage 1</div>

  <div id="startScreen">
    <img src="bomber.png" id="startImage" />
    <button id="startButton">爆撃開始</button>
  </div>

  <canvas id="canvas"></canvas>

  <audio id="downSound" src="down.mp3" preload="auto"></audio>
  <audio id="expSound" src="exp.mp3" preload="auto"></audio>
  <audio id="expbmSound" src="expbm.mp3" preload="auto"></audio>
  <audio id="bgSound" src="29.mp3" preload="auto" loop></audio>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const downSound = document.getElementById("downSound");
    const expSound = document.getElementById("expSound");
    const expbmSound = document.getElementById("expbmSound");
    const bgSound = document.getElementById("bgSound");

    const bombs = [];
    const scars = [];
    const gravity = 0.02;
    const impactY = canvas.height * 0.75;
    const scrollSpeed = 0.5;

    const buildings = [];
    const tanks = [];
    const iGroup = [];
    let stage = 1;

    // 地面色の定義と現在の色
    const groundColors = ["#DEB887", "#228B22", "#A9A9A9"];
    let currentGroundColor = groundColors[0];

    // スマホ対応のスケール係数
    const scale = Math.min(window.innerWidth / 800, 1.5);

    function generateStageObjects() {
      buildings.length = 0;
      tanks.length = 0;
      iGroup.length = 0;

      currentGroundColor = groundColors[(stage - 1) % groundColors.length];

      for (let i = 0; i < 20 + stage * 2; i++) {
        buildings.push({
          x: Math.random() * canvas.width,
          y: -i * 180 * scale,
          w: (40 + Math.random() * 40) * scale,
          h: (60 + Math.random() * 60) * scale,
          color: "#888888",
          destroyed: false,
          opacity: 1.0,
          visible: true
        });
      }

      for (let i = 0; i < 5 + stage; i++) {
        tanks.push({
          x: Math.random() * (canvas.width - 20 * scale),
          y: -i * 400 * scale - 200 * scale,
          w: 20 * scale, h: 30 * scale,
          turretW: 14 * scale, turretH: 14 * scale,
          barrelW: 4 * scale, barrelH: 14 * scale,
          speed: 0.8 + Math.random() * 1.2,
          destroyed: false,
          opacity: 1.0,
          visible: true,
          stoppedBy: null
        });
      }

      for (let i = 0; i < 6 + stage; i++) {
        iGroup.push({
          x: canvas.width / 2 + (Math.random() * 60 - 30) * scale,
          y: -i * 100 * scale - 100 * scale,
          fontSize: 20 * scale,
          speed: scrollSpeed + Math.random() * 0.3,
          destroyed: false,
          opacity: 1.0,
          visible: true,
          stoppedBy: null
        });
      }

      document.getElementById("stageLabel").textContent = `Stage ${stage}`;
    }
    document.getElementById("startButton").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      bgSound.volume = 0.4;
      bgSound.play();
      generateStageObjects();
      loop(); // ゲーム開始
    });

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const tapX = e.clientX - rect.left;

      bombs.push({
        x: tapX,
        y: canvas.height * 0.3,
        size: 40 * scale,
        vy: 0,
        exploded: false,
        explosionSize: 0,
        explosionY: null,
        opacity: 1.0,
        soundPlayed: false,
        hitTarget: false
      });

      downSound.currentTime = 0;
      downSound.play();
    });

    function checkStageClear() {
      const allDestroyed =
        buildings.every(b => b.destroyed) &&
        tanks.every(t => t.destroyed) &&
        iGroup.every(i => i.destroyed);

      if (allDestroyed) {
        stage++;
        generateStageObjects();
      }
    }

    function drawGround() {
      ctx.fillStyle = currentGroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height); // ← 全面塗りつぶしでズレ防止
    }

    function drawScars() {
      scars.forEach(scar => {
        scar.y += scrollSpeed;
        ctx.save();
        ctx.globalAlpha = scar.opacity;
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(scar.x, scar.y, scar.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    function drawBuildings() {
      buildings.forEach(b => {
        if (!b.visible) return;
        b.y += scrollSpeed;
        if (b.y > canvas.height + b.h && !b.destroyed) {
          b.y = -150 * scale;
          b.x = Math.random() * canvas.width;
        }
        if (b.destroyed) {
          b.opacity -= 0.02;
          if (b.opacity <= 0) {
            b.visible = false;
            return;
          }
        }
        ctx.save();
        ctx.globalAlpha = b.opacity;
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.restore();
      });
    }

    function drawTanks() {
      tanks.forEach(t => {
        if (!t.visible) return;

        if (t.stoppedBy && t.stoppedBy.destroyed) {
          t.speed = 0.8 + Math.random() * 1.2;
          t.stoppedBy = null;
        }

        t.y += t.speed;

        buildings.forEach(b => {
          if (!b.visible || b.destroyed) return;
          const overlap =
            t.x < b.x + b.w &&
            t.x + t.w > b.x &&
            t.y < b.y + b.h &&
            t.y + t.h > b.y;
          if (overlap) {
            t.speed = scrollSpeed;
            t.stoppedBy = b;
          }
        });

        if (t.y > canvas.height + t.h && !t.destroyed) {
          t.y = -200 * scale;
          t.x = Math.random() * canvas.width;
          t.speed = 0.8 + Math.random() * 1.2;
          t.stoppedBy = null;
        }

        if (t.destroyed) {
          t.opacity -= 0.02;
          if (t.opacity <= 0) {
            t.visible = false;
            return;
          }
        }

        ctx.save();
        ctx.globalAlpha = t.opacity;
        ctx.fillStyle = "#9A9A6E";
        ctx.fillRect(t.x, t.y, t.w, t.h);
        const turretX = t.x + t.w / 2 - t.turretW / 2;
        const turretY = t.y + t.h / 2 - t.turretH / 2;
        ctx.fillStyle = "#6E6E4B";
        ctx.fillRect(turretX, turretY, t.turretW, t.turretH);
        const barrelX = turretX + t.turretW / 2 - t.barrelW / 2;
        const barrelY = turretY + t.turretH;
        ctx.fillRect(barrelX, barrelY, t.barrelW, t.barrelH);
        ctx.restore();
      });
    }

    function drawIGroup() {
      iGroup.forEach(i => {
        if (!i.visible) return;

        if (i.stoppedBy && i.stoppedBy.destroyed) {
          i.speed = scrollSpeed + Math.random() * 0.3;
          i.stoppedBy = null;
        }

        i.y += i.speed;

        buildings.forEach(b => {
          if (!b.visible || b.destroyed) return;
          const overlap =
            i.x < b.x + b.w &&
            i.x + 10 * scale > b.x &&
            i.y < b.y + b.h &&
            i.y + 20 * scale > b.y;
          if (overlap) {
            i.speed = scrollSpeed;
            i.stoppedBy = b;
          }
        });

        if (i.y > canvas.height + 20 * scale && !i.destroyed) {
          i.y = -100 * scale;
          i.x = canvas.width / 2 + (Math.random() * 60 - 30) * scale;
          i.stoppedBy = null;
        }

        if (i.destroyed) {
          i.opacity -= 0.02;
          if (i.opacity <= 0) {
            i.visible = false;
            return;
          }
        }

        ctx.save();
        ctx.globalAlpha = i.opacity;
        ctx.fillStyle = "#6E6E4B";
        ctx.font = `bold ${i.fontSize}px sans-serif`;
        ctx.fillText("i", i.x, i.y);
        ctx.restore();
      });
    }
    function updateBombs() {
      bombs.forEach(bomb => {
        if (!bomb.exploded) {
          bomb.vy += gravity;
          bomb.y += bomb.vy;
          bomb.size *= 0.98;

          if (bomb.y >= impactY) {
            bomb.y = impactY;
            bomb.exploded = true;
            bomb.explosionSize = bomb.size * 1.5;
            bomb.explosionY = impactY;

            let hit = false;
            [...buildings, ...tanks, ...iGroup].forEach(obj => {
              if (!obj.visible) return;
              const ox = obj.x + (obj.w ? obj.w / 2 : 0);
              const oy = obj.y + (obj.h ? obj.h / 2 : 10 * scale);
              const dx = bomb.x - ox;
              const dy = bomb.explosionY - oy;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < 50 * scale) {
                obj.destroyed = true;
                bomb.hitTarget = true;
                hit = true;
              }
            });

            scars.push({ x: bomb.x, y: impactY, size: 10 * scale, opacity: 0.6 });

            if (!bomb.soundPlayed) {
              if (hit) {
                expbmSound.currentTime = 0;
                expbmSound.play();
              } else {
                expSound.currentTime = 0;
                expSound.play();
              }
              bomb.soundPlayed = true;
            }
          }

          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.y, bomb.size, 0, Math.PI * 2);
          ctx.fill();
        } else if (bomb.opacity > 0) {
          bomb.explosionSize += 2 * scale;
          bomb.explosionY += scrollSpeed;
          bomb.opacity -= 0.01;
          ctx.save();
          ctx.globalAlpha = bomb.opacity;
          ctx.fillStyle = bomb.hitTarget ? "orange" : "yellow";
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.explosionY, bomb.explosionSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      });
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGround();
      drawScars();
      drawBuildings();
      drawTanks();
      drawIGroup();
      updateBombs();
      checkStageClear();
      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>