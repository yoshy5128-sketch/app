<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Three.js Drive - Pure Chase Battle</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; }
    #msg { position: absolute; top: 40%; width: 100%; text-align: center; color: #ff3333; font-family: sans-serif; font-size: 40px; font-weight: bold; text-shadow: 2px 2px 0 #000; display: none; pointer-events: none; }
    .touch-area { position: absolute; top: 0; width: 50%; height: 100%; z-index: 1000; display: none; }
    .touch-left { left: 0; }
    .touch-right { right: 0; }
    @media (pointer: coarse) { .touch-area { display: block; } }
    #fullscreenButton { position: absolute; top: 15px; left: 15px; font-family: sans-serif; font-size: 24px; color: #fff; background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 8px; cursor: pointer; user-select: none; z-index: 1010; line-height: 1; }
    
    /* 修正箇所：ズームスライダーを右端に寄せる */
    #zoomSlider { position: absolute; right: -75px; top: 50%; transform: translateY(-50%) rotate(-90deg); width: 200px; height: 10px; -webkit-appearance: none; background: rgba(255, 255, 255, 0.3); outline: none; border-radius: 5px; opacity: 0.7; transition: opacity .2s; z-index: 1010; }
    #zoomSlider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #4CAF50; cursor: pointer; }
    
    @media (pointer: coarse) { #zoomSlider { display: block; } }
    #hud { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 40px; color: white; font-family: sans-serif; font-weight: bold; text-shadow: 2px 2px 2px #000; pointer-events: none; z-index: 1010; }
</style>
</head>
<body>

<div id="hud">
    <div>PLAYER HP: <span id="p-hp">100</span></div>
    <div>ENEMY HP: <span id="e-hp">100</span></div>
</div>
<div id="msg">ENEMY DESTROYED!</div>
<div class="touch-area touch-left"></div>
<div class="touch-area touch-right"></div>
<div id="fullscreenButton">★</div>
<input type="range" id="zoomSlider" min="0" max="2" step="0.01" value="0.8">

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// --- 設定 ---
const MAX_SPEED = 4.0, ACCEL = 0.15, FRICTION = 0.96, GRAVITY = 0.1;
const MAX_ZOOM_LEVEL = 2.0;

function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.maxTouchPoints > 0) || window.matchMedia('(pointer: coarse)').matches;
}

// --- 基本構築 ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

function updateCamera() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const aspect = width / height;
    renderer.setSize(width, height);
    camera.aspect = aspect;
    const baseFov = 75; 
    if (aspect < 1) {
        const radHov = 2 * Math.atan(Math.tan((baseFov * Math.PI / 180) / 2) / aspect);
        camera.fov = radHov * 180 / Math.PI;
    } else { camera.fov = baseFov; }
    camera.updateProjectionMatrix();
}
window.addEventListener('resize', updateCamera);
updateCamera();

scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const sun = new THREE.DirectionalLight(0xffffff, 1.5);
sun.position.set(100, 150, 100);
sun.castShadow = true;
sun.shadow.camera.left = -100; sun.shadow.camera.right = 100;
sun.shadow.camera.top = 100; sun.shadow.camera.bottom = -100;
sun.shadow.mapSize.set(2048, 2048);
scene.add(sun);

const mirrorCamera = new THREE.PerspectiveCamera(40, 3.0, 0.1, 500);
const mirrorRenderTarget = new THREE.WebGLRenderTarget(256, 85);
const mirrorMaterial = new THREE.MeshBasicMaterial({ map: mirrorRenderTarget.texture });
const mirrorMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.25, 0.08), mirrorMaterial);
scene.add(mirrorMesh);

function getHeight(x, z) {
    return Math.sin(x * 0.04) * 5 + Math.cos(z * 0.03) * 7 + Math.sin((x + z) * 0.02) * 4;
}

const chunks = new Map();
function updateChunks(px, pz) {
    const cx = Math.floor(px/400), cz = Math.floor(pz/400);
    for(let x=cx-1; x<=cx+1; x++) {
        for(let z=cz-1; z<=cz+1; z++) {
            const key = `${x},${z}`;
            if(!chunks.has(key)) {
                const geo = new THREE.PlaneGeometry(400, 400, 40, 40); geo.rotateX(-Math.PI/2);
                const pos = geo.attributes.position;
                for(let i=0; i<pos.count; i++) pos.setY(i, getHeight(pos.getX(i)+x*400, pos.getZ(i)+z*400));
                geo.computeVertexNormals();
                const m = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x998877, roughness: 0.8, metalness: 0.2 }));
                m.position.set(x*400, 0, z*400); m.receiveShadow = true;
                scene.add(m); chunks.set(key, m);
            }
        }
    }
}

const particles = [];
function spawnDust(pos, isSpark = false, isSmoke = false) {
    let color = isSpark ? 0xffffff : 0xd2c08a; 
    if (isSmoke) color = 0x333333;
    const size = isSpark ? 0.2 : (isSmoke ? 0.6 : (0.4 + Math.random() * 0.4));
    const p = new THREE.Mesh(new THREE.SphereGeometry(size, 4, 4), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.6 }));
    p.position.copy(pos);
    const spread = isSpark ? 0.5 : 0.3;
    const vel = isSmoke ? new THREE.Vector3((Math.random()-0.5)*0.2, 0.2+Math.random()*0.2, (Math.random()-0.5)*0.2) : new THREE.Vector3((Math.random()-0.5)*spread, Math.random()*0.5 + 0.2, (Math.random()-0.5)*spread);
    p.userData = { life: 1.0, vel: vel, type: isSmoke ? 'smoke' : 'dust' };
    scene.add(p); particles.push(p);
}

function spawnDebris(pos, color, scale, count = 5) {
    const geo = new THREE.BoxGeometry(scale, scale, scale);
    const mat = new THREE.MeshStandardMaterial({ color: color });
    for(let i=0; i<count; i++) {
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*2, (Math.random())*2, (Math.random()-0.5)*2));
        p.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
        p.userData = { life: 1.0 + Math.random(), vel: new THREE.Vector3((Math.random()-0.5)*1.5, Math.random()*0.8 + 0.5, (Math.random()-0.5)*1.5), rot: new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5), type: 'debris' };
        scene.add(p); particles.push(p);
    }
}

function createCar(color) {
    const group = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.5 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1, 4.5), bodyMat);
    body.position.y = 1.0; body.castShadow = true; body.receiveShadow = true; group.add(body);
    const wheels = [];
    [[1.4,0.6,1.8],[-1.4,0.6,1.8],[1.4,0.6,-1.8],[-1.4,0.6,-1.8]].forEach(off => {
        const w = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,0.5,12).rotateZ(Math.PI/2), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        w.position.set(...off); w.castShadow = true; group.add(w); wheels.push(w);
    });
    return { group, wheels, body, bodyMat, color, hp: 100, dead: false };
}

const player = { ...createCar(0xff3333), speed: 0, lastSpeed: 0, vY: 0, yaw: 0, pitch: 0, roll: 0, impactV: new THREE.Vector3() };
scene.add(player.group);

let enemy = initEnemy(0x3366ff);
let enemyRespawnTimer = 0;

function initEnemy(color) {
    const ent = { ...createCar(color), speed: 0, lastSpeed: 0, yaw: 0, pitch: 0, roll: 0, attackTimer: 0, mode: 'follow', active: true, impactV: new THREE.Vector3() };
    ent.group.position.set(20, 5, 50); 
    scene.add(ent.group);
    return ent;
}

function destroyEnemy() {
    if(!enemy.active || enemy.dead) return;
    enemy.dead = true; enemy.hp = 0;
    enemy.bodyMat.color.set(0x000000);
    spawnDebris(enemy.group.position, 0x000000, 0.8, 30);
    spawnDebris(enemy.group.position, 0xffaa00, 1.5, 15);
    const msg = document.getElementById('msg');
    msg.style.display = 'block'; msg.innerText = "ENEMY DESTROYED!";
    setTimeout(() => {
        msg.style.display = 'none';
        scene.remove(enemy.group);
        enemy.active = false; enemyRespawnTimer = 150;
    }, 4000);
}

let audioCtx, pOsc, pGain;
function initAudio() {
    if (audioCtx) return;
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return; }
    pOsc = audioCtx.createOscillator(); pOsc.type = 'sawtooth'; pGain = audioCtx.createGain(); pGain.gain.value = 0;
    pOsc.connect(pGain).connect(audioCtx.destination); pOsc.start();
}

const keys = {};
window.addEventListener("keydown", e => { keys[e.code] = true; initAudio(); if(audioCtx) audioCtx.resume(); });
window.addEventListener("keyup", e => { keys[e.code] = false; });

let lookYaw = 0, lookPitch = 0, zoomLevel = isMobile() ? 0.8 : 0.5, smoothedCamPos = new THREE.Vector3();
let touchState = { left: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 }, right: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 } };

addEventListener("wheel", e => { zoomLevel = Math.max(0, Math.min(MAX_ZOOM_LEVEL, zoomLevel + e.deltaY*0.001)); }, {passive:true});
renderer.domElement.addEventListener("mousedown", () => {
    renderer.domElement.requestPointerLock();
    initAudio(); if(audioCtx) audioCtx.resume();
});
document.addEventListener("mousemove", e => { if (document.pointerLockElement === renderer.domElement) { lookYaw -= e.movementX * 0.003; lookPitch = Math.max(-0.6, Math.min(0.6, lookPitch - e.movementY * 0.003)); } });

document.getElementById('fullscreenButton').addEventListener('click', () => {
    if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
    else if (document.documentElement.webkitRequestFullscreen) document.documentElement.webkitRequestFullscreen();
    if (screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(() => {});
    setTimeout(updateCamera, 300);
});

const zoomSlider = document.getElementById('zoomSlider');
zoomSlider.value = zoomLevel.toString();
zoomSlider.addEventListener('input', e => { zoomLevel = parseFloat(e.target.value); });

const touchLeft = document.querySelector('.touch-left');
const touchRight = document.querySelector('.touch-right');
touchLeft.addEventListener('touchstart', e => { e.preventDefault(); const t = e.touches[0]; touchState.left = { active: true, startX: t.clientX, startY: t.clientY, currentX: t.clientX, currentY: t.clientY }; initAudio(); if(audioCtx) audioCtx.resume(); }, {passive:false});
touchLeft.addEventListener('touchmove', e => { e.preventDefault(); const t = e.touches[0]; touchState.left.currentX = t.clientX; touchState.left.currentY = t.clientY; }, {passive:false});
touchLeft.addEventListener('touchend', e => { e.preventDefault(); touchState.left.active = false; keys.KeyW = keys.KeyS = keys.KeyA = keys.KeyD = false; }, {passive:false});
touchRight.addEventListener('touchstart', e => { e.preventDefault(); const t = e.touches[0]; touchState.right = { active: true, startX: t.clientX, startY: t.clientY, currentX: t.clientX, currentY: t.clientY }; }, {passive:false});
touchRight.addEventListener('touchmove', e => { e.preventDefault(); const t = e.touches[0]; touchState.right.currentX = t.clientX; touchState.right.currentY = t.clientY; }, {passive:false});
touchRight.addEventListener('touchend', e => { e.preventDefault(); touchState.right.active = false; }, {passive:false});

function animate() {
    requestAnimationFrame(animate);
    const now = audioCtx ? audioCtx.currentTime : 0;
    updateChunks(player.group.position.x, player.group.position.z);
    sun.position.set(player.group.position.x + 50, 150, player.group.position.z + 50);
    sun.target = player.group;

    for(let i = particles.length - 1; i >= 0; i--){
        const p = particles[i]; p.userData.life -= 0.015;
        p.position.add(p.userData.vel);
        if (p.userData.type === 'debris') {
            p.rotation.x += p.userData.rot.x; p.userData.vel.y -= 0.02;
            const h = getHeight(p.position.x, p.position.z);
            if(p.position.y < h) { p.position.y = h; p.userData.vel.y *= -0.5; }
            p.scale.setScalar(p.userData.life * (p.geometry.parameters.width || 0.5));
        } else {
            p.scale.setScalar(p.userData.type === 'smoke' ? (1 + (1.0 - p.userData.life) * 3) : (1 + (1.0 - p.userData.life) * 4)); 
            p.material.opacity = p.userData.life * 0.6;
        }
        if(p.userData.life <= 0){ scene.remove(p); particles.splice(i, 1); }
    }

    if (!enemy.active && enemyRespawnTimer > 0) {
        enemyRespawnTimer--;
        if (enemyRespawnTimer <= 0) {
            enemy = initEnemy([0xff00ff, 0xffff00, 0x00ff00, 0xffffff][Math.floor(Math.random()*4)]);
            enemy.group.position.copy(player.group.position).add(new THREE.Vector3(Math.sin(player.yaw)*-30, 0, Math.cos(player.yaw)*-30));
            enemy.yaw = player.yaw; enemy.speed = Math.abs(player.speed) * 1.5;
            const msg = document.getElementById('msg'); msg.style.display = 'block'; msg.innerText = "NEW CHALLENGER!"; msg.style.color = "#ffff00";
            setTimeout(() => msg.style.display = 'none', 1500);
        }
    }

    const entities = [player];
    if(enemy.active) entities.push(enemy);

    entities.forEach(ent => {
        const isP = (ent === player);
        const isE = (ent === enemy);
        if (ent.dead) {
            ent.speed = 0; if (Math.random() > 0.8) spawnDust(ent.group.position.clone().add(new THREE.Vector3(0,1,0)), false, true);
        } else if (ent.hp <= 30) {
            if (Math.random() > 0.9) spawnDust(ent.group.position.clone().add(new THREE.Vector3(0,1,0)), false, true);
        }

        ent.lastSpeed = ent.speed;
        if(isP && !ent.dead) {
            if(keys.KeyW) ent.speed -= ACCEL; if(keys.KeyS) ent.speed += ACCEL;
            if(keys.KeyA) ent.yaw += 0.05; if(keys.KeyD) ent.yaw -= 0.05;
            if (touchState.left.active) {
                const dy = touchState.left.currentY - touchState.left.startY;
                const dx = touchState.left.currentX - touchState.left.startX;
                if (dy < -20) ent.speed -= ACCEL; else if (dy > 20) ent.speed += ACCEL;
                if (dx < -20) ent.yaw += 0.05; else if (dx > 20) ent.yaw -= 0.05;
            }
            if (touchState.right.active) {
                // 修正箇所：右画面タッチによる視点操作を復旧
                lookYaw -= (touchState.right.currentX - touchState.right.startX) * 0.003;
                lookPitch = Math.max(-0.6, Math.min(0.6, lookPitch - (touchState.right.currentY - touchState.right.startY) * 0.003));
                touchState.right.startY = touchState.right.currentY; 
                touchState.right.startX = touchState.right.currentX;
            }
            ent.speed *= FRICTION;
            ent.group.position.add(ent.impactV);
        } else if (isE && !ent.dead) {
            const toPlayer = new THREE.Vector3().subVectors(player.group.position, ent.group.position);
            const dist = toPlayer.length();
            ent.attackTimer += 0.01;
            if (dist > 50) ent.mode = 'follow'; else if (ent.attackTimer % 12 < 5) ent.mode = 'follow'; else if (ent.attackTimer % 12 < 9) ent.mode = 'side_press'; else ent.mode = 'block';
            let tYaw = Math.atan2(toPlayer.x, toPlayer.z);
            let tSpeed = Math.abs(player.speed);
            if (ent.mode === 'side_press') {
                tSpeed = Math.abs(player.speed) + 0.3;
                const side = Math.sin(ent.attackTimer * 0.2) > 0 ? 1 : -1;
                const offset = new THREE.Vector3(Math.cos(player.yaw)*side*3, 0, Math.sin(player.yaw)*side*3);
                const attackPos = player.group.position.clone().add(offset);
                const toAttack = new THREE.Vector3().subVectors(attackPos, ent.group.position);
                tYaw = Math.atan2(toAttack.x, toAttack.z);
            } else if (ent.mode === 'block') {
                tSpeed = Math.abs(player.speed) + 0.5;
                const frontPos = player.group.position.clone().add(new THREE.Vector3(Math.sin(player.yaw)*12, 0, Math.cos(player.yaw)*12));
                const toFront = new THREE.Vector3().subVectors(frontPos, ent.group.position);
                tYaw = Math.atan2(toFront.x, toFront.z);
            } else { tSpeed = dist > 15 ? Math.abs(player.speed) + 0.4 : Math.abs(player.speed) - 0.3; }
            ent.speed = THREE.MathUtils.lerp(ent.speed, tSpeed, 0.015);
            let dy = tYaw - ent.yaw;
            while(dy < -Math.PI) dy += Math.PI*2; while(dy > Math.PI) dy -= Math.PI*2;
            if (ent.impactV.length() > 0.1) { ent.group.position.add(ent.impactV); ent.impactV.multiplyScalar(0.9); } else { ent.yaw += dy * 0.018; }
        }

        if (!ent.dead) ent.group.position.addScaledVector(new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), ent.yaw), ent.speed);
        
        const fD = 2.2;
        const hF = getHeight(ent.group.position.x + Math.sin(ent.yaw)*fD, ent.group.position.z + Math.cos(ent.yaw)*fD);
        const hB = getHeight(ent.group.position.x - Math.sin(ent.yaw)*fD, ent.group.position.z - Math.cos(ent.yaw)*fD);
        const avgY = (hF + hB) / 2 + 0.2;
        if(isP) { ent.vY -= GRAVITY; ent.group.position.y += ent.vY; if(ent.group.position.y <= avgY) { ent.group.position.y = avgY; ent.vY = 0; } } else { ent.group.position.y = avgY; }
        ent.pitch = THREE.MathUtils.lerp(ent.pitch, Math.atan2(hB-hF, fD*2) + (ent.speed - ent.lastSpeed)*8.0, 0.15);
        ent.roll = THREE.MathUtils.lerp(ent.roll, (isP && keys.KeyA ? -0.2 : (isP && keys.KeyD ? 0.2 : 0)), 0.1);
        ent.group.quaternion.setFromEuler(new THREE.Euler(ent.pitch, ent.yaw, ent.roll, 'YXZ'));
        ent.wheels.forEach(w => w.rotation.x += ent.speed * 0.8);

        // 修正箇所：タイヤからの砂煙パーティクル生成を復旧
        if(!ent.dead && Math.abs(ent.speed) > 0.5 && ent.group.position.y <= avgY + 0.5) {
            [[-1.2,0,-1.5], [1.2,0,-1.5]].forEach(off => {
                const wPos = new THREE.Vector3(...off).applyQuaternion(ent.group.quaternion).add(ent.group.position);
                if(Math.random() > 0.5) spawnDust(wPos);
            });
        }
    });

    if (enemy.active && !player.dead && !enemy.dead) {
        const dist = player.group.position.distanceTo(enemy.group.position);
        if (dist < 3.5) {
            const dirP2E = new THREE.Vector3().subVectors(enemy.group.position, player.group.position).normalize();
            const pMove = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw)).multiplyScalar(-player.speed);
            const eMove = new THREE.Vector3(Math.sin(enemy.yaw), 0, Math.cos(enemy.yaw)).multiplyScalar(enemy.speed);
            const pAtkForce = pMove.dot(dirP2E);
            const eAtkForce = eMove.dot(dirP2E.clone().negate());
            player.impactV.add(dirP2E.clone().multiplyScalar(-1.2));
            enemy.impactV.add(dirP2E.clone().multiplyScalar(1.2));
            if (pAtkForce > eAtkForce + 0.3) { enemy.hp -= 20; spawnDust(enemy.group.position, true); }
            else if (eAtkForce > pAtkForce + 0.3) { player.hp -= 20; spawnDust(player.group.position, true); }
            document.getElementById('p-hp').innerText = Math.max(0, player.hp);
            document.getElementById('e-hp').innerText = Math.max(0, enemy.hp);
            if (enemy.hp <= 0) destroyEnemy();
            if (player.hp <= 0) { player.dead = true; player.bodyMat.color.set(0x000000); document.getElementById('msg').innerText = "GAME OVER"; document.getElementById('msg').style.display = 'block'; setTimeout(() => location.reload(), 5000); }
        }
    }
    player.impactV.multiplyScalar(0.92);

    const cockpitPos = new THREE.Vector3(0, 2.4, 0.5);
    const tpsPos = new THREE.Vector3(0, 4.5, 12);
    const dronePos = new THREE.Vector3(0, 70, 150);
    let currentOffset;
    if (zoomLevel <= 1.0) { currentOffset = new THREE.Vector3().lerpVectors(cockpitPos, tpsPos, zoomLevel); } 
    else { currentOffset = new THREE.Vector3().lerpVectors(tpsPos, dronePos, Math.min(1.0, (zoomLevel - 1.0) / (MAX_ZOOM_LEVEL - 1.0))); }

    const baseQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, player.yaw, 0));
    const mouseQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(lookPitch, lookYaw, 0, 'YXZ'));
    let finalQuat;
    if (zoomLevel <= 1.0) { finalQuat = new THREE.Quaternion().slerpQuaternions(player.group.quaternion.clone(), baseQuat, zoomLevel).multiply(mouseQuat); }
    else {
        const cameraPosForLookAt = player.group.position.clone().add(currentOffset.clone().applyQuaternion(baseQuat));
        const tempCam = new THREE.Camera(); tempCam.position.copy(cameraPosForLookAt); tempCam.lookAt(player.group.position);
        finalQuat = tempCam.quaternion.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, lookYaw, 0)));
    }
    const targetCamPos = player.group.position.clone().add(currentOffset.clone().applyQuaternion(finalQuat));
    smoothedCamPos.lerp(targetCamPos, zoomLevel < 0.15 ? 1.0 : (zoomLevel < 1.0 ? 0.2 : 0.3));
    camera.position.copy(smoothedCamPos); camera.quaternion.copy(finalQuat);

    if (zoomLevel < 0.15) {
        mirrorMesh.visible = true; mirrorMesh.position.copy(camera.position).add(new THREE.Vector3(0, 0.2, -0.4).applyQuaternion(camera.quaternion));
        mirrorMesh.quaternion.copy(camera.quaternion);
        mirrorCamera.position.copy(player.group.position).add(new THREE.Vector3(0, 2.6, 0).applyQuaternion(player.group.quaternion));
        mirrorCamera.quaternion.setFromEuler(new THREE.Euler(0, player.yaw + Math.PI, 0));
        renderer.setRenderTarget(mirrorRenderTarget); renderer.render(scene, mirrorCamera); renderer.setRenderTarget(null);
    } else { mirrorMesh.visible = false; }

    if(audioCtx && !player.dead) { pGain.gain.setTargetAtTime(0.3, now, 0.05); pOsc.frequency.setTargetAtTime(70 + Math.abs(player.speed) * 60, now, 0.05); }
    else if(pGain) { pGain.gain.setTargetAtTime(0, now, 0.05); }
    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
