<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ­ãƒ¼ã‚«ãƒ«MP3ã‚«ãƒƒã‚¿ãƒ¼ (ffmpeg.wasm)</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background-color: #f4f7f6; }
        .container { max-width: 800px; margin: auto; padding: 20px; background: white; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
        h2 { color: #007bff; border-bottom: 2px solid #007bff; padding-bottom: 10px; margin-bottom: 20px; }
        input[type="file"] { margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; width: 100%; box-sizing: border-box; }
        button { background-color: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; margin-top: 15px; }
        button:hover:not(:disabled) { background-color: #218838; }
        button:disabled { background-color: #90ee90; cursor: not-allowed; }
        .controls div { margin-bottom: 10px; }
        .log-area { margin-top: 20px; padding: 10px; background-color: #e9ecef; border: 1px solid #dee2e6; border-radius: 5px; max-height: 150px; overflow-y: scroll; font-size: 0.8em; }
        .processing { color: #ffc107; font-weight: bold; }
        .success { color: #28a745; font-weight: bold; }
        .error { color: #dc3545; font-weight: bold; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
const { useState, useEffect } = React;
// FFmpegã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œæˆ
// corePathã‚’è¨­å®šã™ã‚‹ã“ã¨ã§ã€ãƒ–ãƒ©ã‚¦ã‚¶ãŒffmpegã®WebAssemblyãƒã‚¤ãƒŠãƒªã‚’ãƒ­ãƒ¼ãƒ‰ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™
const ffmpeg = FFmpeg.createFFmpeg({
  log: true, // ãƒ­ã‚°å‡ºåŠ›ã‚’æœ‰åŠ¹ã«
  corePath: 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js',
});

// ç§’ã‚’HH:MM:SS.mså½¢å¼ã«å¤‰æ›ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
const formatTime = (seconds) => {
    const totalMilliseconds = seconds * 1000;
    const ms = String(Math.floor(totalMilliseconds % 1000)).padStart(3, '0');
    const totalSeconds = Math.floor(seconds);
    const s = String(totalSeconds % 60).padStart(2, '0');
    const m = String(Math.floor(totalSeconds / 60) % 60).padStart(2, '0');
    const h = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
    return `${h}:${m}:${s}.${ms}`;
};

function AudioEditor() {
  const [isReady, setIsReady] = useState(false);
  const [audioFile, setAudioFile] = useState(null);
  const [duration, setDuration] = useState(0);
  const [startTime, setStartTime] = useState(0);
  const [endTime, setEndTime] = useState(0);
  const [isProcessing, setIsProcessing] = useState(false);
  const [logMessages, setLogMessages] = useState([]);
  const [status, setStatus] = useState('FFmpegã®åˆæœŸåŒ–ä¸­...');
  
  // ãƒ­ã‚°ã®è¿½åŠ 
  const addLog = (message, type = 'info') => {
      setLogMessages(prev => [{ message, type, timestamp: new Date().toLocaleTimeString() }, ...prev]);
  };
  
  // FFmpegã®åˆæœŸåŒ–
  useEffect(() => {
    const loadFFmpeg = async () => {
      setStatus('FFmpegãƒã‚¤ãƒŠãƒªã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...');
      addLog('FFmpegã®åˆæœŸåŒ–ã‚’é–‹å§‹ã—ã¾ã™ã€‚');
      try {
        if (!ffmpeg.isLoaded()) {
          // ffmpegã®å®Ÿè¡Œã«ã¯äº‹å‰ã«load()ãŒå¿…è¦
          await ffmpeg.load();
        }
        setIsReady(true);
        setStatus('æº–å‚™å®Œäº†ï¼MP3ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚');
        addLog('FFmpegãŒæ­£å¸¸ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã—ãŸã€‚', 'success');
      } catch (e) {
        setStatus('FFmpegã®ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        addLog(`ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
      }
    };
    // ãƒ­ã‚°ãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
    ffmpeg.setLogger(({ message }) => {
        addLog(`[FFmpeg Log]: ${message}`);
    });
    
    loadFFmpeg();
  }, []);

  // Web Audio APIã‚’ä½¿ã£ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã®é•·ã•ã‚’å–å¾—ã™ã‚‹
  const getDuration = (file) => {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioContext.decodeAudioData(e.target.result, (buffer) => {
          resolve(buffer.duration);
        });
      };
      reader.readAsArrayBuffer(file);
    });
  };

  // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ãƒ©
  const handleFileUpload = async (event) => {
    const file = event.target.files[0];
    if (file && file.type === 'audio/mp3') {
        setStatus(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã‚’èª­ã¿è¾¼ã¿ä¸­...`);
        setAudioFile(file);
        
        const fileDuration = await getDuration(file);
        setDuration(fileDuration);
        setEndTime(fileDuration); // çµ‚äº†æ™‚é–“ã‚’æœ€å¤§ã«è¨­å®š
        setStartTime(0);
        setStatus(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã®èª­ã¿è¾¼ã¿å®Œäº†ã€‚é•·ã•: ${fileDuration.toFixed(2)}ç§’`);
    } else {
        alert('MP3ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
    }
  };

  // ã‚«ãƒƒãƒˆå‡¦ç†ã®å®Ÿè¡Œé–¢æ•°
  const executeCut = async () => {
    if (!audioFile || startTime >= endTime || startTime < 0 || endTime > duration) {
        alert('ç„¡åŠ¹ãªæ™‚é–“æŒ‡å®šã§ã™ã€‚é–‹å§‹æ™‚é–“ < çµ‚äº†æ™‚é–“ < å…¨é•·ã€ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        return;
    }

    setIsProcessing(true);
    setStatus('ğŸš€ ã‚«ãƒƒãƒˆå‡¦ç†ã‚’é–‹å§‹ã—ã¾ã—ãŸ...');
    const inputFileName = 'input.mp3';
    const outputFileName = 'output.mp3';

    try {
        addLog('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä»®æƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ (FS)ã«æ›¸ãè¾¼ã¿ä¸­...', 'processing');
        // 1. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä»®æƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ (FS)ã«æ›¸ãè¾¼ã‚€
        ffmpeg.FS('writeFile', inputFileName, await FFmpeg.fetchFile(audioFile));
        
        const ssTime = formatTime(startTime);
        const toTime = formatTime(endTime);
        
        addLog(`FFmpegã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ: -ss ${ssTime} -to ${toTime} -c copy`, 'processing');

        // 2. FFmpegã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ
        await ffmpeg.run(
            '-i', inputFileName,
            '-ss', ssTime, // ã‚·ãƒ¼ã‚¯ï¼ˆé–‹å§‹æ™‚é–“ï¼‰
            '-to', toTime, // çµ‚äº†æ™‚é–“
            '-c', 'copy', // å†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ãªã—ã§é«˜é€Ÿã‚«ãƒƒãƒˆ
            outputFileName
        );
        addLog('FFmpegå‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚', 'success');

        // 3. å‡¦ç†æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’FSã‹ã‚‰èª­ã¿è¾¼ã¿ã€Blobã«ã™ã‚‹
        const data = ffmpeg.FS('readFile', outputFileName);
        const outputBlob = new Blob([data.buffer], { type: 'audio/mp3' });
        
        // 4. ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’ä½œæˆã—ã€ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ä¿ƒã™
        const downloadUrl = URL.createObjectURL(outputBlob);
        const a = document.createElement('a');
        a.href = downloadUrl;
        a.download = `cut_${audioFile.name}`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(downloadUrl); // URLã‚’è§£æ”¾
        
        setStatus('âœ… ã‚«ãƒƒãƒˆæ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã—ãŸã€‚');

    } catch (error) {
        console.error('FFmpegå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        setStatus('âŒ å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        addLog(`è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
    } finally {
        // 5. ä»®æƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã¨çŠ¶æ…‹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        try {
            ffmpeg.FS('unlink', inputFileName);
            ffmpeg.FS('unlink', outputFileName);
        } catch(e) { /* ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦– */ }
        setIsProcessing(false);
    }
  };

  return (
    <div className="container">
      <h2>ğŸµ ãƒ­ãƒ¼ã‚«ãƒ«MP3ã‚«ãƒƒã‚¿ãƒ¼ (Wasm powered)</h2>
      <p>âš ï¸ æ³¨æ„: ã™ã¹ã¦ã®å‡¦ç†ã¯ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§å®Œçµã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã›ã‚“ã€‚</p>
      
      <input 
        type="file" 
        accept="audio/mp3" 
        onChange={handleFileUpload} 
        disabled={!isReady || isProcessing}
      />
      
      <p>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: <span className={isReady && !isProcessing ? 'success' : isProcessing ? 'processing' : ''}>{status}</span></p>

      {audioFile && duration > 0 && (
        <div className="controls">
          <h3>ãƒ•ã‚¡ã‚¤ãƒ«: {audioFile.name} (å…¨é•·: {duration.toFixed(2)}ç§’)</h3>
          
          <div>
            é–‹å§‹æ™‚é–“ (ç§’): 
            <input 
              type="number" 
              step="0.1" 
              value={startTime} 
              onChange={(e) => setStartTime(Math.max(0, Math.min(Number(e.target.value), endTime)))} 
              min="0" 
              max={duration.toFixed(2)} 
              disabled={isProcessing}
            />
          </div>
          <div>
            çµ‚äº†æ™‚é–“ (ç§’): 
            <input 
              type="number" 
              step="0.1" 
              value={endTime} 
              onChange={(e) => setEndTime(Math.min(duration, Math.max(Number(e.target.value), startTime)))} 
              min={startTime.toFixed(2)} 
              max={duration.toFixed(2)} 
              disabled={isProcessing}
            />
          </div>
          
          <p>ã‚«ãƒƒãƒˆå¾Œã®é•·ã•: **{(endTime - startTime).toFixed(2)}ç§’**</p>
          
          <button onClick={executeCut} disabled={isProcessing || !isReady}>
            {isProcessing ? 'å‡¦ç†ä¸­...ãŠå¾…ã¡ãã ã•ã„' : `âœ‚ï¸ ${startTime.toFixed(2)}ç§’ã‹ã‚‰${endTime.toFixed(2)}ç§’ã¾ã§ã‚«ãƒƒãƒˆ`}
          </button>

          <p>ï¼ˆæ³¨: æ­£ç¢ºãªãƒ•ãƒ¬ãƒ¼ãƒ ä½ç½®ã§ã‚«ãƒƒãƒˆã™ã‚‹ãŸã‚ã€æŒ‡å®šã—ãŸæ™‚é–“ã¨è‹¥å¹²ã®èª¤å·®ãŒç”Ÿã˜ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ï¼‰</p>
        </div>
      )}
      
      <div className="log-area">
        <strong>å‡¦ç†ãƒ­ã‚°:</strong>
        {logMessages.map((log, index) => (
            <p key={index} className={log.type}>[{log.timestamp}] {log.message}</p>
        ))}
      </div>
    </div>
  );
}

ReactDOM.render(<AudioEditor />, document.getElementById('root'));
</script>

</body>
</html>
