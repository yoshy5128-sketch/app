<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP3 CUTTER</title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7.3.0/dist/wavesurfer.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7.3.0/dist/plugins/regions.min.js"></script>

    <style>
        /* ‚òÖ‚òÖ‚òÖ „ÉÄ„Éº„ÇØ„É¢„Éº„ÉâÂü∫Êú¨Ë®≠ÂÆö ‚òÖ‚òÖ‚òÖ */
        body { 
            font-family: 'Segoe UI', Tahoma, sans-serif; 
            margin: 0; 
            background: #1c1c1c; /* „ÉÄ„Éº„ÇØËÉåÊôØ */
            color: #f0f0f0; /* Êòé„Çã„ÅÑÊñáÂ≠óËâ≤ */
        }
        .container { 
            max-width: 950px; 
            margin: 30px auto; 
            padding: 25px; 
            background: #2a2a2a; /* „Ç´„Éº„ÉâËÉåÊôØËâ≤ */
            border-radius: 12px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); /* ÂΩ±„ÇíÂº∑Ë™ø */
        }
        h2 { 
            text-align: center; 
            color: #00c853; /* „Ç¢„ÇØ„Çª„É≥„Éà„Ç´„É©„Éº */
            margin-bottom: 30px; 
            letter-spacing: 2px;
        }
        
        /* „Çπ„ÉÜ„Éº„Çø„Çπ„Éê„Éº */
        .status-bar { 
            padding: 10px; 
            border-radius: 8px; 
            margin-bottom: 20px; 
            text-align: center; 
            font-size: 0.9em; 
            font-weight: bold; 
        }
        .status-info { background: #004d40; color: #00c853; } /* „ÉÄ„Éº„ÇØ„Ç∞„É™„Éº„É≥Á≥ª */
        .status-success { background: #00c853; color: #1c1c1c; font-weight: bold; }
        .status-error { background: #b71c1c; color: #ffeb3b; }

        /* „Éï„Ç°„Ç§„É´„Éâ„É≠„ÉÉ„Éó„Ç®„É™„Ç¢ */
        .file-drop-area { 
            border: 2px dashed #00c853; 
            padding: 20px; 
            text-align: center; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: 0.2s; 
            background: #333333; 
            margin-bottom: 15px; 
            font-size: 1.1em;
        }
        .file-drop-area:hover { background: #3a3a3a; border-color: #38ef7d; }

        /* Ê≥¢ÂΩ¢„Ç≥„É≥„ÉÜ„Éä */
        #scroll-wrapper {
            width: 100%; overflow-x: scroll !important; overflow-y: hidden;
            border: 1px solid #444444; border-radius: 4px; height: 200px; 
            -ms-overflow-style: none; scrollbar-width: none; 
        }
        #scroll-wrapper::-webkit-scrollbar { display: none; }

        #waveform { width: fit-content; min-width: 100%; height: 100%; position: relative; overflow: visible !important; }
        #waveform > div { overflow: visible !important; height: 100% !important; }

        /* ‚òÖ‚òÖ‚òÖ „Ç´„Çπ„Çø„É†„Éè„É≥„Éâ„É´ ‚òÖ‚òÖ‚òÖ */
        #handle-container {
            width: 100%; height: 25px; position: relative; margin-top: 5px; background: #3a3a3a; 
            border-radius: 3px; cursor: grab; overflow: hidden; 
        }
        #custom-handle {
            height: 100%; background: #00796b; /* „Éè„É≥„Éâ„É´„ÇíÊøÉ„ÅÑ„Ç¢„ÇØ„Çª„É≥„Éà„Ç´„É©„Éº„Å´ */
            position: absolute; top: 0; left: 0; border-radius: 3px; 
            min-width: 40px; cursor: grab; transition: width 0.1s ease; 
        }
        
        /* „Ç∫„Éº„É†„Ç≥„É≥„Éà„É≠„Éº„É´ */
        .zoom-controls { 
            display: flex; align-items: center; justify-content: flex-end; 
            gap: 10px; margin-bottom: 10px; font-size: 0.9em; color: #bbbbbb; 
        }
        input[type="range"] { 
            width: 150px; cursor: pointer; 
            filter: invert(0.8); /* „ÉÄ„Éº„ÇØ„É¢„Éº„Éâ„Åß„Çπ„É©„Ç§„ÉÄ„Éº„ÇíË¶ã„ÇÑ„Åô„ÅèË™øÊï¥ */
        }
        
        /* „Çø„Ç§„É†Ë°®Á§∫„Å®„Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ */
        .controls-panel { 
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; 
            margin-top: 25px; padding: 20px; background: #333333; border-radius: 10px; 
        }
        .time-group { display: flex; flex-direction: column; gap: 15px; align-items: center; }
        .time-box { 
            text-align: center; 
            font-family: 'Roboto Mono', monospace; 
            font-size: 1.2em; 
            background: #444444; 
            color: #00c853; /* „Ç¢„ÇØ„Çª„É≥„Éà„Ç´„É©„Éº */
            padding: 8px; 
            border-radius: 6px; 
            border: 1px solid #555555; 
            width: 90%; 
        }
        .time-box small { color: #aaaaaa; display: block; margin-bottom: 2px; font-size: 0.7em; }

        /* „Éú„Çø„É≥ */
        .button-group-vertical { display: flex; flex-direction: column; gap: 10px; align-items: center; justify-content: center; }
        .btn-main { 
            padding: 12px 30px; 
            border: none; 
            border-radius: 25px; /* ‰∏∏„ÅÑ„Éá„Ç∂„Ç§„É≥ */
            font-weight: bold; 
            cursor: pointer; 
            font-size: 1.0em; 
            color: #1c1c1c; 
            transition: all 0.2s; 
            min-width: 160px; 
            display: flex; align-items: center; justify-content: center; gap: 8px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        .btn-play { 
            background: #ffb300; /* Êòé„Çã„ÅÑ„Ç™„É¨„É≥„Ç∏ */
            color: #1c1c1c; 
        }
        .btn-play:hover { background: #ffc107; transform: translateY(-1px); box-shadow: 0 5px 10px rgba(0,0,0,0.4); }
        
        .btn-region { 
            background: #00c853; /* „Ç¢„ÇØ„Çª„É≥„Éà„ÅÆ„Ç∞„É™„Éº„É≥ */
            color: #1c1c1c;
            font-size: 1.0em; 
            padding: 12px 30px; 
            border-radius: 25px; 
        }
        .btn-region:hover { background: #38ef7d; transform: translateY(-1px); box-shadow: 0 5px 10px rgba(0,0,0,0.4); }

        .cut-section { 
            margin-top: 30px; 
            text-align: center; 
            border-top: 1px solid #444444; 
            padding-top: 25px; 
        }
        .cut-section p strong { color: #00c853; }
        
        .btn-cut { 
            background: #2196f3; 
            width: 100%; 
            max-width: 400px; 
            padding: 18px; 
            border-radius: 10px; 
            font-size: 1.3em; 
            color: white; 
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.3);
        }
        .btn-cut:hover:not(:disabled) { 
            background: #42a5f5; 
            box-shadow: 0 6px 15px rgba(33, 150, 243, 0.5); 
            transform: translateY(-2px);
        }
        .btn-cut:disabled { 
            background: #444444; 
            cursor: not-allowed; 
            color: #777777; 
            box-shadow: none;
            transform: none;
        }
        .helper-text { font-size: 0.85em; color: #aaaaaa; text-align: center; margin-top: 5px; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

const debounce = (func, delay) => {
    let timeout;
    return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
    };
};

const CORE_URL = 'https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js';
const ffmpeg = FFmpeg.createFFmpeg({ log: true, corePath: CORE_URL, mainName: 'main' });

const formatTime = (seconds) => {
    if (!seconds && seconds !== 0) return "00:00.00";
    const date = new Date(seconds * 1000);
    const mm = String(date.getUTCMinutes()).padStart(2, '0');
    const ss = String(date.getUTCSeconds()).padStart(2, '0');
    const ms = String(Math.floor(date.getMilliseconds() / 10)).padStart(2, '0');
    return `${mm}:${ss}.${ms}`;
};

function AudioEditor() {
    const [isFFmpegReady, setIsFFmpegReady] = useState(false);
    const [status, setStatus] = useState('„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ‰∏≠...');
    const [statusType, setStatusType] = useState('status-info');
    const [audioFile, setAudioFile] = useState(null);
    const [startTime, setStartTime] = useState(0);
    const [endTime, setEndTime] = useState(0);
    const [isPlaying, setIsPlaying] = useState(false);
    const [isProcessing, setIsProcessing] = useState(false);
    
    const [minZoomLevel, setMinZoomLevel] = useState(10); 
    const [maxZoomLevel, setMaxZoomLevel] = useState(500); 
    const [currentZoomLevel, setCurrentZoomLevel] = useState(50); 
    
    const [loopRegionId, setLoopRegionId] = useState(null); 

    const scrollWrapperRef = useRef(null); 
    const waveformContainerRef = useRef(null);
    const customHandleRef = useRef(null); 
    const wavesurferRef = useRef(null);
    const wsRegionsRef = useRef(null);
    
    const debouncedUpdateRegionTime = useCallback(
        debounce((region) => {
            setStartTime(Number(region.start.toFixed(3)));
            setEndTime(Number(region.end.toFixed(3)));
        }, 50),
        []
    );

    const syncHandlePosition = useCallback(() => {
        const scrollWrapper = scrollWrapperRef.current;
        const customHandle = customHandleRef.current;
        const waveformContainer = waveformContainerRef.current;
        
        if (!scrollWrapper || !customHandle || !waveformContainer) return;
        
        const containerWidth = scrollWrapper.clientWidth;
        const requiredWidth = waveformContainer.offsetWidth;
        const scrollableWidth = requiredWidth - containerWidth;
        
        if (scrollableWidth <= 0) {
            customHandle.style.opacity = 0; // „Çπ„ÇØ„É≠„Éº„É´‰∏çË¶Å„Å™„ÇâÈùûË°®Á§∫
            return;
        }

        const handleWidth = customHandle.offsetWidth;
        const maxHandleTravel = containerWidth - handleWidth;

        const scrollPercent = scrollWrapper.scrollLeft / scrollableWidth;
        const handlePosition = scrollPercent * maxHandleTravel;

        customHandle.style.transform = `translateX(${handlePosition}px)`;
        customHandle.style.opacity = 1; // „Çπ„ÇØ„É≠„Éº„É´ÂøÖË¶Å„Å™„ÇâË°®Á§∫

    }, []);


    const updateWaveformWidth = (zoomLevel) => {
        if (wavesurferRef.current && waveformContainerRef.current) {
            const duration = wavesurferRef.current.getDuration();
            if (duration) {
                const requiredWidth = Math.ceil(duration * zoomLevel);
                waveformContainerRef.current.style.width = `${requiredWidth}px`;
                
                updateCustomHandle(requiredWidth);
            }
        }
    };
    
    const updateCustomHandle = (requiredWidth) => {
        const scrollWrapper = scrollWrapperRef.current;
        const customHandle = customHandleRef.current;
        
        if (!scrollWrapper || !customHandle) return;
        
        const containerWidth = scrollWrapper.clientWidth;
        
        let handleWidth;
        if (requiredWidth <= containerWidth) {
            handleWidth = containerWidth; 
            customHandle.style.cursor = 'default';
        } else {
            handleWidth = (containerWidth / requiredWidth) * containerWidth;
            customHandle.style.cursor = 'grab';
        }
        
        customHandle.style.width = `${Math.max(handleWidth, 40)}px`;

        if (!scrollWrapper.dataset.scrollListener) {
            scrollWrapper.addEventListener('scroll', syncHandlePosition, { passive: true });
            scrollWrapper.dataset.scrollListener = 'true';
        }
        
        syncHandlePosition(); 
    };
    
    const setupHandleDrag = useCallback(() => {
        const customHandle = customHandleRef.current;
        const scrollWrapper = scrollWrapperRef.current;
        
        if (!customHandle || !scrollWrapper) return;
        
        let startX = 0;
        let startHandleLeft = 0;
        let isDown = false;
        
        const handleContainer = customHandleRef.current.parentNode;
        const containerWidth = scrollWrapper.clientWidth;
        
        const handleDragStart = (e) => {
            if (customHandle.style.opacity === '0') return;
            isDown = true;
            e.preventDefault(); 
            e.stopPropagation(); 
            
            const clientX = e.touches ? e.touches[0].pageX : e.pageX;
            startX = clientX;
            
            const transformMatch = customHandle.style.transform.match(/translateX\(([^)]+)px\)/);
            startHandleLeft = transformMatch ? parseFloat(transformMatch[1]) : 0;

            customHandle.style.cursor = 'grabbing';
            customHandle.style.transition = 'none'; 
        };

        const handleDragMove = (e) => {
            if (!isDown) return;
            e.preventDefault();
            
            const clientX = e.touches ? e.touches[0].pageX : e.pageX;
            const dragDistance = clientX - startX;
            
            let newHandleLeft = startHandleLeft + dragDistance;
            
            const handleWidth = customHandle.offsetWidth;
            const maxHandleTravel = containerWidth - handleWidth;

            const clampedLeft = Math.min(Math.max(0, newHandleLeft), maxHandleTravel);
            
            customHandle.style.transform = `translateX(${clampedLeft}px)`;

            const scrollableWidth = waveformContainerRef.current.offsetWidth - containerWidth;
            if (maxHandleTravel > 0) {
                const scrollPercent = clampedLeft / maxHandleTravel;
                scrollWrapper.scrollLeft = scrollPercent * scrollableWidth;
            }
        };

        const handleDragEnd = () => {
            if (!isDown) return;
            isDown = false;
            customHandle.style.cursor = 'grab';
            customHandle.style.transition = 'width 0.1s ease'; 
            
            syncHandlePosition();
        };

        handleContainer.addEventListener('touchstart', handleDragStart, { passive: false });
        handleContainer.addEventListener('touchmove', handleDragMove, { passive: false });
        handleContainer.addEventListener('touchend', handleDragEnd);
        handleContainer.addEventListener('mousedown', handleDragStart, { passive: false });
        window.addEventListener('mousemove', handleDragMove);
        window.addEventListener('mouseup', handleDragEnd);

    }, [syncHandlePosition]); 
    
    useEffect(() => {
        const ws = wavesurferRef.current;
        if (!ws) return;

        const handlePause = () => {
            ws.un('audioprocess');
            setLoopRegionId(null);
        };

        ws.on('pause', handlePause);
        ws.on('finish', handlePause);

        return () => {
            ws.un('pause', handlePause);
            ws.un('finish', handlePause);
            ws.un('audioprocess');
        };
    }, []); 

    const initWaveSurfer = (file) => {
        if (wavesurferRef.current) {
            wavesurferRef.current.destroy();
        }

        const ws = WaveSurfer.create({
            container: waveformContainerRef.current,
            waveColor: '#4caf50', /* Ê≥¢ÂΩ¢„ÅÆËâ≤„Çí„Ç¢„ÇØ„Çª„É≥„Éà„Å´Âêà„Çè„Åõ„Å¶Â§âÊõ¥ */
            progressColor: '#ffb300', /* ÂÜçÁîü‰∏≠„ÅÆËâ≤„Çí„Ç™„É¨„É≥„Ç∏„Å´ */
            cursorColor: '#ff1744',
            barWidth: 2,
            height: 160, 
            autoScroll: true,
            normalize: true,
            minPxPerSec: 1, 
            url: URL.createObjectURL(file),
            scrollParent: false, 
            hideScrollbar: true 
        });

        const wsRegions = ws.registerPlugin(WaveSurfer.Regions.create());
        wsRegionsRef.current = wsRegions;
        wavesurferRef.current = ws;

        ws.on('ready', () => {
            const duration = ws.getDuration();
            
            setTimeout(() => {
                const containerWidth = scrollWrapperRef.current.clientWidth;
                const calculatedMinZoom = Math.max(1, Math.ceil(containerWidth / duration));
                
                setMinZoomLevel(calculatedMinZoom);
                setCurrentZoomLevel(calculatedMinZoom); 
                ws.zoom(calculatedMinZoom); 
                
                updateWaveformWidth(calculatedMinZoom);
                setupHandleDrag();
                
                scrollWrapperRef.current.scrollLeft = 0;
                syncHandlePosition(); 

                setEndTime(duration);
                setStatus(`Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü: ${file.name}`);
                setStatusType('status-success');

                wsRegions.clearRegions();
                const initialRegion = wsRegions.addRegion({
                    start: duration * 0.1,
                    end: duration * 0.9,
                    color: 'rgba(0, 200, 83, 0.3)', /* „É™„Éº„Ç∏„Éß„É≥„ÅÆËâ≤„Çí„Ç¢„ÇØ„Çª„É≥„Éà„Å´Âêà„Çè„Åõ„Å¶Â§âÊõ¥ */
                    drag: true,
                    resize: true 
                });
                
                setLoopRegionId(initialRegion.id);

                wsRegions.on('region-updated', (region) => {
                    debouncedUpdateRegionTime(region);
                });
                
                wsRegions.on('region-clicked', (region, e) => {
                    e.stopPropagation();
                    ws.play(region.start, region.end); 
                });


                setStartTime(Number(initialRegion.start.toFixed(3)));
                setEndTime(Number(initialRegion.end.toFixed(3)));

            }, 50); 
        });
        ws.on('play', () => setIsPlaying(true));
        ws.on('pause', () => setIsPlaying(false));
        ws.on('finish', () => setIsPlaying(false));
    };


    const handleZoomChange = (e) => {
        const newZoom = Number(e.target.value);
        setCurrentZoomLevel(newZoom);
        if (wavesurferRef.current) {
            wavesurferRef.current.zoom(newZoom);
            updateWaveformWidth(newZoom);
            
            if (newZoom === minZoomLevel) {
                scrollWrapperRef.current.scrollLeft = 0;
                syncHandlePosition(); 
            }
            syncHandlePosition();
        }
    };
    
    useEffect(() => { 
        const load = async () => {
            try {
                if (!ffmpeg.isLoaded()) await ffmpeg.load();
                setIsFFmpegReady(true);
                setStatus('Ê∫ñÂÇôÂÆå‰∫Ü„ÄÇMP3„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                setStatusType('status-info');
            } catch (e) {
                setStatus('‚ùå FFmpeg„ÅÆËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                setStatusType('status-error');
            }
        };
        load();
        
        return () => {
            if (wavesurferRef.current) wavesurferRef.current.destroy();
        };
    }, []);
    
    const togglePlay = () => {
        if (wavesurferRef.current) {
            if (isPlaying && loopRegionId) {
                wavesurferRef.current.un('audioprocess');
                setLoopRegionId(null);
            }
            wavesurferRef.current.playPause();
        }
    };

    const playRegionLoop = () => {
        const ws = wavesurferRef.current;
        const regions = wsRegionsRef.current.getRegions();
        
        if (!ws || !regions || Object.keys(regions).length === 0) return;

        const region = regions[Object.keys(regions)[0]]; 

        if (isPlaying && loopRegionId === region.id) {
            ws.pause();
            setLoopRegionId(null);
            ws.un('audioprocess');
            return;
        }

        setLoopRegionId(region.id); 
        
        ws.setTime(region.start); 
        
        const loopId = region.id;
        const handleAudioProcess = (currentTime) => {
            if (currentTime >= region.end) {
                ws.setTime(region.start);
            }
        };
        
        ws.un('audioprocess');
        ws.on('audioprocess', handleAudioProcess);
        
        ws.play(); 
    };

    const handleFileUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        setAudioFile(file);
        setStatus('Ê≥¢ÂΩ¢„ÇíËß£Êûê‰∏≠... („Éï„Ç°„Ç§„É´ÂΩ¢Âºè„ÉÅ„Çß„ÉÉ„ÇØ‰∏≠)');
        setStatusType('status-info');

        const reader = new FileReader();
        reader.onload = (evt) => {
            const audioData = evt.target.result;
            const ac = new (window.AudioContext || window.webkitAudioContext)();
            
            ac.decodeAudioData(audioData, 
                (buffer) => {
                    initWaveSurfer(file); 
                    ac.close();
                }, 
                (err) => {
                    console.error("AudioContext Decode Error:", err);
                    setStatus('‚ùå „Ç®„É©„Éº: Èü≥Â£∞„Éá„Éº„Çø„ÅÆËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂà•„ÅÆ„Éï„Ç°„Ç§„É´„ÅßË©¶„Åô„Åã„ÄÅÂÜç„Ç®„É≥„Ç≥„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    setStatusType('status-error');
                    ac.close();
                }
            );
        };
        reader.readAsArrayBuffer(file);
    };

    const executeCut = async () => {
        if (!audioFile || !isFFmpegReady || startTime >= endTime) return;
        
        setIsProcessing(true);
        setStatus('„Ç´„ÉÉ„ÉàÂá¶ÁêÜ‰∏≠... (ÁîªÈù¢„ÇíÈñâ„Åò„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ)');
        setStatusType('status-info');
        
        if (isPlaying) {
             wavesurferRef.current.pause();
        }

        try {
            const inputName = 'input.mp3';
            const outputName = 'output.mp3';
            
            ffmpeg.FS('writeFile', inputName, await FFmpeg.fetchFile(audioFile));

            await ffmpeg.run(
                '-i', inputName,
                '-ss', startTime.toString(),
                '-to', endTime.toString(),
                '-c', 'copy',
                outputName
            );

            const data = ffmpeg.FS('readFile', outputName);
            const blob = new Blob([data.buffer], { type: 'audio/mp3' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `cut_${audioFile.name}`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);

            setStatus('„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂÆå‰∫ÜÔºÅ');
            setStatusType('status-success');
        } catch (e) {
            console.error(e);
            setStatus('‚ùå Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Ç≥„É≥„ÇΩ„Éº„É´„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            setStatusType('status-error');
        } finally {
            try {
                ffmpeg.FS('unlink', 'input.mp3');
                ffmpeg.FS('unlink', 'output.mp3');
            } catch(e) {}
            setIsProcessing(false);
        }
    };

    return (
        <div className="container">
            <h2>MP3 CUTTER</h2>
            
            <div className={`status-bar ${statusType}`}>{status}</div>

            <div className="file-drop-area">
                <input 
                    type="file" 
                    accept="audio/*" 
                    onChange={handleFileUpload} 
                    style={{display: 'none'}} 
                    id="fileInput"
                    disabled={!isFFmpegReady || isProcessing}
                />
                <label htmlFor="fileInput" style={{cursor: 'pointer', display: 'block', width: '100%'}}>
                    {audioFile ? `üìÇ ${audioFile.name}` : 'MP3„Éï„Ç°„Ç§„É´„Çí„Éâ„É≠„ÉÉ„Éó„Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„É≠„Éº„Éâ'}
                </label>
            </div>

            {audioFile && (
                <>
                    <div className="zoom-controls">
                        <label>üîç „Ç∫„Éº„É†:</label>
                        <input 
                            type="range" 
                            min={minZoomLevel} 
                            max={maxZoomLevel} 
                            value={currentZoomLevel} 
                            onChange={handleZoomChange} 
                        />
                    </div>
                    
                    <div id="scroll-wrapper" ref={scrollWrapperRef}>
                        <div id="waveform" ref={waveformContainerRef}></div>
                    </div>
                    
                    <div id="handle-container">
                        <div id="custom-handle" ref={customHandleRef}></div>
                    </div>

                    <p className="helper-text">
                        Ê≥¢ÂΩ¢‰∏ã„ÅÆÂ§™„ÅÑ„Éê„Éº„Çí„Çπ„ÉØ„Ç§„Éó„Åó„Å¶„ÄÅË°®Á§∫ÁØÑÂõ≤„ÇíÁßªÂãï„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
                    </p>

                    <div className="controls-panel">
                        <div className="time-group">
                            <div className="time-box">
                                <small>START</small>
                                {formatTime(startTime)}
                            </div>
                            <div className="time-box">
                                <small>END</small>
                                {formatTime(endTime)}
                            </div>
                        </div>

                        <div className="button-group-vertical">
                            <button className="btn-main btn-play" onClick={togglePlay} disabled={!wavesurferRef.current || isProcessing}>
                                {isPlaying && !loopRegionId ? '‚è∏ PAUSE' : '‚ñ∂Ô∏è PLAY ALL'}
                            </button>
                            <button 
                                className="btn-main btn-region" 
                                onClick={playRegionLoop} 
                                disabled={!wavesurferRef.current || isProcessing}
                            >
                                {isPlaying && loopRegionId ? '‚èπ STOP LOOP' : 'üîÅ LOOP REGION'}
                            </button>
                        </div>
                    </div>

                    <div className="cut-section">
                        <p>Duration: <strong>{((endTime - startTime) || 0).toFixed(2)} sec</strong></p>
                        <button className="btn-main btn-cut" onClick={executeCut} disabled={isProcessing || startTime >= endTime}>
                            {isProcessing ? 'PROCESSING...' : '‚úÇÔ∏è CUT & DOWNLOAD'}
                        </button>
                    </div>
                </>
            )}
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<AudioEditor />);
</script>
</body>
</html>
