<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D City Builder FPS</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui {
            position: absolute; top: 10px; left: 10px; color: #00f0ff;
            background: rgba(0,10,30,0.8); padding: 10px; border-radius: 5px;
            font-size: 11px; z-index: 100; border: 1px solid #00f0ff;
        }
        #controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 200; }
        button { padding: 12px 24px; background: #00f0ff; border: none; border-radius: 30px; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

<div id="ui">
    <b>3D CITY ENGINE</b><br>
    Status: <span id="status">Ready</span><br>
    Buildings: <span id="b-count">0</span>
</div>

<div id="controls"><button id="btn-start">3D都市を生成・開始</button></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, player, buildingsGroup;
    let currentPos = { lat: 35.6895, lon: 139.6917 }; // 初期: 東京駅付近

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        scene.fog = new THREE.Fog(0x000510, 50, 200);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        buildingsGroup = new THREE.Group();
        scene.add(buildingsGroup);

        player = new THREE.Group();
        scene.add(player);
        player.add(camera);
        camera.position.set(0, 30, 40); // 街を見下ろす俯瞰視点
        camera.lookAt(0, 0, 0);

        // 地面のグリッド
        scene.add(new THREE.GridHelper(500, 50, 0x004466, 0x002233));

        animate();
        fetchBuildings(currentPos.lat, currentPos.lon);
    }

    // Overpass APIから周囲の建物データを取得
    async function fetchBuildings(lat, lon) {
        document.getElementById('status').innerText = "Fetching Buildings...";
        const range = 0.002; // 約200m範囲
        const query = `[out:json];way["building"](${lat-range},${lon-range},${lat+range},${lon+range});out body;>;out skel qt;`;
        const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

        try {
            const response = await fetch(url);
            const data = await response.json();
            renderBuildings(data, lat, lon);
        } catch (e) {
            document.getElementById('status').innerText = "API Error";
        }
    }

    function renderBuildings(data, originLat, originLon) {
        buildingsGroup.clear();
        const nodes = {};
        data.elements.filter(e => e.type === 'node').forEach(n => nodes[n.id] = n);

        let count = 0;
        data.elements.filter(e => e.type === 'way').forEach(way => {
            const points = way.nodes.map(id => nodes[id]).filter(n => n);
            if (points.length < 3) return;

            const shape = new THREE.Shape();
            points.forEach((p, i) => {
                const x = (p.lon - originLon) * 91000;
                const z = (p.lat - originLat) * 111000;
                if (i === 0) shape.moveTo(x, -z);
                else shape.lineTo(x, -z);
            });

            const height = (way.tags && way.tags['building:levels'] ? way.tags['building:levels'] * 3 : 10);
            const geometry = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
            const material = new THREE.MeshPhongMaterial({ color: 0x0088ff, transparent: true, opacity: 0.7, wireframe: true });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2; // 地面に水平にする
            buildingsGroup.add(mesh);
            count++;
        });

        document.getElementById('status').innerText = "Online";
        document.getElementById('b-count').innerText = count;
        
        // 環境光を追加
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 50, 10);
        scene.add(light);
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    document.getElementById('btn-start').onclick = () => {
        init();
        document.getElementById('btn-start').style.display = 'none';
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(p => {
                currentPos.lat = p.coords.latitude;
                currentPos.lon = p.coords.longitude;
                fetchBuildings(currentPos.lat, currentPos.lon);
            });
        }
    };
</script>
</body>
</html>
