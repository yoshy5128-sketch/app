<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Descent Maze - Stable Camera Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Georgia', serif; touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        
        /* UI Elements */
        #ui-overlay { position: absolute; top: 15px; left: 15px; color: gold; font-size: 20px; font-weight: bold; text-shadow: 2px 2px 4px black; z-index: 15; pointer-events: none; }
        #stage-label { position: absolute; top: 15px; right: 15px; color: white; font-size: 16px; text-align: right; pointer-events: none; }
        #stage-announcement { position: absolute; width: 100%; top: 30%; text-align: center; color: white; font-size: 2.5em; text-shadow: 0 0 15px rgba(255,255,255,0.5); pointer-events: none; opacity: 0; transition: opacity 1s; z-index: 20; }
        
        /* Menu Screens */
        #instructions, #clear-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            background: rgba(0,0,0,0.9); color: white; text-align: center; z-index: 100; 
        }
        #clear-screen { display: none; }
        
        .menu-buttons { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; z-index: 101;}
        button { padding: 15px 40px; font-size: 1.1em; cursor: pointer; background: #4a3c2c; color: #ffd700; border: 1px solid #ffd700; border-radius: 4px; transition: 0.2s; min-width: 250px; touch-action: manipulation; }
        button:active { background: #ffd700; color: #000; }
        #btn-continue { display: none; background: #2c3e4a; }

        /* Mobile Controls UI */
        .mobile-ui { display: none !important; position: absolute; z-index: 50; touch-action: none; }
        .is-mobile .mobile-ui { display: flex !important; }

        /* Joystick */
        #joystick-zone { bottom: 30px; left: 30px; width: 140px; height: 140px; position: absolute; z-index: 50; }
        #joystick-container { 
            width: 100%; height: 100%; 
            background: rgba(255, 255, 255, 0.1); 
            border: 2px solid rgba(255, 255, 255, 0.3); 
            border-radius: 50%; 
            position: relative;
            display: flex; justify-content: center; align-items: center;
        }
        #joystick-knob { 
            position: absolute; width: 50px; height: 50px; 
            background: rgba(255, 255, 255, 0.5); 
            border-radius: 50%; 
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            pointer-events: none; 
            transform: translate(0px, 0px);
        }

        /* Jump Button */
        #jump-button { 
            bottom: 40px; right: 30px; width: 90px; height: 90px; 
            background: rgba(255, 255, 255, 0.2); 
            border: 3px solid rgba(255,255,255,0.6); 
            border-radius: 50%; 
            display: flex; justify-content: center; align-items: center; 
            font-weight: bold; color: white; font-size: 1.2em;
            user-select: none;
        }
        #jump-button:active { background: rgba(255, 255, 255, 0.5); transform: scale(0.95); }

        /* Camera Touch Area (Right side of screen) */
        #touch-camera-area { 
            top: 0; right: 0; width: 50%; height: 100%; 
            position: absolute; z-index: 40; 
        }

        /* Landscape Warning */
        #rotate-warning { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: gold; z-index: 999; justify-content: center; align-items: center; text-align: center; flex-direction: column; }
        @media screen and (orientation: portrait) {
            .is-mobile #rotate-warning { display: flex; }
        }
    </style>
</head>
<body id="game-body">
    <div id="rotate-warning">
        <h1>PLEASE ROTATE DEVICE</h1>
        <p>This game requires landscape mode.</p>
    </div>

    <audio id="bgm" src="wind.mp3" loop></audio>
    <audio id="sfx-get" src="get.mp3"></audio>
    <audio id="sfx-fall" src="gan.mp3"></audio>
    <audio id="sfx-clear" src="clear.mp3"></audio>

    <div id="ui-overlay">KEYS: <span id="item-count">0</span> / 4</div>
    <div id="stage-label">STAGE 1<br><span id="theme-name">THE DUST RUINS</span></div>
    <div id="stage-announcement">THE DUST RUINS</div>

    <div id="instructions">
        <h1 style="letter-spacing: 8px;">DESCENT MAZE</h1>
        <div class="menu-buttons">
            <button onclick="startGame(true)">NEW GAME</button>
            <button id="btn-continue" onclick="startGame(false)">CONTINUE (STAGE <span id="saved-stage-val"></span>)</button>
        </div>
        <p id="how-to-play" style="font-size: 0.8em; margin-top: 40px; color: #888;"></p>
    </div>

    <div id="clear-screen">
        <h1 id="status-text">STAGE CLEAR</h1>
        <button id="action-button">NEXT LEVEL</button>
    </div>

    <div id="joystick-zone" class="mobile-ui">
        <div id="joystick-container">
            <div id="joystick-knob"></div>
        </div>
    </div>
    <div id="jump-button" class="mobile-ui">JUMP</div>
    <div id="touch-camera-area" class="mobile-ui"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let currentStage = 1;
        let isGameOver = false;
        let collectedItemCount = 0;
        
        // Detect Mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (window.innerWidth < 800 && 'ontouchstart' in window);
        if (isMobile) document.getElementById('game-body').classList.add('is-mobile');

        const THEMES = [
            { name: "THE DUST RUINS", sky: 0x8b7355, fog: 0x8b7355, stair: 0x5a4a3a },
            { name: "THE POISON SWAMP", sky: 0x0a1a0a, fog: 0x0a1a0a, stair: 0x2d3d2d },
            { name: "THE ASHEN SILENCE", sky: 0x1a1a1a, fog: 0x1a1a1a, stair: 0x444444 },
            { name: "THE BLOOD TWILIGHT", sky: 0x240a0a, fog: 0x240a0a, stair: 0x4a1a1a }
        ];

        let scene, camera, renderer, controls;
        let objects = [], collectibleItems = [], goal = null, floor = null;
        
        // Movement Variables
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let targetY = 51.8, prevTime = performance.now();
        
        // --- Stable Camera Variables ---
        // 直接オイラー角を蓄積する変数（Three.jsの自動計算に依存しない）
        let cameraYaw = 0;   // 横回転
        let cameraPitch = 0; // 縦回転
        
        // Mobile Input
        let joyVector = { x: 0, y: 0 }; 

        const stairMat = new THREE.MeshStandardMaterial({ roughness: 0.8 });
        const keyMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 });

        function checkSaveData() {
            const saved = localStorage.getItem('descent_maze_stage');
            if (saved && parseInt(saved) > 1) {
                document.getElementById('btn-continue').style.display = 'block';
                document.getElementById('saved-stage-val').innerText = saved;
                return parseInt(saved);
            }
            return 1;
        }

        function saveGame(stageNum) {
            localStorage.setItem('descent_maze_stage', stageNum);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            document.body.appendChild(renderer.domElement);

            if (!isMobile) {
                controls = new PointerLockControls(camera, document.body);
                document.getElementById('how-to-play').innerText = "WASD: MOVE / SPACE: JUMP / MOUSE: LOOK";
            } else {
                document.getElementById('how-to-play').innerText = "LEFT STICK: MOVE / RIGHT SCREEN: LOOK / BUTTON: JUMP";
                setupMobileControls();
            }

            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const light = new THREE.PointLight(0xffffff, 150, 100);
            camera.add(light);
            scene.add(camera);

            window.addEventListener('resize', onWindowResize);
            checkSaveData();
            generateStage(1);
            animate();
        }

        function generateStage(stageNum) {
            currentStage = stageNum;
            const theme = THEMES[(stageNum - 1) % THEMES.length];
            scene.background = new THREE.Color(theme.sky);
            
            const fogNear = Math.max(45 - (stageNum * 3), 12);
            const fogFar = Math.max(160 - (stageNum * 6), 70);
            scene.fog = new THREE.Fog(theme.fog, fogNear, fogFar);
            stairMat.color.set(theme.stair);
            
            document.getElementById('stage-label').innerHTML = `STAGE ${stageNum}<br><span id="theme-name">${theme.name}</span>`;
            const ann = document.getElementById('stage-announcement');
            ann.innerText = theme.name; ann.style.opacity = 1;
            setTimeout(() => ann.style.opacity = 0, 3000);

            objects.forEach(o => scene.remove(o));
            collectibleItems.forEach(k => scene.remove(k));
            if(goal) scene.remove(goal);
            if(floor) scene.remove(floor);
            objects = []; collectibleItems = []; collectedItemCount = 0;
            document.getElementById('item-count').innerText = "0";

            let seed = 555 + stageNum;
            const rnd = () => { const x = Math.sin(seed++) * 10000; return x - Math.floor(x); };

            const startP = new THREE.Mesh(new THREE.BoxGeometry(10, 1.2, 10), stairMat);
            startP.position.set(0, 50, 0);
            scene.add(startP); objects.push(startP);
            
            camera.position.set(0, 51.8, 0); 
            velocity.set(0, 0, 0);
            
            // Reset Camera Rotation
            cameraYaw = 0; cameraPitch = 0;
            updateCameraRotation();

            let keyRemaining = 4;
            const maxDepth = 25 + (stageNum * 10); 
            const branchChance = Math.min(0.25 + (stageNum * 0.05), 0.5); 
            let currentPos = new THREE.Vector3(0, 50, 0);

            function createPath(startPos, startRot, depth, isMainPath) {
                let pos = startPos.clone();
                let lastRot = startRot;

                for (let i = 0; i < depth; i++) {
                    const rot = lastRot + (Math.floor(rnd() * 3) - 1) * (Math.PI / 2);
                    lastRot = rot;

                    for (let s = 0; s < 5; s++) {
                        const step = new THREE.Mesh(new THREE.BoxGeometry(4.5, 1.2, 1.6), stairMat);
                        const offset = new THREE.Vector3(0, s * -0.7, s * 1.3).applyAxisAngle(new THREE.Vector3(0,1,0), rot);
                        step.position.copy(pos).add(offset);
                        step.rotation.y = rot;
                        scene.add(step); objects.push(step);
                    }

                    const land = new THREE.Mesh(new THREE.BoxGeometry(9, 1.2, 9), stairMat);
                    const landOffset = new THREE.Vector3(0, -3.5, 9.5).applyAxisAngle(new THREE.Vector3(0,1,0), rot);
                    land.position.copy(pos).add(landOffset);
                    land.rotation.y = rot;
                    scene.add(land); objects.push(land);
                    pos.copy(land.position);

                    if ((isMainPath && i > 0 && i % 12 === 0 && keyRemaining > 1) || 
                        (!isMainPath && i === depth - 1 && keyRemaining > 0)) {
                        const k = createKey();
                        k.position.copy(land.position).add(new THREE.Vector3(0, 2.2, 0));
                        k.userData.baseY = k.position.y;
                        scene.add(k); collectibleItems.push(k);
                        keyRemaining--;
                    }

                    if (isMainPath && rnd() < branchChance && depth - i > 6) {
                        const sideRot = rot + (rnd() < 0.5 ? Math.PI/2 : -Math.PI/2);
                        const sideDepth = 5 + Math.floor(rnd() * (4 + stageNum));
                        createPath(pos.clone(), sideRot, sideDepth, false);
                    }
                    pos.y -= 5.0;
                }
                return pos;
            }

            const finalPos = createPath(currentPos, 0, maxDepth, true);

            goal = new THREE.Mesh(new THREE.CylinderGeometry(12, 12, 1000, 32), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 }));
            goal.position.set(finalPos.x, finalPos.y - 490, finalPos.z);
            goal.userData.topY = finalPos.y + 10;
            goal.visible = false;
            scene.add(goal);

            floor = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            floor.rotation.x = -Math.PI/2; floor.position.y = finalPos.y - 200;
            scene.add(floor);
            isGameOver = false;
        }

        function createKey() {
            const g = new THREE.Group();
            const r = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.1, 12, 24), keyMat); r.position.y = 0.6; g.add(r);
            const s = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.9, 12), keyMat); s.position.y = 0.2; g.add(s);
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.06), keyMat); b.position.set(0.15, 0, 0); g.add(b);
            return g;
        }

        // カメラ回転を一括適用する関数
        function updateCameraRotation() {
            // Pitch制限 (真上・真下を少し避ける)
            const minPitch = -Math.PI / 2 + 0.1;
            const maxPitch = Math.PI / 2 - 0.1;
            cameraPitch = Math.max(minPitch, Math.min(maxPitch, cameraPitch));

            // Quaternion作成 (Y回転 -> X回転の順)
            const qx = new THREE.Quaternion();
            qx.setFromAxisAngle(new THREE.Vector3(1, 0, 0), cameraPitch);
            const qy = new THREE.Quaternion();
            qy.setFromAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);
            
            // カメラに適用 (Yaw * Pitch)
            camera.quaternion.copy(qy).multiply(qx);
        }

        function setupMobileControls() {
            const joyZone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            const maxDist = 45; 

            // Joystick Logic (same as before)
            const handleJoy = (e) => {
                e.preventDefault();
                const touch = e.targetTouches[0]; 
                const rect = joyZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
                const angle = Math.atan2(dy, dx);
                const moveX = Math.cos(angle) * distance;
                const moveY = Math.sin(angle) * distance;
                knob.style.transform = `translate(${moveX}px, ${moveY}px)`;
                joyVector.x = moveX / maxDist; joyVector.y = moveY / maxDist; 
            };
            const resetJoy = (e) => {
                e.preventDefault();
                knob.style.transform = `translate(0px, 0px)`;
                joyVector.x = 0; joyVector.y = 0;
            };
            joyZone.addEventListener('touchstart', handleJoy, {passive: false});
            joyZone.addEventListener('touchmove', handleJoy, {passive: false});
            joyZone.addEventListener('touchend', resetJoy);
            
            // --- Stable Camera Logic ---
            const camArea = document.getElementById('touch-camera-area');
            let lastTouchX = 0; 
            let lastTouchY = 0;
            let activeTouchId = null; // 現在追跡中の指ID

            camArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // 追跡中の指がなければ、新しく触れた指を追跡対象にする
                if (activeTouchId === null) {
                    const t = e.changedTouches[0]; // 新しく触れた指
                    activeTouchId = t.identifier;
                    lastTouchX = t.clientX;
                    lastTouchY = t.clientY;
                }
            }, {passive: false});

            camArea.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (activeTouchId === null) return;

                // 追跡中のIDを持つ指を探す
                let touch = null;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === activeTouchId) {
                        touch = e.changedTouches[i];
                        break;
                    }
                }

                if (touch) {
                    const dx = touch.clientX - lastTouchX;
                    const dy = touch.clientY - lastTouchY;
                    const sens = 0.005;

                    // 単純変数を更新
                    cameraYaw -= dx * sens; 
                    cameraPitch -= dy * sens;

                    updateCameraRotation();

                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                }
            }, {passive: false});

            const endTouch = (e) => {
                e.preventDefault();
                // 離れた指の中に追跡中のIDがあれば追跡終了
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === activeTouchId) {
                        activeTouchId = null;
                        break;
                    }
                }
            };

            camArea.addEventListener('touchend', endTouch);
            camArea.addEventListener('touchcancel', endTouch);

            const btnJump = document.getElementById('jump-button');
            btnJump.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if(canJump) { velocity.y += 17; canJump = false; }
            }, {passive: false});
        }

        function enterFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) { elem.requestFullscreen().catch(err => console.log(err)); }
            else if (elem.webkitRequestFullscreen) { elem.webkitRequestFullscreen(); }
        }

        window.startGame = (isNew) => {
            if (isMobile) enterFullscreen();
            const saved = checkSaveData();
            const startStage = isNew ? 1 : saved;
            generateStage(startStage);
            document.getElementById('instructions').style.display = 'none';
            if(!isMobile && controls) controls.lock();
            document.getElementById('bgm').play().catch(()=>{});
        };

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);

            if (!isGameOver) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 42.0 * delta; 

                // Camera Direction for Movement (Derived directly from current Quaternion)
                const camFwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                camFwd.y = 0; camFwd.normalize();
                const camRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                camRight.y = 0; camRight.normalize();

                let moveX = 0; let moveZ = 0;

                if (moveForward) moveZ += 1; if (moveBackward) moveZ -= 1;
                if (moveLeft) moveX -= 1; if (moveRight) moveX += 1;

                if (Math.abs(joyVector.y) > 0.1) moveZ += (-joyVector.y);
                if (Math.abs(joyVector.x) > 0.1) moveX += joyVector.x;

                if (Math.abs(moveX) > 0 || Math.abs(moveZ) > 0) {
                    velocity.x += (camFwd.x * moveZ + camRight.x * moveX) * 75 * delta;
                    velocity.z += (camFwd.z * moveZ + camRight.z * moveX) * 75 * delta;
                }

                camera.position.x += velocity.x * delta;
                camera.position.z += velocity.z * delta;

                const ray = new THREE.Raycaster(camera.position, new THREE.Vector3(0, -1, 0), 0, 4);
                const hit = ray.intersectObjects(objects);
                let onObj = false;
                if(hit.length > 0) {
                    const gY = hit[0].point.y + 1.8;
                    if(camera.position.y <= gY + 1.0 && velocity.y < 0) { velocity.y = 0; canJump = true; targetY = gY; onObj = true; }
                }

                if(!onObj) camera.position.y += velocity.y * delta;
                else camera.position.y += (targetY - camera.position.y) * 0.3;

                collectibleItems.forEach((k, i) => {
                    k.rotation.y += delta * 3;
                    k.position.y = k.userData.baseY + Math.sin(time*0.004)*0.25;
                    if(camera.position.distanceTo(k.position) < 3.2) {
                        document.getElementById('sfx-get').currentTime=0; document.getElementById('sfx-get').play().catch(()=>{});
                        scene.remove(k); collectibleItems.splice(i, 1);
                        collectedItemCount++; document.getElementById('item-count').innerText = collectedItemCount;
                        if(collectedItemCount === 4) goal.material.color.set(0x00ff00);
                    }
                });

                if(camera.position.y < 20) goal.visible = true;
                if(camera.position.y < floor.position.y + 50) {
                    isGameOver = true; document.getElementById('sfx-fall').play().catch(()=>{});
                    showEndScreen("FELL INTO THE ABYSS", "RETRY STAGE", () => {
                        document.getElementById('clear-screen').style.display='none';
                        generateStage(currentStage); if(!isMobile && controls) controls.lock();
                    });
                }
                
                if(goal.visible && collectedItemCount >= 4) {
                    const d = new THREE.Vector2(camera.position.x-goal.position.x, camera.position.z-goal.position.z).length();
                    if(d < 12 && Math.abs(camera.position.y - goal.userData.topY) < 15) {
                        isGameOver = true;
                        const next = currentStage + 1;
                        saveGame(next);
                        showEndScreen("LEVEL COMPLETED", "DESCEND DEEPER", () => {
                            document.getElementById('clear-screen').style.display='none';
                            document.getElementById('bgm').play().catch(()=>{}); generateStage(next);
                            if(!isMobile && controls) controls.lock();
                        }, true);
                    }
                }
            }
            prevTime = time; renderer.render(scene, camera);
        }

        function showEndScreen(text, btnText, btnAction, isClear = false) {
            document.getElementById('status-text').innerText = text;
            const btn = document.getElementById('action-button');
            btn.innerText = btnText; btn.onclick = btnAction;
            document.getElementById('clear-screen').style.display = 'flex';
            if(isClear) { document.getElementById('bgm').pause(); document.getElementById('sfx-clear').play().catch(()=>{}); }
            if(!isMobile && controls) controls.unlock();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        document.addEventListener('keydown', e => {
            if(e.code==='KeyW') moveForward=true; if(e.code==='KeyS') moveBackward=true;
            if(e.code==='KeyA') moveLeft=true; if(e.code==='KeyD') moveRight=true;
            if(e.code==='Space' && canJump) { velocity.y+=17; canJump=false; }
        });
        document.addEventListener('keyup', e => {
            if(e.code==='KeyW') moveForward=false; if(e.code==='KeyS') moveBackward=false;
            if(e.code==='KeyA') moveLeft=false; if(e.code==='KeyD') moveRight=false;
        });

        init();
    </script>
</body>
</html>